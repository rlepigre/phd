\Include{Macros}

\Caml(
  open ProofTree
  open Diagrams
  open PMLVerbatim
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\mathsize{3.}{\wbox}$>
  let bbox = <$\mathsize{3.}{\bbox}$>
)

\Configure_math_macro{\v}{ syntax = string; }
\Configure_math_macro{\t}{ syntax = string; }
\Configure_math_macro{\s}{ syntax = string; }
\Configure_math_macro{\p}{ syntax = string; }
\Configure_math_macro{\f}{ syntax = string; }
\Configure_math_macro{\vs}{ syntax = string; }
\Configure_math_macro{\ss}{ syntax = string; }
\Configure_math_macro{\ts}{ syntax = string; }

=> Implementation and examples \label("implem")

In this last chapter, we consider examples of programs and proofs that can be
written and manipulated using our prototype implementation. This restricted
set of examples is not intended to give an exhaustive view of our language.
Their only purpose is to demonstrate its expressiveness through a selected
set of examples that seem interesting to the author. This chapter also
contains some discussions on possible extensions and improvement on the
system and its implementation.

=> Encoding of strict product types

As discussed in the previous chapter, the most natural semantics for product
types in presence of subtyping allows for extensible records. In other words,
it is alway possible to provide more fields than necessary. However, product
types with a fixed set of fields often arise in practice. For this reason, we
introduced so-called strict product types, which were used to state our type
safety theorem (\theorem("fullsafety")). In this section, we will show that
it is possible to encode strict records into the system, without extending
it with two different forms of product types.

Let us first consider the "unit" type, corresponding to the empty product.
In our system, a first attempt at defining such a type would be to use an
extensible record with no fields. However, as indicated by its name, this
type contains many more elements that the empty record (written ##{}## in
our system).
### PML "examples/realunit.pml"
type wrong_unit = {⋯}

// It is inhabited by the empty record.
val u : wrong_unit = {}

// And in fact by any record...
val u_aux : wrong_unit = {l = {}}
###

To avoid extending the system with strict record types, it is possible to
use one of the following three encodings for the ##unit## type. They rely
on the membership type, optionally combined with existential quantification
and restriction.
### PML "examples/realunit.pml"
type unit1 = {} ∈ {⋯}
type unit2 = ∃x:ι, x ∈ ({⋯} | x ≡ {})
type unit3 = ∃x:ι, x ∈ {⋯} | x ≡ {}
###
Note that these types are all equivalent semantically. In the implementation,
we chose to use the definition ##unit1## in place of the syntactic sugar
##{}## (strict product type with no fields). We can thus use the following
definition for a reasonable ##unit## type.
### PML "examples/realunit.pml"
def unit : ο = {} ∈ {⋯}
// def unit : ο = {}

// It is inhabited by the empty record.
val u : unit = {}

// But not by any other record.
// val fail : unit = {l = {}}
###
In fact, we can show that every value of ##unit## is equivalent to the
empty record ##{}## with the following proof.
### PML "examples/realunit.pml"
val true_unit : ∀x∈unit, x ≡ {} = fun x → {}
###

The encoding of strict products is not limited to the unit type. A similar
encoding can be used for any record type, and it is made accessible in the
syntax using the strict product type notation. For instance, the type of
pairs ##pair<a,b>## can be encoded as follows.
### PML "examples/pair.pml"
type pair<a,b> = ∃ x y:ι, {fst = x ; snd = y} ∈ {fst : a ; snd : b ⋯}
// type pair<a,b> = {fst : a ; snd : b}

val couple : ∀ a b, a ⇒ b ⇒ pair<a,b> = fun x y →
  {fst = x ; snd = y}

val pi1 : ∀ a b, pair<a,b> ⇒ a = fun p → p.fst
val pi2 : ∀ a b, pair<a,b> ⇒ b = fun p → p.snd
###
As for the unit type, it is possible to show that the elements of a pair
type are indeed records with exactly two fields ##fst## and ##snd##.
### PML "examples/pair.pml"
val true_pair : ∀a b, ∀p∈pair<a,b>, ∃x y:ι, p ≡ {fst = x ; snd = y} =
  fun p → {}
###

=<
=> Booleans and tautologies

After defining the (one element) ##unit## type in the previous section,
we will now consider the (two elements) type of booleans. It can be encoded
as usual using a polymorphic variant type as follows.
### PML "examples/bool.pml"
type bool = [Fls of unit ; Tru of unit]
// type bool = [Fls ; Tru]
###
Note that our variants need to have exactly one argument, which will here
be ##unit## on both the ##Tru## and ##Fls## constructors. It would be the
case implicitly if no argument type was provided.

In practice, booleans are often used together with conditional structures.
In our language, there are several (non-equivalent) ways of defining them.
A first possibility would be to define a condition function with three
arguments as follows.
### PML "examples/bool.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a = fun c e1 e2 →
  case c of Tru[_] → e1 | Fls[_] → e2
###
However, this function leads to both the expressions for the "then" and
"else" branch to be evaluated, before a choice is made. This is not the
semantics that is expected in practice, as it would be rather inefficient.

In our language, we can encode the usual "if ... then ... else ..."
construct using the definition of a term macro ##cond## with three term
arguments. This is made possible by the higher-order features of our
language.
### PML "examples/bool.pml"
def cond<c:τ, e1:τ, e2:τ> : τ =
  case c of Tru[_] → e1 | Fls[_] → e2
###
Although such a macro remains untyped in the system, we can check that
can be "typed" as expected by giving the following alternative definition
of ##cond_fun## (which is actually expended to the exact same definition
as above).
### PML "examples/bool.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a = fun c e1 e2 →
  cond<c, e1, e2>
###
Note that in the syntax, the syntactic sugar ##if c then e1 else e2## is
immediately translated to ##cond<c, e1, e2>## according to the definition
given above.

Note that the definition of similar macros can be used for definition an
##and## and an ##or## operator with the expected (lazy) semantics. This
feature is in fact useful in many ways, we will see in a further section
that it can even be used to encode proof tactics.
### PML "examples/bool.pml"
def land<b1:τ,b2:τ> =
  case b1 of Tru[_] → b2 | Fls[_] → Fls

def lor<b1:τ,b2:τ> =
  case b1 of Tru[_] → Tru | Fls[_] → b2
###

Before going further, we are going to define a set of usual boolean
operators. We will then consider their prove that they behave as
they are expected to in the system.
### PML "examples/bool.pml"
val not : bool ⇒ bool = fun a →
  case a of Fls[_] → Tru | Tru[_] → Fls

val or  : bool ⇒ bool ⇒ bool = fun a b → lor <a, b>
val and : bool ⇒ bool ⇒ bool = fun a b → land<a, b>
val imp : bool ⇒ bool ⇒ bool = fun a b → lor <b, not a>

val xor : bool ⇒ bool ⇒ bool = fun a b →
  case a of
  | Fls[_] → (case b of Fls[_] → Fls | Tru[_] → Tru)
  | Tru[_] → (case b of Fls[_] → Tru | Tru[_] → Fls)

val eq : bool ⇒ bool ⇒ bool = fun a b → xor a (not b)
###
As a first example of proof, we are going to consider the law of the
excluded middle. It can be stated and proved as follows in the system.
### PML "examples/bool.pml"
val excl_mid : ∀x∈bool, or x (not x) ≡ Tru = fun b →
  case b of Fls[_] → {} | Tru[_] → {}
###
\begin{rem}
The law of the excluded middle on booleans is not to be confused with the
term using control operators that was given in the introduction. Indeed,
they live in completely different levels of the system.
\end{rem}

As the type of booleans contain only finitely many elements, properties
can alway be proved by exhaustively listing the different cases. This is
what was done above for ##excl_mid##, but it was not too tedious as there
were only two cases. This will not be the case anymore when considering
properties with more parameters. For example, let us consider the
reflexivity, commutativity of the ##eq## function.
### PML "examples/bool.pml"
val eq_refl : ∀a∈bool, eq a a ≡ Tru = fun a →
  case a of Fls[_] → {} | Tru[_] → {}

val eq_comm : ∀a b∈bool, eq a b ≡ eq b a = fun a b →
  case a of
  | Fls[_] → (case b of Tru[_] → {} | Fls[_] → {})
  | Tru[_] → (case b of Tru[_] → {} | Fls[_] → {})

val eq_asso : ∀a b c∈bool, eq (eq a b) c ≡ eq a (eq b c) = fun a b c →
  case a of
  | Fls[_] →
      (case b of
       | Tru[_] → (case c of Tru[_] → {} | Fls[_] → {})
       | Fls[_] → (case c of Tru[_] → {} | Fls[_] → {}))
  | Tru[_] →
      (case b of
       | Tru[_] → (case c of Tru[_] → {} | Fls[_] → {})
       | Fls[_] → (case c of Tru[_] → {} | Fls[_] → {}))
###
To simplify the writing of such trivial proofs, it is possible to use
term macros defined using higher-order definitions. Such macros can then
be used to prove any tautology with a given number of arguments on
booleans.
### PML "examples/bool.pml"
def auto1<a:τ>           : τ = if a then {} else {}
def auto2<a:τ, b:τ>      : τ = if a then auto1<b> else auto1<b>
def auto3<a:τ, b:τ, c:τ> : τ = if a then auto2<b,c> else auto2<b,c>

val eq_refl_auto : ∀a∈bool, eq a a ≡ Tru =
  fun a → auto1<a>

val eq_comm_auto : ∀a b∈bool, eq a b ≡ eq b a =
  fun a b → auto2<a,b>

val eq_asso_auto : ∀a b c∈bool, eq (eq a b) c ≡ eq a (eq b c) =
  fun a b c → auto3<a,b,c>
###

=<
=> Unary natural numbers and totality

It is now time to consider a first example of data type with infinitely
many elements: unary natural numbers. Their definition was already given
in \chapter("intro"), together with some simple proofs. Let us start by
recalling the definition of unary natural numbers, together with their
addition and multiplication functions.
### PML "examples/unat.pml"
type rec nat = [ Zero ; Succ of nat ]

val rec add : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Zero[_] → m
  | Succ[k] → Succ[add k m]

val rec mul : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Zero[_] → Zero
  | Succ[k] → add m (mul k m)
###
As ##add## and ##mul## are defined using recursion on their first argument,
it is immediate to show ##add Zero n ≡ n## and ##mul Zero n ≡ Zero## for
every ##n##.
### PML "examples/unat.pml"
val add_zero_v : ∀v:ι, add Zero v ≡ v    = {}
val mul_zero_v : ∀v:ι, mul Zero v ≡ Zero = {}
###
Note that these properties are proved by quantifying over every possible
value ##v##. Whether it is a unary natural number or not is not important
as ##add Zero v## and ##mul Zero v## can still be unfolded. In fact, the
##add## function can always be given an arbitrary value as second argument
as it is never considered in a case analysis.

Of course, it is possible to show similar properties by quantifying only
on natural numbers using dependent functions.
### PML "examples/unat.pml"
val add_zero_n : ∀n∈nat, add Zero n ≡ n    = fun _ → {}
val mul_zero_n : ∀n∈nat, mul Zero n ≡ Zero = fun _ → {}
###
However, such definitions will never need to be used in practice since the
more general ##add_zero_v## and ##mul_zero_v## have trivial proofs. This
means that they can be obtained immediately by unfolding definitions, and
thus it will never be necessary to invoke them. In particular, the user
will never need to call ##add_zero_n## or ##mul_zero_n## to prove the
corresponding equivalences.

Let us now consider the commutativity of the ##add## function, which is a
much more interesting example. To obtain this properties, two lemmas are
required. We need to prove that ##add n Zero ≡ n## for every unary number
##n##, and that ##add n Succ[m] ≡ Succ[add n m]## for every unary numbers
##n## and ##m##. These two properties can be obtained easily using a case
analysis and induction.
### PML "examples/unat.pml"
val rec add_n_zero : ∀n∈nat, add n Zero ≡ n = fun n →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = add_n_zero k in {}

val rec add_succ : ∀n m∈nat, add n Succ[m] ≡ Succ[add n m] = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = add_succ k m in {}
###
A proof of the commutativity of ##add## is then obtained in a similar way,
but the two previously proved lemmas are used.
### PML "examples/unat.pml"
val rec add_comm : ∀n m∈nat, add n m ≡ add m n = fun n m →
  case n of
  | Zero[_] → let lem = add_n_zero m in {}
  | Succ[k] → let ih = add_comm k m in
               let lem = add_succ m k in {}
###
Note that in the system, a lemma is used by calling the corresponding
function. Similarly, using an induction hypothesis corresponds to performing
a recursive call. A proof can thus only be correct if it terminates on
every possible input. Otherwise, obviously invalid proofs would be allowed
by using a "non decreasing induction hypothesis".

When going toward more complex example, it becomes a necessity to establish
the totality of functions. In other words, it will sometimes be required to
show that the application of a function to any value produces a value. As an
example, we will prove the totality of the ##add## function.
### PML "examples/unat.pml"
val rec add_total : ∀n m∈nat, ∃v:ι, add n m ≡ v = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = add_total k m in {}
###
Using ##add_total## twice, it is then possible to show that addition function
##add## corresponds to an associative operation.
### PML "examples/unat.pml"
val rec add_asso : ∀n m p∈nat, add n (add m p) ≡ add (add n m) p =
  fun n m p →
    let tot_m_p = add_total m p in
    case n of
    | Zero[_] → {}
    | Succ[k] → let tot_k_m = add_total k m in
                 let ih = add_asso k m p in {}
###

To conclude this section, we will prove the commutativity of the ##mul##
function. This result requires three intermediate lemmas. First, we need
to show that ##mul n Zero ≡ Zero## for every unary number ##n## and that
##mul## is total. It is then necessary to show that
##mul n Succ[m] ≡ add (mul n m) n## for all ##n## and ##m##. These three
properties are rather straight-forward to obtain, even if longer proofs
are harder to read.
### PML "examples/unat.pml"
val rec mul_n_zero : ∀n∈nat, mul n Zero ≡ Zero = fun n →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = mul_n_zero k in {}

val rec mul_total : ∀n m∈nat, ∃v:ι, mul n m ≡ v = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = mul_total k m in
               let lem = add_total m (mul k m) in {}

val rec mul_succ : ∀n m∈nat, mul n Succ[m] ≡ add (mul n m) n = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let lem = mul_succ k m in
               let tot = mul_total k m in
               let tot = add_total m (mul k m) in
               let lem = add_succ (add m (mul k m)) k in
               let lem = add_asso m (mul k m) k in
               let tot = mul_total k Succ[m] in {}
###
The commutativity of ##mul## then follows using yet another proof by
induction, using each of the above lemmas.
### PML "examples/unat.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fun n m →
  case n of
  | Zero[_] → let lem = mul_n_zero m in {}
  | Succ[k] → let ih  = mul_comm m k in
               let lem = mul_succ m k in
               let tot = mul_total k m in
               let lem = add_comm (mul k m) m in {}
###

One possible way for making a proof more readable is to give type
annotations. They can be used to specify explicitly the equivalences
that are being shown when using lemmas, but also for checking that
some properties can be derived at a given point in the proof. We give
bellow another version of ##mul_comm## annotated in this way.
### PML "examples/unat.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fun n m →
  case n of
  | Zero[_] → let lem = mul_n_zero m in {}
  | Succ[k] → let ih  = mul_comm m k in
               let lem = mul_succ m k in
               let tot = mul_total k m in
               let lem = add_comm (mul k m) m in {}
###
(* TODO add annotations above + explanations. *)

=<
=> Lists and their vector subtypes

\todo(None) (* TODO *)

### PML "examples/vec.pml"
type rec nat = [ Z ; S of nat ]

val zero : nat = Z[]
val succ : nat ⇒ nat = fun n → S[n]

val rec add : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Z[] → m
  | S[p] → succ (add p m)

val rec add_total : ∀n m∈nat, ∃v:ι, add n m ≡ v = fun n m →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp = add_total p m in {}

type rec list<a:ο> = [ Nil; Cns of { hd : a; tl : list }  ]

val nil : ∀a:ο, list<a> = Nil[]
val cns : ∀a:ο, a ⇒ list<a> ⇒ list<a> =
  fun e l → Cns[{ hd = e; tl = l }]

val rec length : ∀a:ο, list<a> ⇒ nat = fun l →
  case l of
  | Nil[] → zero
  | Cns[c] → succ (length c.tl)

val rec length_total : ∀a:ο, ∀l∈list<a>, ∃v:ι, v ≡ length l = fun l →
  case l of
  | Nil[] → {}
  | Cns[c] → let ind = length_total c.tl in {}

type vec<a:ο,s:τ> = ∃l:ι, l∈(list<a> | length l ≡ s)
// The fact that s:τ is very important
// The position of the partenthesis is important

val vnil : ∀a:ο, vec<a,zero> = nil

val vcns : ∀a:ο,∀s:ι, ∀x∈a, vec<a,s> ⇒ vec<a,succ s> =
   fun y ls → Cns[{hd= y;tl= ls}]

val rec app : ∀a:ο, ∀n1 n2:ι, vec<a,n1> ⇒ vec<a,n2> ⇒ vec<a,add n1 n2> =
  Λa:ο. fun l1 l2 →
  case l1 of
  | Nil[] → l2
  | Cns[c] →
      let lem = length_total c.tl in
      (case length l1 of
      | Z[] → ✂
      | S[p1] →
        let r = app c.tl l2 in
        let lem = length_total (r : list<a>) in
        vcns c.hd r)

val app3 : ∀a:ο, ∀n1 n2 n3:ι,
           vec<a,n1> ⇒ vec<a,n2> ⇒ vec<a,n3> ⇒ vec<a,add n1 (add n2 n3)> =
    fun l1 l2 l3 →
      let lem = add_total (length l2) (length l3) in
      app l1 (app l2 l3)
###

=<
=> Case study: sorting algorithm

\todo(None) (* TODO *)

=<
=> Case study: $λ$-calculus

\todo(None) (* TODO *)

=<
=<
