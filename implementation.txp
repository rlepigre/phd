\Include{Macros}

\Caml(
  open ProofTree
  open Diagrams
  open PMLVerbatim
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\size{3.}{\wbox}$>
  let bbox = <$\size{3.}{\bbox}$>
)

\Configure_math_macro{\v}{ syntax = string; }
\Configure_math_macro{\t}{ syntax = string; }
\Configure_math_macro{\s}{ syntax = string; }
\Configure_math_macro{\p}{ syntax = string; }
\Configure_math_macro{\f}{ syntax = string; }
\Configure_math_macro{\vs}{ syntax = string; }
\Configure_math_macro{\ss}{ syntax = string; }
\Configure_math_macro{\ts}{ syntax = string; }

=> Implementation and examples \label("implem")

\begin{center}
\linesBefore(10)
\end{center}
(* *)
In this last chapter, we consider examples of programs and proofs that can be
written and manipulated using our prototype implementation. This restricted
set of examples is not intended to give an exhaustive view of our language.
Their only purpose is to demonstrate its expressiveness through a selected
set of examples.

=> Concrete syntax and syntactic sugars

Although it is conveniently short, the abstract syntax that was used since
\chapter("calculus") is not suitable for actual programming. Throughout
this chapter, we will rely on the syntax used by the prototype
implementation of the system. Some examples of programs written with this
concrete syntax were already considered in \chapter("intro"). We will now
give some elements of the translation from the concrete syntax to the
abstract syntax.
\begin{rem}
Although we will not give the full details, it would be possible to give a
precise definition of the translation of terms and types between the two
syntaxes.
\end{rem}

At the top level of the concrete syntax, there are three different ways of
defining meta-variable: the definition of an expression of a given sort,
the definition of a type and the definition of a value. The definition of
an expression simply amounts to giving a name to some higher-order term
of our language (i.e., to an element of $\cal{F}$ of an arbitrary sort).
Examples of such definitions are given below.
### PML "examples/implem.pml"
def delta : ι          = fun x { x x }
def rapp<t:τ, u:τ> : τ = u t
def omega : τ          = rapp<delta, delta>
def empty : ο          = ∀x:ο, x
def neg<a:ο> : ο       = a ⇒ empty
###
Note that higher-order definitions can have arguments, which are given in
angle brackets. Sort annotations are given for the arguments, as well as
for the global (fully applied) expression. For example, the expression
##rapp## (reversed application) given above has the sort ##τ→τ→τ##, and
to be used as an element of sort ##τ## it needs to be provided with two
arguments of sort ##τ## as in the definition of ##omega##. Of course, any
term of sort ##ι## also has sort ##τ## and the sort of expressions can be
inferred most of the time (i.e., it does not always have to be provided
by the user).

As it is very common to define types (i.e., expressions of sort ##ο##), a
specific syntax is provided to do so. However, it is completely equivalent
to using a standard definition as it is only syntactic sugar. As a
consequence, the following two definitions of the type of booleans are
equivalent.
### PML "examples/implem.pml"
type boolean = [True; False]
def boolean : ο = [True; False]
###
Type definitions can also have arguments, and the ##rec## or ##corec##
keyword can be used to make a type definition inductive or coinductive.
For example, the type of lists and the type of streams can be defined
as follows (equivalent higher-order definitions are also given).
### PML "examples/implem.pml"
type rec list<a:ο> = [Nil; Cons of {hd : a; tl : list}]
type corec stream<a:ο> = {} ⇒ {hd : a; tl : stream}

def list<a:ο> : ο = μ list [Nil; Cons of {hd : a; tl : list}]
def stream<a:ο> : ο = ν stream {} ⇒ {hd : a; tl : stream}
###
Note that the name of the constructors are uppercase identifiers, while
lowercase identifiers are used everywhere else. In particular, constructor
names and label names are not limited as in the abstract syntax.

Finally, values can be defined and type-checked using the ##val## keyword.
As for types, the ##rec## keyword can be used and it makes the definition
recursive. For example, we can define the following functions on lists,
using the built-in type ##bool## and the ##option<a>## type from the
standard library.
### PML "examples/implem.pml"
val is_empty : ∀a, list<a> ⇒ bool =
  fun l {
    case l {
      Nil     → true
      Cons[_] → false
    }
  }

include lib.option
// type option<a> = [None; Some of a]

val rec last : ∀a, list<a> ⇒ option<a> =
  fun l {
    case l {
      Nil     → None
      Cons[c] →
        case c.tl {
          Nil     → Some[c.hd]
          Cons[_] → last c.tl
        }
    }
  }
###
Note that the body of functions and the patterns of case analyses are
wrapped in curly brackets (like in the Rust language). This will also
be the case for conditionals, but they will only be introduced later.

Another important remark about our concrete syntax is that we allow terms
which are not values everywhere, including in records and variants. This
is in fact translated to the limited abstract syntax as discussed in
\remark("remsugar"). For example, the term ##Some[c.hd]## in the above
example is translated to ##(fun x { Some[x] }) c.hd## internally.

In the concrete syntax, $λ$-abstractions and $μ$-abstractions can be
written using the syntax ##fun x { t }## and ##save k { t }## respectively.
Note that they can take multiple arguments at once. For example,
##fun x y { t }## is the same as ##fun x { fun y { t } }##. A
continuation (or stack) ##k## can be restored using the syntax
##restore k t##, which corresponds to named terms in the abstract syntax.

=<
=> Encoding of strict product types

As discussed in the previous chapter, the most natural semantics for product
types in presence of subtyping allows for extensible records. In other words,
it is always possible to provide more fields than necessary. However, product
types with a fixed set of fields often arise in practice. For this reason, we
introduced so-called strict product types, which were used to state our type
safety theorem (\theorem("fullsafety")). In this section, we will show that
it is possible to encode strict records into the system, without extending
it with two different forms of product types.

Let us first consider the "unit" type, corresponding to the empty product.
In our system, a first attempt at defining such a type would be to use an
extensible record with no fields. However, as indicated by its name, this
type contains many more elements that the empty record (written ##{}## in
our system).
### PML "examples/implem.pml"
type wrong_unit = {⋯}

// It is inhabited by the empty record.
val u : wrong_unit = {}

// And in fact by any record...
val u_aux : wrong_unit = {l = {}}
###

To avoid extending the system with strict record types, it is possible to
use one of the following three encodings for the ##unit## type. They rely
on the membership type, optionally combined with existential quantification
and restriction.
### PML "examples/implem.pml"
type unit1 = {} ∈ {⋯}
type unit2 = ∃x:ι, x ∈ ({⋯} | x ≡ {})
type unit3 = ∃x:ι, (x ∈ {⋯}) | x ≡ {}
###
Note that these types are all equivalent semantically. In the implementation,
we chose to use the definition ##unit1## in place of the syntactic sugar
##{}## (strict product type with no fields). We can thus use the following
definition for a reasonable ##unit## type.
### PML "examples/implem.pml"
type unit = {} ∈ {⋯}
// type unit = {}

// It is inhabited by the empty record.
val u : unit = {}

// But not by any other record.
// val fail : unit = {l = {}}
###
In fact, we can show that every value of ##unit## is equivalent to the
empty record ##{}## with the following proof.
### PML "examples/implem.pml"
val true_unit : ∀x∈unit, x ≡ {} = fun x { {} }
###

The encoding of strict products is not limited to the unit type. A similar
encoding can be used for any record type, and it is made accessible in the
syntax using the strict product type notation. For instance, the type of
pairs ##pair<a,b>## can be encoded as follows.
### PML "examples/implem.pml"
type pair<a,b> = ∃ x y:ι, {fst = x; snd = y} ∈ {fst : a; snd : b; ⋯}
// type pair<a,b> = {fst : a ; snd : b}

val couple : ∀ a b, a ⇒ b ⇒ pair<a,b> =
  fun x y { {fst = x ; snd = y} }

val pi1 : ∀ a b, pair<a,b> ⇒ a = fun p { p.fst }
val pi2 : ∀ a b, pair<a,b> ⇒ b = fun p { p.snd }
###
As for the unit type, it is possible to show that the elements of a pair
type are indeed records with exactly two fields ##fst## and ##snd##.
### PML "examples/implem.pml"
val true_pair : ∀a b, ∀p∈pair<a,b>, ∃x y:ι, p ≡ {fst = x ; snd = y} =
  fun p { {} }
###

=<
=> Booleans and tautologies

After defining the (one element) ##{}## (or ##unit##) type in the previous
section, we will now consider the (two elements) type of booleans. It can
be encoded as usual using a polymorphic variant type as follows.
### PML "examples/implem.pml"
type boolean = [False of {}; True of {}]
// type boolean = [False; True]
###
Note that our variants need to have exactly one argument, which will here
be ##{}## on both the ##True## and ##False## constructors. However, if
no argument type is specified, then ##{}## is used implicitly.

In practice, booleans are often used together with conditional structures.
There are several (non-equivalent) ways of defining them in our language.
A first possibility is to define a condition function with three arguments
as follows.
### PML "examples/implem.pml"
val cond_fun : ∀ a, boolean ⇒ a ⇒ a ⇒ a =
  fun c e1 e2 { case c { True → e1 | False → e2 } }
###
However, this function leads to both the expressions for the "then" and
"else" branches to be evaluated, before a choice is made. This is not the
semantics that is expected in practice, as it would be rather inefficient.

In our language, we can encode the usual conditional structures using a
term macro ##cond##, with three term arguments. This is made possible by
the higher-order features of our language.
### PML "examples/implem.pml"
def cond<c:τ, e1:τ, e2:τ> : τ =
  case c { True → e1 | False → e2 }
###
Although such a macro is not typed at the time of its definition (it is
only given a sort), it is expanded and type-checked each time it is used.
For instance, ##cond## can be used to define the following alternative
definition of ##cond_fun##.
### PML "examples/implem.pml"
val cond_fun : ∀ a, boolean ⇒ a ⇒ a ⇒ a =
  fun c e1 e2 { cond<c, e1, e2> }
###
In the following, we will prefer using the built-in ##bool## type, rather
that the ##boolean## type defined above. Although they are completely
equivalent, only the ##bool## type will allow us to use the syntax for
conditional structures. For example, the following definition of
##cond_fun## can be given for ##bool##.
### PML "examples/implem.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a =
  fun c e1 e2 { if c { e1 } else { e2 } }
###
It is exactly equivalent to the one using the ##boolean## type. The only
difference lies in the name of the constructors, which are hidden to the
user in the ##bool## type. Only the conditional structures and the usual
boolean constants can be accessed by the user.

Higher-order macros similar to ##cond## can also be used to obtain
conjunction and disjunction operators having the expected (lazy)
semantics. This feature is in fact useful in many ways, we will see
in a further section that it can even be used to encode a form of
proof tactics.
### PML "examples/implem.pml"
def land<b1:τ, b2:τ> =
  if b1 { b2 } else { false }

def lor<b1:τ, b2:τ> =
  if b1 { true } else { b2 }
###

Before going further, we are going to define a set of usual boolean
operators. We will then prove that they behave as expected in the
system.
### PML "examples/implem.pml"
val not : bool ⇒ bool =
  fun a { if a { false } else { true } }

val or  : bool ⇒ bool ⇒ bool = fun a b { lor<a, b> }
val and : bool ⇒ bool ⇒ bool = fun a b { land<a, b> }
val imp : bool ⇒ bool ⇒ bool = fun a b { lor<not a, b> }
val xor : bool ⇒ bool ⇒ bool = fun a b { if a { not b } else { b } }
val eq  : bool ⇒ bool ⇒ bool = fun a b { xor a (not b) }
###
We will now consider the law of the excluded middle (on booleans). It can
be stated and proved as follows in the system.
### PML "examples/implem.pml"
val excl_mid : ∀x∈bool, or x (not x) ≡ true =
  fun b { if b { {} } else { {} } }
###
\begin{rem}
The law of the excluded middle on booleans is not to be confused with the
term using control operators that was given in the introduction. Indeed,
they live in completely different levels of the system.
\end{rem}

As the type of booleans contain only finitely many elements, properties
can always be proved by exhaustively listing the different cases. This is
what was done above for ##excl_mid##, but it was not too tedious as there
were only two cases. This will not be the case anymore when considering
properties with more parameters. For example, let us consider the
reflexivity, commutativity of the ##eq## function.
### PML "examples/implem.pml"
val eq_refl : ∀a∈bool, eq a a ≡ true =
  fun a { if a { {} } else { {} } }

val eq_comm : ∀a b∈bool, eq a b ≡ eq b a =
  fun a b {
    if a { if b { {} } else { {} } }
    else { if b { {} } else { {} } }
  }

val eq_asso : ∀a b c∈bool, eq (eq a b) c ≡ eq a (eq b c) =
  fun a b c {
    if a {
      if b { if c { {} } else { {} } }
      else { if c { {} } else { {} } }
    } else {
      if b { if c { {} } else { {} } }
      else { if c { {} } else { {} } }
    }
  }
###
To simplify the writing of such trivial proofs, it is possible to use
term macros defined using higher-order definitions. Such macros can then
be used to prove any tautology with a given number of arguments on
booleans.
### PML "examples/implem.pml"
def auto1<a:τ>           : τ = if a { {} } else { {} }
def auto2<a:τ, b:τ>      : τ = if a { auto1<b> } else { auto1<b> }
def auto3<a:τ, b:τ, c:τ> : τ = if a { auto2<b,c> } else { auto2<b,c> }

val eq_refl_auto : ∀a∈bool, eq a a ≡ true =
  fun a { auto1<a> }

val eq_comm_auto : ∀a b∈bool, eq a b ≡ eq b a =
  fun a b { auto2<a,b> }

val eq_asso_auto : ∀a b c∈bool, eq (eq a b) c ≡ eq a (eq b c) =
  fun a b c { auto3<a,b,c> }
###

=<
=> Unary natural numbers and totality

It is now time to consider a first example of data type with infinitely
many elements: unary natural numbers. Their definition was already given
in \chapter("intro"), together with some simple proofs. Let us start by
recalling the definition of unary natural numbers, together with their
addition and multiplication functions.
### PML "examples/implem.pml"
type rec nat = [Zero; Succ of nat]

val rec add : nat ⇒ nat ⇒ nat =
  fun n m {
    case n { Zero → m | Succ[k] → Succ[add k m] }
  }

val rec mul : nat ⇒ nat ⇒ nat =
  fun n m {
    case n { Zero → Zero | Succ[k] → add m (mul k m) }
  }
###
As ##add## and ##mul## are defined using recursion on their first argument,
it is immediate to show ##add Zero n ≡ n## and ##mul Zero n ≡ Zero## for
every ##n##.
### PML "examples/implem.pml"
val add_zero_v : ∀v:ι, add Zero v ≡ v = {}
val mul_zero_v : ∀v:ι, mul Zero v ≡ Zero = {}
###
Note that these properties are proved by quantifying over every possible
value ##v##. Whether it is a unary natural number or not is not important
as ##add Zero v## and ##mul Zero v## can still be unfolded. In fact, the
##add## function can always be given an arbitrary value as second argument
as it is never considered in a case analysis.

Of course, it is possible to show similar properties by quantifying only
on natural numbers using dependent functions.
### PML "examples/implem.pml"
val add_zero_n : ∀n∈nat, add Zero n ≡ n    = fun _ { {} }

val mul_zero_n : ∀n∈nat, mul Zero n ≡ Zero = fun _ { {} }
###
However, such definitions will never need to be used in practice since the
more general ##add_zero_v## and ##mul_zero_v## have trivial proofs. This
means that they can be obtained immediately by unfolding definitions, and
thus it will never be necessary to invoke them. In particular, the user
will never need to call ##add_zero_n## or ##mul_zero_n## to prove the
corresponding equivalences.

Let us now consider the commutativity of the ##add## function, which is a
more interesting example. To obtain these properties, two lemmas are
required. We need to prove that ##add n Zero ≡ n## for every unary number
##n##, and that ##add n Succ[m] ≡ Succ[add n m]## for every unary numbers
##n## and ##m##. These two properties can be obtained easily using a case
analysis and induction.
### PML "examples/implem.pml"
val rec add_n_zero : ∀n∈nat, add n Zero ≡ n =
  fun n {
    case n {
      Zero    → {}
      Succ[k] → let ih = add_n_zero k; {}
    }
  }

val rec add_succ : ∀n m∈nat, add n Succ[m] ≡ Succ[add n m] =
  fun n m {
    case n {
      Zero    → {}
      Succ[k] → let ih = add_succ k m; {}
    }
  }
###
A proof of the commutativity of ##add## is then obtained in a similar way,
but the two previously proved lemmas are used.
### PML "examples/implem.pml"
val rec add_comm : ∀n m∈nat, add n m ≡ add m n =
  fun n m {
    case n {
      Zero    → let lem = add_n_zero m; {}
      Succ[k] → let ih = add_comm k m; let lem = add_succ m k; {}
    }
  }
###
Note that in the system, a lemma is used by calling the corresponding
function. Similarly, using an induction hypothesis corresponds to performing
a recursive call. A proof can thus only be correct if it terminates on
every possible input. Otherwise, obviously invalid proofs would be allowed
by using a "non decreasing induction hypothesis".

When the examples become more complex, it is sometimes required to establish
the totality of functions. In other words, we need to show that the
application of a function to any value (of the right type) produces a value.
As an example, we will prove the totality of the ##add## function.
### PML "examples/implem.pml"
val rec add_total : ∀n m∈nat, ∃v:ι, add n m ≡ v =
  fun n m {
    case n {
      Zero    → {}
      Succ[k] → let ih = add_total k m; {}
    }
  }
###
Using ##add_total## twice, it is then possible to show that the addition
function corresponds to an associative operation.
### PML "examples/implem.pml"
val rec add_asso : ∀n m p∈nat, add n (add m p) ≡ add (add n m) p =
  fun n m p {
    let tot_m_p = add_total m p;
    case n {
      Zero    → {}
      Succ[k] → let tot_k_m = add_total k m;
                 let ih = add_asso k m p; {}
    }
  }
###

To conclude this section, we will prove the commutativity of the ##mul##
function. This result requires three intermediate lemmas. First, we need
to show that ##mul n Zero ≡ Zero## for every unary number ##n## and that
##mul## is total. It is then necessary to show that
##mul n Succ[m] ≡ add (mul n m) n## for all ##n## and ##m##. These three
properties are rather straight-forward to obtain, even if longer proofs
are harder to read.
### PML "examples/implem.pml"
val rec mul_n_zero : ∀n∈nat, mul n Zero ≡ Zero =
  fun n {
    case n {
      Zero    → {}
      Succ[k] → let ih = mul_n_zero k; {}
    }
  }

val rec mul_total : ∀n m∈nat, ∃v:ι, mul n m ≡ v =
  fun n m {
    case n {
      Zero    → {}
      Succ[k] → let ih = mul_total k m;
                 let lem = add_total m (mul k m); {}
    }
  }

val rec mul_succ : ∀n m∈nat, mul n Succ[m] ≡ add (mul n m) n =
  fun n m {
    case n {
      Zero    → {}
      Succ[k] →
        let lem = mul_succ k m;
        let tot = mul_total k m;
        let tot = add_total m (mul k m);
        let lem = add_succ (add m (mul k m)) k;
        let lem = add_asso m (mul k m) k;
        let tot = mul_total k Succ[m]; {}
    }
  }
###
The commutativity of ##mul## then follows using yet another proof by
induction, using each of the above lemmas.
### PML "examples/implem.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n =
  fun n m {
    case n {
      Zero    → let lem = mul_n_zero m; {}
      Succ[k] → let ih  = mul_comm m k;
                 let lem = mul_succ m k;
                 let tot = mul_total k m;
                 let lem = add_comm (mul k m) m; {}
    }
  }
###

One possible way for making a proof more readable is to give type
annotations. They can be used to specify explicitly the equivalences
that are being shown when using lemmas, but also for checking that
some properties can be derived at a given point in the proof. We give
below another version of ##mul_comm## annotated in this way.
### PML "examples/implem.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n =
  fun n m {
    case n {
      Zero    → let ded : mul Zero m ≡ Zero = {};
                 let lem : mul m Zero ≡ Zero = mul_n_zero m; {}
      Succ[k] → let ded : mul Succ[k] m ≡ add m (mul k m) = {};
                 let ih  : mul k m ≡ mul m k = mul_comm k m;
                 let lem : mul m Succ[k] ≡ add (mul m k) m =
                   mul_succ m k;
                 let tot : (∃v:ι, mul k m ≡ v) = mul_total k m;
                 let lem : add (mul k m) m ≡ add m (mul k m) =
                   add_comm (mul k m) m;
                 {}
    }
  }
###
Here, we add type annotations on used lemmas to explicit the properties
they prove. We also extend the proof with intermediate steps using local
definitions. They allow us to check that some property can be deduced in
the current context, while showing more reasoning steps. Note that the
names chosen for the local definitions are never used, they can hence be
seen as a form of comments (we could also use the symbol ##_## to avoid
giving an explicit name). Only the equations that are transparently added
to the context matter. Using this discipline, the proofs are not only more
readable, but also easier to write.

Another, more satisfactory way of obtaining more readable proofs is to
use again the higher-order layer of our system to define "tactics". We
will here use a ##t_deduce## tactic to check that some equation holds in
the current context, and a ##t_show## tactic to prove a property using
a given proof.
### PML "examples/implem.pml"
def t_deduce<f:ο> : τ = ({} : f)
def t_show<f:ο, p:τ> : τ = (p : f)
###
We can then modify our commutativity proof to obtain the following, which
is a lot more readable than our original proof. Note that here, we use
semicolons to put proof steps in sequence. It is encoded as usual using
a dummy redex.
### PML "examples/implem.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n =
  fun n m {
    case n {
      Zero    →
        t_deduce<mul Zero m ≡ Zero>;
        t_show<mul m Zero ≡ Zero, mul_n_zero m>
      Succ[k] →
        t_deduce<mul Succ[k] m ≡ add m (mul k m)>;
        t_show<mul k m ≡ mul m k, mul_comm k m>;
        t_show<mul m Succ[k] ≡ add (mul m k) m, mul_succ m k>;
        t_show<(∃v:ι, mul k m ≡ v), mul_total k m>;
        t_show<add (mul k m) m ≡ add m (mul k m), add_comm (mul k m) m>
    }
  }
###
We could even introduce syntactic sugar for our tactics into the parser
of our language to obtain the following, very satisfactory proof.
### PML "examples/implem.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n =
  fun n m {
    case n {
      Zero    →
        deduce mul Zero m ≡ Zero;
        show mul m Zero ≡ Zero using mul_n_zero m
      Succ[k] →
        deduce mul Succ[k] m ≡ add m (mul k m);
        show mul k m ≡ mul m k using mul_comm k m;
        show mul m Succ[k] ≡ add (mul m k) m
          using mul_succ m k;
        show ∃v:ι, mul k m ≡ v using mul_total k m;
        show add (mul k m) m ≡ add m (mul k m)
          using add_comm (mul k m) m
    }
  }
###

=<
=> Lists and their vector subtypes

We will now consider the type of lists containing elements of a fixed type,
given as a parameter. As usual, operations on lists will be polymorphic in
this parameter.
### PML "examples/implem.pml"
type rec list<a:ο> = [Nil ; Cons of {hd : a ; tl : list}]
###
According to the above definition, a list is either empty (##Nil##
constructor), or built using a smaller list and an element (##Cons##
constructor). Note that the argument of the ##Cons## constructor is
formed using a product (or record) type with two elements. The label
##hd## denotes the //head// of the list (i.e., its first element) and
##tl## denotes its //tail//.
\begin{rem}
  The type that is stored under the ##tl## label is ##list## and not
  ##list<a>## due to the encoding of the "##type rec##" construct. It
  is formed using a higher-order function which body contains a fixpoint
  construction over a variable named ##list##.
\end{rem}

As for the natural number, it is possible to define the usual
functions on lists, including ##exists## or ##rev_append## (see
\chapter("intro")). Many more functions are given in the standard
library of the prototype, together with its source code. Here, we
will only focus on the ##map## and ##length## functions, which are
given below.
### PML "examples/implem.pml"
val rec map : ∀a b:ο, (a ⇒ b) ⇒ list<a> ⇒ list<b> =
  fun f l {
    case l {
      Nil     → Nil
      Cons[c] → Cons[{hd = f c.hd; tl = map f c.tl}]
    }
  }

val rec length : ∀a:ο, list<a> ⇒ nat =
  fun l { case l { Nil → Zero | Cons[c] → Succ[length c.tl] } }
###
The ##map## function applies the function given as first argument to
all the elements of the list given as second argument. The ##length##
function simply computes a unary natural number corresponding to the
length of the list given as argument. We will now prove the totality
of these two functions because it will be needed later. Note that the
totality of the ##map## function can only be established ifs first
argument is itself total.
### PML "examples/implem.pml"
// total<f,a> means that f is total on the domain a.
def total<f:ι,a:ο> : ο = ∀x∈a, ∃v:ι, f x ≡ v

val rec map_total : ∀a b:ο, ∀f∈(a ⇒ b), total<f,a>
                    ⇒ ∀l∈list<a>, ∃v:ι, map f l ≡ v =
  fun fn ft ls {
    case ls {
      Nil     → {}
      Cons[c] → let lem = ft c.hd;
                 let ih  = map_total fn ft c.tl; {}
    }
  }

val rec length_total : ∀a:ο, ∀l∈list<a>, ∃v:ι, v ≡ length l =
  fun l {
    case l {
      Nil     → {}
      Cons[c] → let ind = length_total c.tl; {}
    }
  }
###

We will now show that two successive uses of ##map## on a list, with two
different functions, is the same as applying ##map## once using the
composition of the two functions. To do so, we will first need to show
that the composition of two total functions is itself total.
### PML "examples/implem.pml"
val compose_total : ∀a b c:ο, ∀f∈(a ⇒ b), ∀g∈(b ⇒ c),
    total<f,a> ⇒ total<g,b> ⇒ total<(fun x { g (f x) }), a> =
  fun f g ftot gtot a {
    show ∃v:ι, f a ≡ v using ftot a;
    show ∃w:ι, g (f a) ≡ w using gtot (f a)
  }
###
We can then state and prove our lemma as follows, using a proof by
induction together with our different totality results.
### PML "examples/implem.pml"
val map_map : ∀a b c:ο, ∀f∈(a ⇒ b), ∀g∈(b ⇒ c),
    total<f,a> ⇒ total<g,b> ⇒
    ∀l∈list<a>, map g (map f l) ≡ map (fun x { g (f x) }) l =
  fun f g ftot gtot {
    fix fun map_map ls {
      case ls {
        Nil     → {}
        Cons[c] → let hd = c.hd; let tl = c.tl;
                   let tgf = compose_total f g ftot gtot hd;
                   let lem = ftot hd;
                   let lem = map_total f ftot tl;
                   let ind = map_map tl; {}
      }
    }
  }
###
Note that the proof by induction starts at the level of the "##fix##"
keyword, which takes the fixpoint of the functions that immediately
follows it. In fact, our "##val rec##" construct is exactly encoded in
this way.

In our system, it is possible to encode the type of vectors (i.e., lists
of a given length) using a restriction on the type of lists. In other
words, vectors of length ##s## will be defined as the type of all lists
##l## such that ##length l ≡ s##. The type of vectors will hence have
two parameters. The former will give the type of the elements contained
in the vectors and the latter will be the size parameter, in the form of
a term.
### PML "examples/implem.pml"
type vec<a:ο, s:τ> = ∃l:ι, l∈(list<a> | length l ≡ s)
###
(* TODO a word on the position of parentheses ? *)
We can then define a concatenation function ##app## on vector. It produces
a vector which length is the sum of the lengths of its two arguments. Note
that the definition of ##app## requires the use of ##length_total##.
### PML "examples/implem.pml"
val rec app : ∀a:ο, ∀m n:ι, vec<a, m> ⇒ vec<a, n> ⇒ vec<a, add m n> =
  fun l1 l2 {
    case l1 {
      Nil     → l2
      Cons[c] → length_total c.tl;
                Cons[{hd = c.hd; tl = app c.tl l2}]
    }
  }
###
We can now define a ternary concatenation function on vectors as follows,
using two calls to ##app##. To be able to define this function, the
totality of the ##add## function is required.
### PML "examples/implem.pml"
val app3 : ∀a:ο, ∀m n p:ι, vec<a,m> ⇒ vec<a,n> ⇒ vec<a,p>
                           ⇒ vec<a, add m (add n p)> =
 fun l1 l2 l3 {
   let lem = add_total (length l2) (length l3);
   app l1 (app l2 l3)
 }
###

It is important to notice that an element of type ##vec<a,s>## can
always be used as an element of ##list<a>##, independently of ##s##.
In fact, ##vec<a,s>## is a subtype of ##list<a>##.
### PML "examples/implem.pml"
val vec_to_list : ∀a:ο, ∀s:τ, vec<a,s> ⇒ list<a> = fun x { x }
###
Note that we will never need to use the function ##vec_to_list## to
turn a vector into a list. A vector can be seen as a list directly, without
relying on any form of coercion.

=<
=> Sorted lists and insertion sort

We will now consider the insertion sort algorithm, and prove that it
actually produces sorted lists. Before going further, we will start by
defining a type ##ord<a>## that will be represent an ordering relation
together with its properties.
### PML "examples/implem.pml"
type ord<a:ο> = ∃cmp:ι,
  { cmp : cmp ∈ (a ⇒ a ⇒ bool)
  ; tot : ∀x y∈a, ∃v:ι, cmp x y ≡ v
  ; dis : ∀x y∈a, or (cmp x y) (cmp y x) ≡ true }
###
If we ignore the leading existential, an ordering relation simply consist
in a product (or record) type containing a comparison function, a proof
of its totality and a proof that every element can be compared. The
existential quantifier is only there to make the comparison function
accessible in the types of the other fields.
\begin{rem}
An element of type ##ord<a>## does not really correspond to an ordering
relation as transitivity is included. Although it could very well be
given, it is not required for insertion sort.
\end{rem}

We can then define our ##isort## function in the usual way, using
an intermediate function ##insert##, inserting an element in a sorted
list.
### PML "examples/implem.pml"
val rec insert : ∀a:ο, ord<a> ⇒ a ⇒ list<a> ⇒ list<a> =
  fun o x l {
    case l {
      Nil     → Cons[{hd = x; tl = Nil}]
      Cons[c] → let hd = c.hd; let tl = c.tl;
                 if o.cmp x hd { Cons[{hd = x ; tl = l}] }
                 else {
                   let tl = insert o x tl;
                   Cons[{hd = hd ; tl = tl}]
                 }
    }
  }

val rec isort : ∀a:ο, ord<a> ⇒ list<a> ⇒ list<a> =
  fun o l {
    case l {
      Nil     → Nil
      Cons[c] → insert o c.hd (isort o c.tl)
    }
  }
###
Until the end of this section, our goal will be to show that for any
ordering relation ##o## and list ##l##, the list ##isort o l##
is indeed sorted.

A first step in this direction consists in specifying what it means to
be sorted. We hence define a boolean valued program taking as input an
ordering relation and a list, and indicating whether the list is sorted.
### PML "examples/implem.pml"
val rec sorted : ∀a:ο, ∀o∈ord<a>, ∀l∈list<a>, bool =
  fun o l {
    case l {
      Nil      → true
      Cons[c1] →
        let hd = c1.hd; let tl = c1.tl;
        case tl {
          Nil      → true
          Cons[c2] → let hd2 = c2.hd;
                      land<(o.cmp) hd hd2, sorted o tl>
        }
    }
  }
###
Most remarkably, we can even define the type of sorted lists using the
restriction operator. Indeed, sorted lists are lists on which the
##sorted## function returns ##true##.
### PML "examples/implem.pml"
type slist<a:ο,o:τ> = ∃l:ι, l∈(list<a> | sorted o l ≡ true)
###
At the end of this section we will be able to define another version of
##isort## that can be given the type
##∀a:ο, ∀o∈ord<a>, list<a> ⇒ slist<a,o>##.

To build our proof, we will first need to establish the totality of the
##insert## and ##isort## functions. This can be done straightforwardly
with the following proofs.
### PML "examples/implem.pml"
val rec insert_total :
    ∀a:ο, ∀o∈ord<a>, ∀x∈a, ∀l∈list<a>, ∃v:ι, insert o x l ≡ v =
  fun o x l {
    case l {
      Nil      → {}
      Cons[c1] →
        let hd = c1.hd; let tl = c1.tl;
        let lem = o.tot x hd;
        if o.cmp x hd {
          {}
        } else {
          let ih = insert_total o x tl; {}
        }
    }
  }

val rec isort_total :
    ∀a:ο, ∀o∈ord<a>, ∀l∈list<a>, ∃v:ι, isort o l ≡ v =
  fun o l {
    case l {
      Nil     → {}
      Cons[c] →
        let ih  = isort_total o c.tl;
        let lem = insert_total o c.hd (isort o c.tl); {}
    }
  }
###
It is then necessary to show that inserting an element in a sorted list
yields a sorted list. The proof of this lemma is not complicated either,
but the case analysis is a bit tedious due to the lack of deep pattern
matching.
### PML "examples/implem.pml"
val rec isorted :
    ∀a:ο, ∀o∈ord<a>, ∀x∈a, ∀l∈slist<a,o>,
    sorted o (insert o x l) ≡ true =
  fun o x l {
    case l {
      Nil      → {}
      Cons[c1] →
        let lem = o.tot x c1.hd;
        if o.cmp x c1.hd { {} }
        else {
          let lem = o.tot c1.hd x;
          let lem = o.dis x c1.hd;
          case c1.tl {
            Nil      → {}
            Cons[c2] →
              let lem = insert_total o x c2.tl;
              let lem = o.tot c1.hd c2.hd;
              let lem = o.tot x c2.hd;
              if o.cmp c1.hd c2.hd {
                let lem = isorted o x c1.tl;
                if o.cmp x c2.hd { {} } else { {} }
              } else {
                ✂
              }
          }
        }
    }
  }
###
\begin{rem}
The ##✂## symbol (to be pronounced "scissors") can be used to mark a
branch of the code as unreachable. It can be used whenever an equational
contradiction is induced by the form of a pattern. Here, it must be that
##o.cmp c1.hd c2.hd ≡ true## as otherwise the hypothesis that ##l## is a
sorted list would be contradicted. As the scissors symbol can be used in
the place of provably unreachable code, it can be replaced by any term
of the language.
\end{rem}

We can then prove that ##isort## produces lists that are sorted using a
simple proof by induction as follows.
### PML "examples/implem.pml"
val rec isort_sorted :
    ∀a:ο, ∀o∈ord<a>, ∀l∈list<a>, sorted o (isort o l) ≡ true =
  fun o l {
    case l {
      Nil     → {}
      Cons[c] → let lem = isort_total o c.tl;
                 let ind = isort_sorted o c.tl;
                 let lem = isorted o c.hd (isort o c.tl); {}
    }
  }
###
Finally, we can obtain a sorting function which return type indicates
that the produced list is sorted. As for vectors, the type of sorted
lists is a subtype of lists. As a consequence, a sorted list can be
used as a list transparently.
### PML "examples/implem.pml"
val isort_full : ∀a:ο, ∀o∈ord<a>, list<a> ⇒ slist<a,o> =
  fun o l {
    let tot = isort_total  o l;
    let lem = isort_sorted o l;
    isort o l
  }
###

=<
=> Lookup function with an exception

We will consider an example of a program
that relies on control operators as exceptions. We will take the
common example of a lookup function on the type of lists. However,
the type of our exception will carry a proof that the element that
is looked for is in the list. To encode this property, we will
rely on the ##exists## function (given in \chapter("intro")).
### PML "examples/implem.pml"
val rec exists : ∀a, (a ⇒ bool) ⇒ list<a> ⇒ bool =
  fun pred l {
    case l {
      Nil     → false
      Cons[c] → if pred c.hd { true } else { exists pred c.tl }
    }
  }
###

Our lookup function (named ##find##) can the be defined as follows,
using a logic negation as the type of the exception.
### PML "examples/implem.pml"
type bot = ∀x, x
type neg<a> = a ⇒ bot

val rec find :
    ∀a:ο, ∀pred∈(a ⇒ bool), total<pred,a> ⇒ ∀l∈list<a>,
    neg<exists pred l ≡ false> ⇒ a =
  fun pred pred_tot l exc {
    case l {
      Nil     → exc {}
      Cons[c] →
        let lem = pred_tot c.hd;
        if pred c.hd {
          c.hd
        } else {
          find pred pred_tot c.tl exc
        }
    }
  }
###
Note that the exception ##exc## can only be called if we are able
to feed it with a proof that no element of the list satisfy the
predicate ##pred##. As a consequence, we are guaranteed that the
exception cannot be raised if the list contains an element
satisfying ##pred##.

To conclude, let us give two examples of function defined using
##find##. The first one will simply call ##find## and wrap its
result in the usual ##option<a>## type.
### PML "examples/implem.pml"
val find_opt :
    ∀a:ο, ∀pred∈(a ⇒ bool), total<pred,a> ⇒ list<a> ⇒ option<a> =
  fun pred pred_tot l {
    save a {
      some (find pred pred_tot l (fun _ { restore a none }))
    }
  }
###
The second one does the same, but it looks for an element satisfying
the predicate into a list of lists.
### PML "examples/implem.pml"
val rec find_list :
    ∀a:ο, ∀pred∈(a ⇒ bool), total<pred,a> ⇒
    list<list<a>> ⇒ option<a> =
  fun pred pred_tot l {
    case l {
      Nil     → none
      Cons[c] →
        save a {
          let f = fun _ { restore a (find_list pred pred_tot c.tl) };
          some (find pred pred_tot c.hd f)
        }
    }
  }
###
Note that the recursive call of ##find_list## is done inside the
exception handler provided to ##find##.

=<
=> An infinite tape lemma on streams

To conclude this chapter, we will consider an example of program that can
only be written in a classical setting (i.e., with control operators). We
are going to define a function on streams of natural numbers, that extracts
from its input a stream of odd numbers, or a stream of even numbers. First,
we need to define odd and even numbers in our language.
### PML "examples/implem.pml"
val rec is_odd : nat ⇒ bool =
  fun n {
    case n {
      Zero    → false
      Succ[m] →
        case m {
          Zero    → true
          Succ[p] → is_odd p
        }
    }
  }

type odd  = {v∈nat | is_odd v ≡ true }
type even = {v∈nat | is_odd v ≡ false}
###
Note that here, we use a "set type" syntax similar to that of NuPrl
\cite("Constable1986"). It is encoded as follows in our system.
### PML "examples/implem.pml"
type odd  = ∃v:ι, v∈(nat | is_odd v ≡ true )
type even = ∃v:ι, v∈(nat | is_odd v ≡ false)
###

Before going further, we need to establish that the ##odd## function
is total. It will be required when we decide whether a given number
of the input stream is odd or even.
### PML "examples/implem.pml"
val rec odd_total : ∀n∈nat, ∃v:ι, is_odd n ≡ v =
  fun n {
    case n {
      Zero    → {}
      Succ[m] →
        case m {
          Zero    → {}
          Succ[p] → odd_total p
        }
    }
  }
###
We also need to define the type of streams, together a related type
corresponding to streams with an explicit size annotation (or ordinal)
##o##. Intuitively, this size annotation indicates the number of
elements that are available in the stream.
### PML "examples/implem.pml"
type corec stream<a> = {} ⇒ {hd : a; tl : stream}
type sized_stream<o,a> = νo stream {} ⇒ {hd : a; tl : stream}
###
We can now defined the ##itl_aux## function, which will be used
to build our main infinite tape lemma function. Note that this
function uses ##abort##, which logically amounts to the //ex
falso quodlibet// principle. Size annotations are also required
on the type of ##itl_aux##, for our type-checking algorithm to
prove its termination.
### PML "examples/implem.pml"
val abort : ∀y, empty ⇒ y = fun x { x }

val rec itl_aux :
    ∀a b, neg<sized_stream<a,even>> ⇒
    neg<sized_stream<b,odd>> ⇒ neg<stream<nat>> =
  fun fe fo s {
    let hd = (s {}).hd;
    let tl = (s {}).tl;
    use odd_total hd;
    if is_odd hd {
      fo (fun _ {
        {hd = hd; tl = save o {
          abort (itl_aux fe (fun x { restore o x }) tl)}}
      })
    } else {
      fe (fun _ {
        {hd = hd; tl = save e {
          abort (itl_aux (fun x { restore e x }) fo tl)}}
      })
    }
  }
###
Intuitively, the ##itl_aux## function looks at the head of its third
argument (a stream of natural numbers). Depending on whether this
number is odd or even, the function then calls one of its first two
arguments, which corresponds to a partially constructed stream of
even or odd numbers. The read number is then added to this stream,
and a recursive call is made to continue the construction.
\begin{rem}
  It is surprising that our prototype implementation is able to establish the
  termination of ##itl_aux##. Indeed, at each call, an element is added to one
  of two streams. Moreover, this example does not satisfy the usually required
  semi-continuity condition (see, for example, \cite("Abel2008")).
\end{rem}

Using ##itl_aux##, it is then possible to define the ##itl## function
corresponding to our infinite tape lemma.
### PML "examples/implem.pml"
val itl : stream<nat> ⇒ [InL of stream<even>; InR of stream<odd>] =
  fun s {
    save a {
      InL[save e { restore a InR[save o {
        abort (itl_aux (fun x { restore e x}) (fun x { restore o x }) s)
      } ] } ]
    }
  }
###
This function starts by saving two continuations, corresponding to
the constructors ##InL## and ##InR## of the return type, and then
calls ##itl_aux## on the input stream. The very fact that we can
write ##itl## proves that it is possible to extract a stream of
odd numbers or a stream of even numbers from any stream of natural
numbers.

=<
=<
