\Include{Macros}

\Caml(
  open ProofTree
  open Diagrams
  open PMLVerbatim
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\mathsize{3.}{\wbox}$>
  let bbox = <$\mathsize{3.}{\bbox}$>
)

\Configure_math_macro{\v}{ syntax = string; }
\Configure_math_macro{\t}{ syntax = string; }
\Configure_math_macro{\s}{ syntax = string; }
\Configure_math_macro{\p}{ syntax = string; }
\Configure_math_macro{\f}{ syntax = string; }
\Configure_math_macro{\vs}{ syntax = string; }
\Configure_math_macro{\ss}{ syntax = string; }
\Configure_math_macro{\ts}{ syntax = string; }

=> Implementation and examples \label("implem")

In this last chapter, we consider examples of programs and proofs that can be
written and manipulated using our prototype implementation. This restricted
set of examples is not intended to give an exhaustive view of our language.
Their only purpose is to demonstrate its expressiveness through a selected
set of examples that seem interesting to the author. This chapter also
contains some discussions on possible extensions and improvement on the
system and its implementation.

=> Encoding of strict product types

As discussed in the previous chapter, the most natural semantics for product
types in presence of subtyping allows for extensible records. In other words,
it is alway possible to provide more fields than necessary. However, product
types with a fixed set of fields often arise in practice. For this reason, we
introduced so-called strict product types, which were used to state our type
safety theorem (\theorem("fullsafety")). In this section, we will show that
it is possible to encode strict records into the system, without extending
it with two different forms of product types.

Let us first consider the "unit" type, corresponding to the empty product.
In our system, a first attempt at defining such a type would be to use an
extensible record with no fields. However, as indicated by its name, this
type contains many more elements that the empty record (written ##{}## in
our system).
### PML "examples/realunit.pml"
type wrong_unit = {⋯}

// It is inhabited by the empty record.
val u : wrong_unit = {}

// And in fact by any record...
val u_aux : wrong_unit = {l = {}}
###

To avoid extending the system with strict record types, it is possible to
use one of the following three encodings for the ##unit## type. They rely
on the membership type, optionally combined with existential quantification
and restriction.
### PML "examples/realunit.pml"
type unit1 = {} ∈ {⋯}
type unit2 = ∃x:ι, x ∈ ({⋯} | x ≡ {})
type unit3 = ∃x:ι, x ∈ {⋯} | x ≡ {}
###
Note that these types are all equivalent semantically. In the implementation,
we chose to use the definition ##unit1## in place of the syntactic sugar
##{}## (strict product type with no fields). We can thus use the following
definition for a reasonable ##unit## type.
### PML "examples/realunit.pml"
def unit : ο = {} ∈ {⋯}
// def unit : ο = {}

// It is inhabited by the empty record.
val u : unit = {}

// But not by any other record.
// val fail : unit = {l = {}}
###
In fact, we can show that every value of ##unit## is equivalent to the
empty record ##{}## with the following proof.
### PML "examples/realunit.pml"
val true_unit : ∀x∈unit, x ≡ {} = fun x → {}
###

The encoding of strict products is not limited to the unit type. A similar
encoding can be used for any record type, and it is made accessible in the
syntax using the strict product type notation. For instance, the type of
pairs ##pair<a,b>## can be encoded as follows.
### PML "examples/pair.pml"
type pair<a,b> = ∃ x y:ι, {fst = x ; snd = y} ∈ {fst : a ; snd : b ⋯}
// type pair<a,b> = {fst : a ; snd : b}

val couple : ∀ a b, a ⇒ b ⇒ pair<a,b> = fun x y →
  {fst = x ; snd = y}

val pi1 : ∀ a b, pair<a,b> ⇒ a = fun p → p.fst
val pi2 : ∀ a b, pair<a,b> ⇒ b = fun p → p.snd
###
As for the unit type, it is possible to show that the elements of a pair
type are indeed records with exactly two fields ##fst## and ##snd##.
### PML "examples/pair.pml"
val true_pair : ∀a b, ∀p∈pair<a,b>, ∃x y:ι, p ≡ {fst = x ; snd = y} =
  fun p → {}
###

=<
=> Booleans and tautologies

After defining the (one element) ##unit## type in the previous section,
we will now consider the (two elements) type of booleans. It can be encoded
as usual using a polymorphic variant type as follows.
### PML "examples/bool.pml"
type bool = [Fls of unit ; Tru of unit]
// type bool = [Fls ; Tru]
###
Note that our variants need to have exactly one argument, which will here
be ##unit## on both the ##Tru## and ##Fls## constructors. It would be the
case implicitly if no argument type was provided.

In practice, booleans are often used together with conditional structures.
In our language, there are several (non-equivalent) ways of defining them.
A first possibility would be to define a condition function with three
arguments as follows.
### PML "examples/bool.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a = fun c e1 e2 →
  case c of Tru[_] → e1 | Fls[_] → e2
###
However, this function leads to both the expressions for the "then" and
"else" branch to be evaluated, before a choice is made. This is not the
semantics that is expected in practice, as it would be rather inefficient.

In our language, we can encode the usual "if ... then ... else ..."
construct using the definition of a term macro ##cond## with three term
arguments. This is made possible by the higher-order features of our
language.
### PML "examples/bool.pml"
def cond<c:τ, e1:τ, e2:τ> : τ =
  case c of Tru[_] → e1 | Fls[_] → e2
###
Although such a macro remains untyped in the system, we can check that
can be "typed" as expected by giving the following alternative definition
of ##cond_fun## (which is actually expended to the exact same definition
as above).
### PML "examples/bool.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a = fun c e1 e2 →
  cond<c, e1, e2>
###
Note that in the syntax, the syntactic sugar ##if c then e1 else e2## is
immediately translated to ##cond<c, e1, e2>## according to the definition
given above.

Note that the definition of similar macros can be used for definition an
##and## and an ##or## operator with the expected (lazy) semantics. This
feature is in fact useful in many ways, we will see in a further section
that it can even be used to encode proof tactics.
### PML "examples/bool.pml"
def land<b1:τ,b2:τ> =
  case b1 of Tru[_] → b2 | Fls[_] → Fls

def lor<b1:τ,b2:τ> =
  case b1 of Tru[_] → Tru | Fls[_] → b2
###

Before going further, we are going to define a set of usual boolean
operators. We will then consider their prove that they behave as
they are expected to in the system.
### PML "examples/bool.pml"
val not : bool ⇒ bool = fun a →
  case a of Fls[_] → Tru | Tru[_] → Fls

val or  : bool ⇒ bool ⇒ bool = fun a b → lor <a, b>
val and : bool ⇒ bool ⇒ bool = fun a b → land<a, b>
val imp : bool ⇒ bool ⇒ bool = fun a b → lor <b, not a>

val xor : bool ⇒ bool ⇒ bool = fun a b →
  case a of
  | Fls[_] → (case b of Fls[_] → Fls | Tru[_] → Tru)
  | Tru[_] → (case b of Fls[_] → Tru | Tru[_] → Fls)

val eq : bool ⇒ bool ⇒ bool = fun a b → xor a (not b)
###
As a first example of proof, we are going to consider the law of the
excluded middle. It can be stated and proved as follows in the system.
### PML "examples/bool.pml"
val excluded_middle : ∀x∈bool, or x (not x) ≡ Tru = fun b →
  case b of Fls[_] → {} | Tru[_] → {}
###


### PML "examples/bool.pml"
// Equivalence is reflexive.
val eq_refl : ∀x∈bool, eq x x ≡ Tru = fun b →
  case b of
  | Fls[_] → {}
  | Tru[_] → {}

// Equivalence is commutative.
val eq_comm : ∀x y∈bool, eq x y ≡ eq y x = fun b1 b2 →
  case b1 of
  | Fls[_] → (case b2 of Tru[_] → {} | Fls[_] → {})
  | Tru[_] → (case b2 of Tru[_] → {} | Fls[_] → {})


val eq_comm2 : ∀x y∈bool, eq (eq x y) (eq y x) ≡ Tru = fun b1 b2 →
  case b1 of
  | Fls[_] → (case b2 of Tru[_] → {} | Fls[_] → {})
  | Tru[_] → (case b2 of Tru[_] → {} | Fls[_] → {})

// Equivalence is associative.
val eq_asso : ∀x y z∈bool, eq (eq x y) z ≡ eq x (eq y z) =
  fun b1 b2 b3 →
    case b1 of
    | Fls[_] → (case b2 of
                 | Tru[_] → (case b3 of Tru[_] → {} | Fls[_] → {})
                 | Fls[_] → (case b3 of Tru[_] → {} | Fls[_] → {}))
    | Tru[_] → (case b2 of
                 | Tru[_] → (case b3 of Tru[_] → {} | Fls[_] → {})
                 | Fls[_] → (case b3 of Tru[_] → {} | Fls[_] → {}))

val eq_asso2 : ∀x y z∈bool, eq (eq (eq x y) z) (eq x (eq y z)) ≡ Tru =
  fun b1 b2 b3 →
    case b1 of
    | Fls[_] → (case b2 of
                 | Tru[_] → (case b3 of Tru[_] → {} | Fls[_] → {})
                 | Fls[_] → (case b3 of Tru[_] → {} | Fls[_] → {}))
    | Tru[_] → (case b2 of
                 | Tru[_] → (case b3 of Tru[_] → {} | Fls[_] → {})
                 | Fls[_] → (case b3 of Tru[_] → {} | Fls[_] → {}))
###

=<
=> Proofs on unary natural numbers

\todo(None) (* TODO *)

### PML "examples/unat.pml"
type rec nat = [ Z ; S of nat ]

val zero : nat = Z[]
val succ : nat ⇒ nat = fun n → S[n]
val one  : nat = succ zero
val two  : nat = succ one

val rec id_nat : nat ⇒ nat = fun n →
  case n of
  | Z[] → Z[]
  | S[p] → succ (id_nat p)

val test : nat = id_nat two

val rec id_nat_id : ∀n∈nat, id_nat n ≡ n = fun m →
  case m of
  | Z[] → {}
  | S[p] → let ind_hyp : id_nat p ≡ p = id_nat_id p in {}

val rec add : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Z[] → m
  | S[p] → succ (add p m)

val partial_add_total : ∀x:ι, ∃v:ι, add x ≡ v = {}

val rec strong_add_total : ∀n∈nat, ∀m∈(∃x,x), ∃v:ι, add n m ≡ v = fun n m →
  case n of
  | Z[_] → {}
  | S[p] → let ind_hyp = strong_add_total p m in {}

// FIXME should work
val rec strong_add_total : ∀m:ι, ∀n∈nat, ∃v:ι, add n m ≡ v = Λm:ι.fun n →
  case n of
  | Z[_] → {}
  | S[p] → let deduce  : add n m ≡ S[add p m] = {} in
           let ind_hyp : (∃v:ι, add p m ≡ v) = strong_add_total p in {}

val rec add_total : ∀n m∈nat, ∃v:ι, add n m ≡ v = fun n m →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp = add_total p m in {}

def addt<x:τ,y:τ> : τ =
   let lem = add_total x y in add x y

val add_zero_left : ∀z∈nat, add zero z ≡ z = fun n → {}

val rec add_zero1 : ∀z∈nat, add z zero ≡ z = fun k →
  case k of
  | Z[] → {}
  | S[p] →
    let ind_hyp = (add_zero1 p : add p zero ≡ p) in {}

val rec add_zero2 : ∀n∈nat, add n zero ≡ n = fun n →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp : add p zero ≡ p = add_zero2 p in {}

val rec add_asso : ∀n m q∈nat, add n (add m q) ≡ add (add n m) q =
  fun n m q →
    let tot1 = add_total m q in
    case n of
    | Z[] → {}
    | S[p] →
      let deduce : add n (add m q) ≡ succ (add p (add m q)) = {} in
      let tot2 = add_total p m in
      let deduce : add (add n m) q ≡ succ (add (add p m) q) = {} in
      let ind_hyp = add_asso p m q in
      {}

val rec add_zero : ∀n∈nat, add n zero ≡ n = fun n →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp = add_zero p in {}

val rec add_succ : ∀n m∈nat, add n S[m] ≡ succ(add n m) = fun n m →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp = add_succ p m in {}

val rec add_succ2 : ∀n m∈nat, add n S[m] ≡ S[add n m] = fun n m →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp : add p S[m] ≡ S[add p m] = add_succ p m in {}

val add_comm : ∀n m∈nat, add n m ≡ add m n = fix fun add_comm n m →
  case n of
  | Z[] → let lem = add_zero m in {}
  | S[p] →
    let ind_hyp = add_comm p m in
    let lem = add_succ m p in
    {}

val mul : nat ⇒ nat ⇒ nat = fix fun mul n m →
  case n of
  | Z[] → Z[]
  | S[p] → add m (mul p m)

val mul_total : ∀n m∈nat, ∃v:ι, mul n m ≡ v = fix fun mul_total n m →
  case n of
  | Z[] → {}
  | S[p] →
   let ind_hyp = mul_total p m in
   let lem = add_total m (mul p m) in
   {}

val mul_zero : ∀n∈nat, mul n zero ≡ zero = fix fun mul_zero n →
  case n of
  | Z[] → {}
  | S[p] →
    let ind_hyp : mul p zero ≡ zero = mul_zero p in
    let deduce : add zero (mul p zero) ≡ mul n zero = {} in
    let deduce : add zero (mul p zero) ≡ zero = {} in
    {}

val mul_zero1 : ∀n∈nat, mul n zero ≡ zero = fix fun mul_zero n →
  case n of
  | Z[]  → {}
  | S[p] → let ind_hyp = mul_zero p in {}

val mul_succ : ∀n m∈nat, mul n S[m] ≡ add (mul n m) n = fix fun mul_succ n m →
  case n of
  | Z[]  → {}
  | S[p] →
    let deduce : add (mul n m) n ≡ add (add m (mul p m)) n = {} in
    let ind_hyp : mul p S[m] ≡ add (mul p m) p = mul_succ p m in
    let total = mul_total p m in
    let total = add_total m (mul p m) in
    let deduce : add (add m (mul p m)) n ≡ succ (add (add m (mul p m)) p) =
      add_succ (add m (mul p m)) p
    in
    let deduce : add (add m (mul p m)) n ≡ succ (add m (add (mul p m) p)) =
      add_asso m (mul p m) p
    in
    let deduce : add (add m (mul p m)) n ≡ succ (add m (mul p S[m])) =
      {}
    in
    let total = mul_total p S[m] in
    let deduce : add (add m (mul p m)) n ≡ add S[m] (mul p S[m]) =
      {}
    in
    let deduce : add (add m (mul p m)) n ≡ mul n S[m] =
      {}
    in
    {}

val mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fix fun mul_comm n m →
  case n of
  | Z[]  → let lem = mul_zero m in {}
  | S[p] →
     let ind : mul p m ≡ mul m p = mul_comm m p in
     let lem = mul_succ m p in
     let tot = mul_total p m in
     let lem = add_comm (mul p m) m in
     {}
###

=<
=> Lists and their vector subtypes

\todo(None) (* TODO *)

### PML "examples/vec.pml"
type rec nat = [ Z ; S of nat ]

val zero : nat = Z[]
val succ : nat ⇒ nat = fun n → S[n]

val rec add : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Z[] → m
  | S[p] → succ (add p m)

val rec add_total : ∀n m∈nat, ∃v:ι, add n m ≡ v = fun n m →
  case n of
  | Z[] → {}
  | S[p] → let ind_hyp = add_total p m in {}

type rec list<a:ο> = [ Nil; Cns of { hd : a; tl : list }  ]

val nil : ∀a:ο, list<a> = Nil[]
val cns : ∀a:ο, a ⇒ list<a> ⇒ list<a> =
  fun e l → Cns[{ hd = e; tl = l }]

val rec length : ∀a:ο, list<a> ⇒ nat = fun l →
  case l of
  | Nil[] → zero
  | Cns[c] → succ (length c.tl)

val rec length_total : ∀a:ο, ∀l∈list<a>, ∃v:ι, v ≡ length l = fun l →
  case l of
  | Nil[] → {}
  | Cns[c] → let ind = length_total c.tl in {}

type vec<a:ο,s:τ> = ∃l:ι, l∈(list<a> | length l ≡ s)
// The fact that s:τ is very important
// The position of the partenthesis is important

val vnil : ∀a:ο, vec<a,zero> = nil

val vcns : ∀a:ο,∀s:ι, ∀x∈a, vec<a,s> ⇒ vec<a,succ s> =
   fun y ls → Cns[{hd= y;tl= ls}]

val rec app : ∀a:ο, ∀n1 n2:ι, vec<a,n1> ⇒ vec<a,n2> ⇒ vec<a,add n1 n2> =
  Λa:ο. fun l1 l2 →
  case l1 of
  | Nil[] → l2
  | Cns[c] →
      let lem = length_total c.tl in
      (case length l1 of
      | Z[] → ✂
      | S[p1] →
        let r = app c.tl l2 in
        let lem = length_total (r : list<a>) in
        vcns c.hd r)

val app3 : ∀a:ο, ∀n1 n2 n3:ι,
           vec<a,n1> ⇒ vec<a,n2> ⇒ vec<a,n3> ⇒ vec<a,add n1 (add n2 n3)> =
    fun l1 l2 l3 →
      let lem = add_total (length l2) (length l3) in
      app l1 (app l2 l3)
###

=<
=> Case study: sorting algorithm

\todo(None) (* TODO *)

=<
=> Case study: $λ$-calculus

\todo(None) (* TODO *)

=<
=<
