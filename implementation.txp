\Include{Macros}

\Caml(
  open ProofTree
  open Diagrams
  open PMLVerbatim
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\mathsize{3.}{\wbox}$>
  let bbox = <$\mathsize{3.}{\bbox}$>
)

\Configure_math_macro{\v}{ syntax = string; }
\Configure_math_macro{\t}{ syntax = string; }
\Configure_math_macro{\s}{ syntax = string; }
\Configure_math_macro{\p}{ syntax = string; }
\Configure_math_macro{\f}{ syntax = string; }
\Configure_math_macro{\vs}{ syntax = string; }
\Configure_math_macro{\ss}{ syntax = string; }
\Configure_math_macro{\ts}{ syntax = string; }

=> Implementation and examples \label("implem")

In this last chapter, we consider examples of programs and proofs that can be
written and manipulated using our prototype implementation. This restricted
set of examples is not intended to give an exhaustive view of our language.
Their only purpose is to demonstrate its expressiveness through a selected
set of examples that seem interesting to the author. This chapter also
contains some discussions on possible extensions and improvement on the
system and its implementation.

=> Encoding of strict product types

As discussed in the previous chapter, the most natural semantics for product
types in presence of subtyping allows for extensible records. In other words,
it is alway possible to provide more fields than necessary. However, product
types with a fixed set of fields often arise in practice. For this reason, we
introduced so-called strict product types, which were used to state our type
safety theorem (\theorem("fullsafety")). In this section, we will show that
it is possible to encode strict records into the system, without extending
it with two different forms of product types.

Let us first consider the "unit" type, corresponding to the empty product.
In our system, a first attempt at defining such a type would be to use an
extensible record with no fields. However, as indicated by its name, this
type contains many more elements that the empty record (written ##{}## in
our system).
### PML "examples/realunit.pml"
type wrong_unit = {⋯}

// It is inhabited by the empty record.
val u : wrong_unit = {}

// And in fact by any record...
val u_aux : wrong_unit = {l = {}}
###

To avoid extending the system with strict record types, it is possible to
use one of the following three encodings for the ##unit## type. They rely
on the membership type, optionally combined with existential quantification
and restriction.
### PML "examples/realunit.pml"
type unit1 = {} ∈ {⋯}
type unit2 = ∃x:ι, x ∈ ({⋯} | x ≡ {})
type unit3 = ∃x:ι, x ∈ {⋯} | x ≡ {}
###
Note that these types are all equivalent semantically. In the implementation,
we chose to use the definition ##unit1## in place of the syntactic sugar
##{}## (strict product type with no fields). We can thus use the following
definition for a reasonable ##unit## type.
### PML "examples/realunit.pml"
def unit : ο = {} ∈ {⋯}
// def unit : ο = {}

// It is inhabited by the empty record.
val u : unit = {}

// But not by any other record.
// val fail : unit = {l = {}}
###
In fact, we can show that every value of ##unit## is equivalent to the
empty record ##{}## with the following proof.
### PML "examples/realunit.pml"
val true_unit : ∀x∈unit, x ≡ {} = fun x → {}
###

The encoding of strict products is not limited to the unit type. A similar
encoding can be used for any record type, and it is made accessible in the
syntax using the strict product type notation. For instance, the type of
pairs ##pair<a,b>## can be encoded as follows.
### PML "examples/pair.pml"
type pair<a,b> = ∃ x y:ι, {fst = x ; snd = y} ∈ {fst : a ; snd : b ⋯}
// type pair<a,b> = {fst : a ; snd : b}

val couple : ∀ a b, a ⇒ b ⇒ pair<a,b> = fun x y →
  {fst = x ; snd = y}

val pi1 : ∀ a b, pair<a,b> ⇒ a = fun p → p.fst
val pi2 : ∀ a b, pair<a,b> ⇒ b = fun p → p.snd
###
As for the unit type, it is possible to show that the elements of a pair
type are indeed records with exactly two fields ##fst## and ##snd##.
### PML "examples/pair.pml"
val true_pair : ∀a b, ∀p∈pair<a,b>, ∃x y:ι, p ≡ {fst = x ; snd = y} =
  fun p → {}
###

=<
=> Booleans and tautologies

After defining the (one element) ##unit## type in the previous section,
we will now consider the (two elements) type of booleans. It can be encoded
as usual using a polymorphic variant type as follows.
### PML "examples/bool.pml"
type bool = [Fls of unit ; Tru of unit]
// type bool = [Fls ; Tru]
###
Note that our variants need to have exactly one argument, which will here
be ##unit## on both the ##Tru## and ##Fls## constructors. It would be the
case implicitly if no argument type was provided.

In practice, booleans are often used together with conditional structures.
In our language, there are several (non-equivalent) ways of defining them.
A first possibility would be to define a condition function with three
arguments as follows.
### PML "examples/bool.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a = fun c e1 e2 →
  case c of Tru[_] → e1 | Fls[_] → e2
###
However, this function leads to both the expressions for the "then" and
"else" branch to be evaluated, before a choice is made. This is not the
semantics that is expected in practice, as it would be rather inefficient.

In our language, we can encode the usual "if ... then ... else ..."
construct using the definition of a term macro ##cond## with three term
arguments. This is made possible by the higher-order features of our
language.
### PML "examples/bool.pml"
def cond<c:τ, e1:τ, e2:τ> : τ =
  case c of Tru[_] → e1 | Fls[_] → e2
###
Although such a macro remains untyped in the system, we can check that
can be "typed" as expected by giving the following alternative definition
of ##cond_fun## (which is actually expended to the exact same definition
as above).
### PML "examples/bool.pml"
val cond_fun : ∀ a, bool ⇒ a ⇒ a ⇒ a = fun c e1 e2 →
  cond<c, e1, e2>
###
Note that in the syntax, the syntactic sugar ##if c then e1 else e2## is
immediately translated to ##cond<c, e1, e2>## according to the definition
given above.

Note that the definition of similar macros can be used for definition an
##and## and an ##or## operator with the expected (lazy) semantics. This
feature is in fact useful in many ways, we will see in a further section
that it can even be used to encode proof tactics.
### PML "examples/bool.pml"
def land<b1:τ,b2:τ> =
  case b1 of Tru[_] → b2 | Fls[_] → Fls

def lor<b1:τ,b2:τ> =
  case b1 of Tru[_] → Tru | Fls[_] → b2
###

Before going further, we are going to define a set of usual boolean
operators. We will then consider their prove that they behave as
they are expected to in the system.
### PML "examples/bool.pml"
val not : bool ⇒ bool = fun a →
  case a of Fls[_] → Tru | Tru[_] → Fls

val or  : bool ⇒ bool ⇒ bool = fun a b → lor <a, b>
val and : bool ⇒ bool ⇒ bool = fun a b → land<a, b>
val imp : bool ⇒ bool ⇒ bool = fun a b → lor <b, not a>

val xor : bool ⇒ bool ⇒ bool = fun a b →
  case a of
  | Fls[_] → (case b of Fls[_] → Fls | Tru[_] → Tru)
  | Tru[_] → (case b of Fls[_] → Tru | Tru[_] → Fls)

val eq : bool ⇒ bool ⇒ bool = fun a b → xor a (not b)
###
As a first example of proof, we are going to consider the law of the
excluded middle. It can be stated and proved as follows in the system.
### PML "examples/bool.pml"
val excl_mid : ∀x∈bool, or x (not x) ≡ Tru = fun b →
  case b of Fls[_] → {} | Tru[_] → {}
###
\begin{rem}
The law of the excluded middle on booleans is not to be confused with the
term using control operators that was given in the introduction. Indeed,
they live in completely different levels of the system.
\end{rem}

As the type of booleans contain only finitely many elements, properties
can alway be proved by exhaustively listing the different cases. This is
what was done above for ##excl_mid##, but it was not too tedious as there
were only two cases. This will not be the case anymore when considering
properties with more parameters. For example, let us consider the
reflexivity, commutativity of the ##eq## function.
### PML "examples/bool.pml"
val eq_refl : ∀a∈bool, eq a a ≡ Tru = fun a →
  case a of Fls[_] → {} | Tru[_] → {}

val eq_comm : ∀a b∈bool, eq a b ≡ eq b a = fun a b →
  case a of
  | Fls[_] → (case b of Tru[_] → {} | Fls[_] → {})
  | Tru[_] → (case b of Tru[_] → {} | Fls[_] → {})

val eq_asso : ∀a b c∈bool, eq (eq a b) c ≡ eq a (eq b c) = fun a b c →
  case a of
  | Fls[_] →
      (case b of
       | Tru[_] → (case c of Tru[_] → {} | Fls[_] → {})
       | Fls[_] → (case c of Tru[_] → {} | Fls[_] → {}))
  | Tru[_] →
      (case b of
       | Tru[_] → (case c of Tru[_] → {} | Fls[_] → {})
       | Fls[_] → (case c of Tru[_] → {} | Fls[_] → {}))
###
To simplify the writing of such trivial proofs, it is possible to use
term macros defined using higher-order definitions. Such macros can then
be used to prove any tautology with a given number of arguments on
booleans.
### PML "examples/bool.pml"
def auto1<a:τ>           : τ = if a then {} else {}
def auto2<a:τ, b:τ>      : τ = if a then auto1<b> else auto1<b>
def auto3<a:τ, b:τ, c:τ> : τ = if a then auto2<b,c> else auto2<b,c>

val eq_refl_auto : ∀a∈bool, eq a a ≡ Tru =
  fun a → auto1<a>

val eq_comm_auto : ∀a b∈bool, eq a b ≡ eq b a =
  fun a b → auto2<a,b>

val eq_asso_auto : ∀a b c∈bool, eq (eq a b) c ≡ eq a (eq b c) =
  fun a b c → auto3<a,b,c>
###

=<
=> Unary natural numbers and totality

It is now time to consider a first example of data type with infinitely
many elements: unary natural numbers. Their definition was already given
in \chapter("intro"), together with some simple proofs. Let us start by
recalling the definition of unary natural numbers, together with their
addition and multiplication functions.
### PML "examples/unat.pml"
type rec nat = [Zero ; Succ of nat]

val rec add : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Zero[_] → m
  | Succ[k] → Succ[add k m]

val rec mul : nat ⇒ nat ⇒ nat = fun n m →
  case n of
  | Zero[_] → Zero
  | Succ[k] → add m (mul k m)
###
As ##add## and ##mul## are defined using recursion on their first argument,
it is immediate to show ##add Zero n ≡ n## and ##mul Zero n ≡ Zero## for
every ##n##.
### PML "examples/unat.pml"
val add_zero_v : ∀v:ι, add Zero v ≡ v    = {}
val mul_zero_v : ∀v:ι, mul Zero v ≡ Zero = {}
###
Note that these properties are proved by quantifying over every possible
value ##v##. Whether it is a unary natural number or not is not important
as ##add Zero v## and ##mul Zero v## can still be unfolded. In fact, the
##add## function can always be given an arbitrary value as second argument
as it is never considered in a case analysis.

Of course, it is possible to show similar properties by quantifying only
on natural numbers using dependent functions.
### PML "examples/unat.pml"
val add_zero_n : ∀n∈nat, add Zero n ≡ n    = fun _ → {}
val mul_zero_n : ∀n∈nat, mul Zero n ≡ Zero = fun _ → {}
###
However, such definitions will never need to be used in practice since the
more general ##add_zero_v## and ##mul_zero_v## have trivial proofs. This
means that they can be obtained immediately by unfolding definitions, and
thus it will never be necessary to invoke them. In particular, the user
will never need to call ##add_zero_n## or ##mul_zero_n## to prove the
corresponding equivalences.

Let us now consider the commutativity of the ##add## function, which is a
much more interesting example. To obtain this properties, two lemmas are
required. We need to prove that ##add n Zero ≡ n## for every unary number
##n##, and that ##add n Succ[m] ≡ Succ[add n m]## for every unary numbers
##n## and ##m##. These two properties can be obtained easily using a case
analysis and induction.
### PML "examples/unat.pml"
val rec add_n_zero : ∀n∈nat, add n Zero ≡ n = fun n →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = add_n_zero k in {}

val rec add_succ : ∀n m∈nat, add n Succ[m] ≡ Succ[add n m] = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = add_succ k m in {}
###
A proof of the commutativity of ##add## is then obtained in a similar way,
but the two previously proved lemmas are used.
### PML "examples/unat.pml"
val rec add_comm : ∀n m∈nat, add n m ≡ add m n = fun n m →
  case n of
  | Zero[_] → let lem = add_n_zero m in {}
  | Succ[k] → let ih = add_comm k m in
               let lem = add_succ m k in {}
###
Note that in the system, a lemma is used by calling the corresponding
function. Similarly, using an induction hypothesis corresponds to performing
a recursive call. A proof can thus only be correct if it terminates on
every possible input. Otherwise, obviously invalid proofs would be allowed
by using a "non decreasing induction hypothesis".

When going toward more complex example, it becomes a necessity to establish
the totality of functions. In other words, it will sometimes be required to
show that the application of a function to any value produces a value. As an
example, we will prove the totality of the ##add## function.
### PML "examples/unat.pml"
val rec add_total : ∀n m∈nat, ∃v:ι, add n m ≡ v = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = add_total k m in {}
###
Using ##add_total## twice, it is then possible to show that addition function
##add## corresponds to an associative operation.
### PML "examples/unat.pml"
val rec add_asso : ∀n m p∈nat, add n (add m p) ≡ add (add n m) p =
  fun n m p →
    let tot_m_p = add_total m p in
    case n of
    | Zero[_] → {}
    | Succ[k] → let tot_k_m = add_total k m in
                 let ih = add_asso k m p in {}
###

To conclude this section, we will prove the commutativity of the ##mul##
function. This result requires three intermediate lemmas. First, we need
to show that ##mul n Zero ≡ Zero## for every unary number ##n## and that
##mul## is total. It is then necessary to show that
##mul n Succ[m] ≡ add (mul n m) n## for all ##n## and ##m##. These three
properties are rather straight-forward to obtain, even if longer proofs
are harder to read.
### PML "examples/unat.pml"
val rec mul_n_zero : ∀n∈nat, mul n Zero ≡ Zero = fun n →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = mul_n_zero k in {}

val rec mul_total : ∀n m∈nat, ∃v:ι, mul n m ≡ v = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let ih = mul_total k m in
               let lem = add_total m (mul k m) in {}

val rec mul_succ : ∀n m∈nat, mul n Succ[m] ≡ add (mul n m) n = fun n m →
  case n of
  | Zero[_] → {}
  | Succ[k] → let lem = mul_succ k m in
               let tot = mul_total k m in
               let tot = add_total m (mul k m) in
               let lem = add_succ (add m (mul k m)) k in
               let lem = add_asso m (mul k m) k in
               let tot = mul_total k Succ[m] in {}
###
The commutativity of ##mul## then follows using yet another proof by
induction, using each of the above lemmas.
### PML "examples/unat.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fun n m →
  case n of
  | Zero[_] → let lem = mul_n_zero m in {}
  | Succ[k] → let ih  = mul_comm m k in
               let lem = mul_succ m k in
               let tot = mul_total k m in
               let lem = add_comm (mul k m) m in {}
###

One possible way for making a proof more readable is to give type
annotations. They can be used to specify explicitly the equivalences
that are being shown when using lemmas, but also for checking that
some properties can be derived at a given point in the proof. We give
bellow another version of ##mul_comm## annotated in this way.
### PML "examples/unat.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fun n m →
  case n of
  | Zero[_] → let ded : mul Zero m ≡ Zero = {} in
               let lem : mul m Zero ≡ Zero = mul_n_zero m in {}
  | Succ[k] → let ded : mul Succ[k] m ≡ add m (mul k m) = {} in
               let ih  : mul k m ≡ mul m k = mul_comm k m in
               let lem : mul m Succ[k] ≡ add (mul m k) m =
                 mul_succ m k
               in
               let tot : (∃v:ι, mul k m ≡ v) = mul_total k m in
               let lem : add (mul k m) m ≡ add m (mul k m) =
                 add_comm (mul k m) m
               in {}
###
Here, we add type annotations on used lemmas to explicit the properties
they prove. We also extend the proof with intermediate steps using local
definitions. They allow us to check that some property can be deduced in
the current context, while showing more reasoning steps. Note that the
names chosen for the local definitions is never used, and is thus not
important. Only the equations that are transparently added to the context
matter. Using this discipline, the proofs are not only more readable, but
also easier to write.

Another, more satisfactory way of obtaining more readable proofs is to
use again the higher-order layer of our system to define "tactics". We
will here use a ##deduce## tactic to check that some equation holds in
the current context, and a ##show## tactic to prove a property using
a given proof. 
### PML "examples/unat.pml"
def deduce<f:ο> : τ = ({} : f)
def show<f:ο, p:τ> : τ = (p : f)
###
We can then modify our commutativity proof to obtain the following, which
is a lot more readable than our original proof. Note that here, we use
semicolons to put proof steps in sequence. It is encoded as usual using
a dummy redex.
### PML "examples/unat.pml"
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fun n m →
  case n of
  | Zero[_] → deduce<mul Zero m ≡ Zero>;
               show<mul m Zero ≡ Zero, mul_n_zero m>
  | Succ[k] → deduce<mul Succ[k] m ≡ add m (mul k m)>;
               show<mul k m ≡ mul m k, mul_comm k m>;
               show<mul m Succ[k] ≡ add (mul m k) m, mul_succ m k>;
               show<(∃v:ι, mul k m ≡ v), mul_total k m>;
               show<add (mul k m) m ≡ add m (mul k m)
                    , add_comm (mul k m) m>
###
We could even introduce syntactic sugar for our tactics into the parser
of our language to obtain the following, very satisfactory proof.
### PML
val rec mul_comm : ∀n m∈nat, mul n m ≡ mul m n = fun n m →
  case n of
  | Zero[_] → deduce mul Zero m ≡ Zero;
               show mul m Zero ≡ Zero using mul_n_zero m
  | Succ[k] → deduce mul Succ[k] m ≡ add m (mul k m);
               show mul k m ≡ mul m k using mul_comm k m;
               show mul m Succ[k] ≡ add (mul m k) m
                 using mul_succ m k;
               show ∃v:ι, mul k m ≡ v using mul_total k m;
               show add (mul k m) m ≡ add m (mul k m)
                 using add_comm (mul k m) m
###

=<
=> Lists and their vector subtypes

We will now consider the type of lists containing elements of a fixed type,
given as a parameter. As usual, operations on lists will be polymorphic in
this parameter.
### PML "examples/unat.pml"
type rec list<a:ο> = [Nil ; Cons of {hd : a ; tl : list}]
###
According to the above definition, a list is either empty (##Nil##
constructor), or built using a smaller list and an element (##Cons##
constructor). Note that the argument of the ##Cons## constructor is
formed using a product (or record) type with two elements. The label
##hd## denotes the //head// of the list (i.e. its first element) and
##tl## denotes its //tail//.
\begin{rem}
  The type that is stored under the ##tl## label is ##list## and not
  ##list<a>## due to the encoding of the "##type rec##" construct. It
  is formed using a higher-order function which body contains a fixpoint
  construction over a variable named ##list##.
\end{rem}

As for the natural number, it is possible to define the usual
functions on lists, including ##exists## or ##rev_append## (see
\chapter("intro")). Many more functions are given in the standard
library of the prototype, together with its source code. Here, we
will only focus on the ##length## function, that will be used for
encoding vectors. Note that we will also need the fact that the
##length## function is total.
### PML "examples/unat.pml"
val rec length : ∀a:ο, list<a> ⇒ nat = fun l →
  case l of
  | Nil[_]  → Zero
  | Cons[c] → Succ[length c.tl]

val rec length_total : ∀a:ο, ∀l∈list<a>, ∃v:ι, v ≡ length l = fun l →
  case l of
  | Nil[_]  → {}
  | Cons[c] → let ind = length_total c.tl in {}
###

In our system, the type of vectors can be defined using a restriction on
the type of lists. In other words, vectors of length ##s## will be encoded
as the type containing lists ##l## such that ##length l ≡ s##. The type of
vectors will hence have two parameters. The former will give the type of
the elements contained in the vectors and the latter will be the size
parameter, in the form of a term.
### PML "examples/unat.pml"
type vec<a:ο, s:τ> = ∃l:ι, l∈(list<a> | length l ≡ s)
###
(* TODO a word on the position of parentheses ? *)
We can then define a concatenation function ##app## on vector. The produces a vector which length is the sum of the lengths of its two
arguments. Note that the use the definition of ##app## requires the
use of the ##length_total## lemma in its definition.
### PML "examples/unat.pml"
val rec app : ∀a:ο, ∀m n:ι, vec<a, m> ⇒ vec<a, n> ⇒ vec<a, add m n> =
  fun l1 l2 → case l1 of Nil[_] → l2 | Cons[c] →
    let _ = length_total c.tl in
    let r = app c.tl l2 in
    Cons[{hd = c.hd; tl = r}]
###
We can now define a ternary concatenation function on vectors as follows,
using two calls to ##app##. To be able to define this function, the
totality of the ##add## function is required.
### PML "examples/unat.pml"
val app3 : ∀a:ο, ∀m n p:ι, vec<a,m> ⇒ vec<a,n> ⇒ vec<a,p>
                           ⇒ vec<a, add m (add n p)> =
 fun l1 l2 l3 →
   let lem = add_total (length l2) (length l3) in
   app l1 (app l2 l3)
###

=<
=> Case study: sorting algorithm

(* TODO *)

### "examples/insert.pml"
type order<a:ο> = ∃cmp:ι, {
  cmp : cmp ∈ (a ⇒ a ⇒ bool);
  tmp : ∀x y∈a, ∃v:ι, v ≡ cmp x y;
  tra : ∀x y z∈a, (cmp x y ≡ tru ⇒ cmp y z ≡ tru ⇒ cmp x y ≡ tru);
  tot : ∀x y∈a, or (cmp x y) (cmp y x) ≡ tru
}

type rec list<a:ο> = μx [ Nil of {}; Cns of { hd : a; tl : list } ]

val nil : ∀a:ο, list<a> = Nil[]

def tl : ι = fun l → case l of | Cns[c] → c.tl
def hd : ι = fun l → case l of | Cns[c] → c.hd

val cns : ∀a:ο, a ⇒ list<a> ⇒ list<a> = fun e l → Cns[{ hd = e; tl = l }]

val sorted : ∀a:ο, ∀o∈order<a>, ∀l∈list<a>, bool = fix fun sorted o l →
  case l of
  | Nil[] → tru
  | Cns[c1] →
    let hd = c1.hd in let tl = c1.tl in
    (case tl of
    | Nil[] → tru
    | Cns[c2] →
       let hd2 = c2.hd in
       land<(o.cmp) hd hd2, sorted o tl>)

val sorted_total : ∀a:ο, ∀o∈order<a>, ∀l∈list<a>, ∃v:ι, v ≡ sorted o l =
  fix fun sorted_total o l →
  case l of
  | Nil[] → {}
  | Cns[c1] →
    let hd = c1.hd in let tl = c1.tl in
    (case tl of
    | Nil[] → {}
    | Cns[c2] →
       let hd2 = c2.hd in
       let tl2 = c2.tl in
       let ind : (∃v:ι, v ≡ sorted o tl) = sorted_total o tl in
       let lem = o.tmp hd hd2 in
       (case o.cmp hd hd2 of
       | Tru[] →
          let lem : o.cmp hd hd2 ≡ tru = {} in
          let lem : sorted o l ≡ sorted o tl = {} in
          {}
       | Fls[] →
          let lem : o.cmp hd hd2 ≡ fls = {} in
          let lem : sorted o l ≡ fls = {} in {}))


val rec insert : ∀a:ο, order<a> ⇒ a ⇒ list<a> ⇒ list<a> = fun o x l →
   case l of
   | Nil[] → cns x nil
   | Cns[c1] →
     let hd = c1.hd in let tl = c1.tl in
     (case o.cmp x hd of
     | Tru[] → cns x l
     | Fls[] → cns hd (insert o x tl))

val rec insert_total :  ∀a:ο, ∀o∈order<a>, ∀x∈a, ∀l∈list<a>, ∃v:ι, insert o x l ≡ v = fun o x l →
   case l of
   | Nil[] → {}
   | Cns[c1] →
     let hd = c1.hd in let tl = c1.tl in
     let lem = o.tmp x hd in
     (case o.cmp x hd of
     | Tru[] → {}
     | Fls[] →
        let lem = insert_total o x tl in
        {})

val rec isort : ∀a:ο, order<a> ⇒ list<a> ⇒ list<a> = fun o l →
   case l of
   | Nil[] → nil
   | Cns[c1] →
     let hd = c1.hd in let tl = c1.tl in
     insert o hd (isort o tl)

val rec isort_total :  ∀a:ο, ∀o∈order<a>, ∀l∈list<a>, ∃v:ι, isort o l ≡ v = fun o l →
   case l of
   | Nil[] → {}
   | Cns[c1] →
     let hd = c1.hd in let tl = c1.tl in
     let lem = isort_total o tl in
     let lem = insert_total o hd (isort o tl) in
     {}

type slist<a:ο,ord:τ> = ∃l:ι, l∈(list<a> | sorted ord l ≡ tru)

val rec tail_sorted :  ∀a:ο, ∀o∈order<a>, ∀x∈a, ∀l∈list<a>, sorted o (cns x l) ≡ tru ⇒ sorted o l ≡ tru = fun o x l hyp →
  case l of Nil[] → {}
          | Cns[c1] →
            let hd = c1.hd in
            let lem : (∃v:ι, o.cmp x hd ≡ v) = o.tmp x hd in
            let lem : (∃v:ι, sorted o l ≡ v) = sorted_total o l in
            (case o.cmp x hd of Tru[] →  {} | Fls[] → ✂)


val rec insert_sorted : ∀a:ο, ∀o∈order<a>, ∀x∈a, ∀l∈slist<a,o>, sorted o (insert o x l) ≡ tru = Λa:ο.fun o x l →
   let cmp = o.cmp in
   case l of
   | Nil[] → {}
   | Cns[c1] →
     let hd = c1.hd in let tl = c1.tl in
     let lem = insert_total o x tl in
     let lem = o.tmp x hd in
     (case cmp x hd of
     | Tru[] →
         let lem : sorted o tl ≡ tru = tail_sorted o hd tl ({}:sorted o (cns hd tl) ≡ tru)  in
         {}
     | Fls[] →
         let lem : (∃v:ι, v ≡ cmp x hd) = o.tmp x hd in
         let lem : (∃v:ι, v ≡ cmp hd x) = o.tmp hd x in
         let lem : cmp hd x ≡ tru = o.tot x hd in
         (case tl of
             | Nil[] → {}
             | Cns[c2] →
                let hd2 = c2.hd in let tl2 = c2.tl in
                let lem = insert_total o x tl2 in
                let lem : (∃v:ι, v ≡ cmp hd hd2) = o.tmp hd hd2 in
                let lem : (∃v:ι, v ≡ cmp x hd2) = o.tmp x hd2 in
                (case cmp hd hd2 of Fls[] → ✂ | Tru[] →
                  let lem : sorted o (insert o x tl) ≡ tru = insert_sorted o x (tl:slist<a,o>) in
                  (case cmp x hd2 of
                  | Fls[] →
                     let lem : (∃v:ι, v ≡ cmp hd2 x) = o.tmp hd2 x in
                     let lem : (cmp hd2 x) ≡ tru = o.tot x hd2 in
                     {}
                  | Tru[] → {}
                  ))))

val rec isort_sorted : ∀a:ο, ∀o∈order<a>, ∀l∈list<a>, sorted o (isort o l) ≡ tru = Λa:ο.fun o l →
   let cmp = o.cmp in
   case l of
   | Nil[] → {}
   | Cns[c1] →
      let hd = c1.hd in let tl = c1.tl in
      let lem = isort_total o tl in
      let lem = sorted_total o (isort o tl) in
      let ind : sorted o (isort o tl) ≡ true = isort_sorted o tl in
      let lem : (∃v:ι, insert o hd (isort o tl) ≡ v) = insert_total o hd (isort o tl) in
      let tls : slist<a,o> = isort o tl in
      let lem : sorted o (insert o hd (isort o tl)) ≡ tru = insert_sorted o hd tls in
      {}
###

=<
=> Lookup function with an exception

(* TODO *)
### PML "examples/exceptions.pml"
include lib.list
include test.mu

val rec exists : ∀a:ο, (a ⇒ bool) ⇒ list<a> ⇒ bool =
  fun f l →
    case l of
    | Nil[_]  → false
    | Cons[c] → if f c.hd then true else exists f c.tl

def total<f:ι, a:ο> : ο = ∀x∈a, ∃y:ι, f x ≡ y

val rec exists_total : ∀a:ο, ∀f∈(a ⇒ bool), total<f,a> ⇒ ∀l∈list<a>,
                         ∃v:ι, exists f l ≡ v =
  fun f ftot l →
    case l of
    | Nil[_]  → {}
    | Cons[c] →
        let lem : (∃y:ι, f c.hd ≡ y) = ftot c.hd in
        if f c.hd then {} else (let lem = exists_total f ftot c.tl in {})


val rec find : ∀a:ο, ∀f∈(a ⇒ bool), total<f,a> ⇒ ∀l∈list<a>, neg<(exists f l ≡ false)> ⇒ a =
  fun f ftot l exc →
    case l of
    | Nil[_]  → exc {}
    | Cons[c] → let hd = c.hd in let tl = c.tl in
                let lem : (∃v:ι, f hd ≡ v) = ftot hd in
//                 let exc : neg<exists f tl ≡ false> = exc in //useless !!!
                if f hd then hd else find f ftot tl exc

val find_opt : ∀a:ο, ∀f∈(a ⇒ bool), total<f,a> ⇒ list<a> ⇒ option<a> =
  fun f ftot l → save a → Some[find f ftot l (fun _ → restore a none)]

val notNone : ∀a:ο, option<a> ⇒ bool = fun o →
  case o of None[] → fls | Some[_] → tru

val rec find2 : ∀a:ο, ∀f∈(a ⇒ bool), total<f,a> ⇒ list<list<a>> ⇒ option<a> =
  fun f ftot ls →
    case ls of Nil[_]  → none
             | Cons[c] → let l = c.hd in let tl = c.tl in
                         save a → Some[find f ftot l (fun _ → restore a (find2 f ftot tl))]


//val find_opt2 : ∀a:ο, ∀f∈(a ⇒ bool), total<f,a> ⇒ ∀l∈list<a>, ∃o:ι, option<a> |
//      imp (exists f l) (notNone o) ≡ tru  =
//  fun f ftot l → save a → Some[find f ftot l (fun _ → restore a none)]
###

=<
=<
