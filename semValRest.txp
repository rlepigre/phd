\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vset = <$ Λ_ι^{∗} $>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>
)
\Include{Macros}

\Configure_math_macro{\v}{ syntax = string; }
\Configure_math_macro{\t}{ syntax = string; }
\Configure_math_macro{\s}{ syntax = string; }
\Configure_math_macro{\p}{ syntax = string; }
\Configure_math_macro{\f}{ syntax = string; }
\Configure_math_macro{\subs}{ syntax = string; }
\Configure_math_macro{\vs}{ syntax = string; }
\Configure_math_macro{\ss}{ syntax = string; }
\Configure_math_macro{\ts}{ syntax = string; }

\Caml(
let r_ax =
  <$\axiomRN{Ax_τ}{Σ, x:ι \sp Γ, x:A; Ξ ⊢ \t{x} : A}$>

let r_arrow_i =
  <$\unaryRN{⇒_{i,τ}}{Σ, x:ι \sp Γ,x:A;Ξ ⊢ \t{t} : B}
   {Σ \sp Γ;Ξ ⊢ \v{λx t} : A ⇒ B}$>

let r_arrow_e =
  <$\binaryRN{⇒_e}{Σ \sp Γ;Ξ ⊢ \t{t} : A ⇒ B}{Σ \sp Γ;Ξ ⊢ \t{u} : A}
   {Σ \sp Γ;Ξ ⊢ \t{t u} : B}$>

let r_mu =
  <$\unaryRN{μ}{Σ, α:σ \sp Γ,α:A^⊥;Ξ ⊢ \t{t} : A}
   {Σ \sp Γ;Ξ ⊢ \t{μα t} : A}$>

let r_name =
  <$\binaryRN{[\wc]}{Σ \sp Γ;Ξ ⊢ \t{t} : A}
   {Σ \sp Γ;Ξ ⊢ \s{π} : A^⊥}
   {Σ \sp Γ;Ξ ⊢ \t{[π]t} : B}$>

let r_ax' =
  <$\axiomRN{Ax^⊥}{Σ, α:σ \sp Γ, α:A^⊥; Ξ ⊢ \s{α} : A^⊥}$>

let r_push =
  <$\binaryRN{\wc·\wc_τ}{Σ \sp Γ;Ξ ⊢ \v{v} : A}
   {Σ \sp Γ;Ξ ⊢ \s{π} : \f{B}^⊥}
   {Σ \sp Γ;Ξ ⊢ \s{v·π} : \f{A⇒B}^⊥}$>

let r_fram =
  <$\binaryRN{[\wc]\wc}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{A⇒B}}
   {Σ \sp Γ;Ξ ⊢ \s{π} : \f{B}^⊥}
   {Σ \sp Γ;Ξ ⊢ \s{[t]π} : \f{A}^⊥}$>

let r_forall_i =
  <$\binaryRN{∀_{i,τ}}{Σ, χ:s \sp Γ;Ξ ⊢ \t{t} : A}{Ξ⊢t≡v}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{∀χ^s A}}$>

let r_forall_e =
  <$\binaryRN{∀_e}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{∀χ^s A}}{Σ ⊢ B : s}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{A[χ ≔ B]}}$>

let r_exists_i =
  <$\binaryRN{∃_i}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{A[χ≔B]}}{Σ ⊢ B : s}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{∃χ^s A}}$>

let r_exists_e =
  <$\unaryRN{∃_e}{Σ, x:ι, χ:s \sp Γ,x:\f{A};Ξ ⊢ \t{t} : \f{C}}
   {Σ, x:ι \sp Γ,x:\f{∃χ^s A};Ξ ⊢ \t{t} : \f{C}}$>

let r_memb_i =
  <$\binaryRN{∈_{i,τ}}{Σ \sp Γ;Ξ ⊢ \t{t} : A}{Ξ⊢t≡v}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{t∈A}}$>

let r_memb_e =
  <$\unaryRN{∈_e}{Σ, x:ι \sp Γ,x:A;Ξ,x≡t ⊢ \t{u} : C}
   {Σ, x:ι \sp Γ,x:\f{t∈A};Ξ ⊢ \t{u} : C}$>

let r_rest_i =
  <$\binaryRN{↾_i}{Σ \sp Γ;Ξ ⊢ \t{t} : A}{Ξ ⊢ \t{u₁} ≡ \t{u₂}}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{A ∧ u₁≡u₂}}$>

let r_rest_e =
  <$\unaryRN{↾_e}{Σ, x:ι \sp Γ,x:A;Ξ,\t{u₁}≡\t{u₂} ⊢ \t{t} : C}
   {Σ, x:ι \sp Γ,x:\f{A ∧ u₁≡u₂};Ξ ⊢ \t{t} : C}$>

let r_prod_i =
  <$\unaryRN{×_{i,τ}}{[Σ \sp Γ;Ξ ⊢ \v{vi} : \f{Ai}]_{i∈I}}
   {Σ \sp Γ;Ξ ⊢ \v{{(li = vi) i∈I}} : \f{{(li : Ai) i∈I}}}$>

let r_prod_e =
  <$\binaryRN{×_{e,τ}}{Σ \sp Γ;Ξ ⊢ \v{v} : \f{{(li : Ai) i∈I}}}
   {k∈I}{Σ \sp Γ;Ξ ⊢ \t{v.lk} : A_k}$>

let r_sum_i =
  <$\binaryRN{+_{i,τ}}{Σ \sp Γ;Ξ ⊢ \v{v} : \f{Ak}}{k∈I}
   {Σ \sp Γ;Ξ ⊢ \v{Ck[v]} : \f{[(Ci : Ai) i∈I]}}$>

let r_sum_e =
  <$\binaryRN{+_{e,τ}}{Σ \sp Γ;Ξ ⊢ \v{v} : \f{[(Ci : Ai) i∈I]}}
   {[Σ, x_i:ι \sp Γ,x_i:A_i;Ξ,v≡\t{Ci[xi]} ⊢ t_i : B]_{i∈I}}
   {Σ \sp Γ;Ξ ⊢ \t{[v | (Ci[xi] → ti) i∈I]} : B}$>

let r_eq_i =
  <$\binaryRN{≡_{τ,ι}}{Σ \sp Γ[x≔w₁];Ξ ⊢ \t{t[x≔w₁]} : \f{A[x≔w₁]}}
   {Ξ ⊢ \v{w₁} ≡ \v{w₂}}
   {Σ \sp Γ[x≔w₂];Ξ ⊢ \t{t[x≔w₂]} : \f{A[x≔w₂]}}$>

let r_eq_t =
  <$\binaryRN{≡_{τ,τ}}{Σ \sp Γ[a≔u₁];Ξ ⊢ \t{t[a≔u₁]} : \f{A[a≔u₁]}}
   {Ξ ⊢ \t{u₁} ≡ \t{u₂}}
   {Σ \sp Γ[a≔u₂];Ξ ⊢ \t{t[a≔u₂]} : \f{A[a≔u₂]}}$>

let rs env =
  let env = resize_env 3.4 env in
  let rs =
    [ [r_ax;r_arrow_e] ; [r_ax';r_arrow_i] ; [r_mu; r_name] ; [r_push; r_fram]
    ; [r_forall_i;r_exists_e] ; [r_forall_e;r_exists_i] ; [r_memb_e;r_rest_i]
    ; [r_memb_i;r_rest_e] ; [r_prod_e;r_sum_i] ; [r_prod_i] ; [r_sum_e]
    ; [r_eq_i] ; [r_eq_t] ]
  in
  let rs = List.map (List.map (fun cs -> <<$\id(cs)$>>)) rs in
  List.map (List.map (fun cs ->
    draw_boxes env (boxify_scoped env cs))) rs

let derived_rules () =
  figure_here ~name:"derivedrules"
              ~caption:[tT "Derived typing rules."] (dr rs)
)

=> A model for a semantical value restriction \label("semValRest")

\begin{center}
\linesBefore(10)
\end{center}
(* *)
In this chapter, we consider the encoding of dependent types (i.e., a form
of typed quantification) into our system. However, the expressiveness of
such constructs is considerably limited by the value restriction. To solve
this issue we introduce the notion of //semantical value restriction//,
which allows the system to accept many more programs. Obtaining a model
justifying //semantical value restriction// will require us to change our
notions of reduction and observational equivalence.

=> Dependent function types

It is possible to encode dependent types into our system to obtain a
form of quantification over the values (or terms) of a given type.
This encoding relies on the well-known relativised quantification
scheme, and it was suggested by Alexandre Miquel.
\begin{def}
Let $A$, $B ∈ \cal{F}$ be two types, $x ∈ \cal{V}_ι$ be a $λ$-variable and
$a ∈ \cal{V}_τ$ be a term variable. We will use the following notations
for representing dependent function types ranging over values and terms
respectively.
$$
  \f{Π_(x∈A) B} ≔ \f{∀x(x∈A ⇒ B)}
  \hspace(6.0)
  \f{Π_(a∈A) B} ≔ \f{∀a(a∈A ⇒ B)}
$$
\end{def}
Of course, we do not need to give additional sorting rules since
$\f{Π_(x∈A) B}$ and $\f{Π_(a∈A) B}$ are only syntactic sugars.
However, we can use consider the following typing rules to work
with dependent functions more easily.
\begin{center}
$
\unaryRN{Π_{ι,i}}{Σ, x : ι \sp Γ, x:A ; Ξ ⊢ t : B[y≔x]}
  {Σ \sp Γ ; Ξ ⊢_\tval \v{λx t} : \f{Π_(y∈A) B}}
$
\end{center}
\linesAfter(2) (* FIXME hack *)

\begin{center}
$
\unaryRN{Π_{τ,i}}{Σ, x : ι \sp Γ, x:A ; Ξ ⊢ t : B[a≔x]}
  {Σ \sp Γ ; Ξ ⊢_\tval \v{λx t} : \f{Π_(a∈A) B}}
$
\end{center}

\linesBefore(2) (* FIXME hack *)
\begin{center}
$
\binaryRN{Π_{ι,e}}{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(x∈A) B}}
  {Σ \sp Γ ; Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t{t v} : \f{B[x≔v]}}
$
\end{center}

\linesBefore(2) (* FIXME hack *)
\begin{center}
$
\binaryRN{Π_{τ,e}}{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(a∈A) B}}
  {Σ \sp Γ ; Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t{t v} : \f{B[a≔v]}}
$
\end{center}
Note that both elimination rules require the value restriction on
their second premise. In other words, dependent functions can only
be applied to values. The four new typing rules can immediately be
used to extend the type system as they are derivable. Hence, we
do not have to extend our adequacy lemma (\thmRef("adequacy") or
\thmRef("stack_adequacy")).
\begin{lem}
The typing rules for the dependent function types are derivable.
\begin{proof}
The derivations for each of the new rules is given below.
$$
\proofTree{
  \unaryN{Def}{Σ \sp Γ; Ξ ⊢_\tval \v{λx t} : \f{Π_(y∈A) B}}{
  \unaryN{∀_i}{Σ \sp Γ; Ξ ⊢_\tval \v{λx t} : \f{∀y (y∈A ⇒ B)}}{
  \unaryN{⇒_i}{Σ, y:ι \sp Γ; Ξ ⊢_\tval \v{λx t} : \f{y∈A ⇒ B}}{
  \unaryN{∈_e}{Σ, y:ι, x:ι \sp Γ, x : \f{y∈A}; Ξ ⊢ t : B}{
  \unaryN{≡_{τ,ι}}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ, x≡y ⊢ t : B}{
  \unaryN{Wk}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ, x≡y ⊢ t : \f{B[y≔x]}}{
  \unaryN{Wk}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ ⊢ t : \f{B[y≔x]}}{
    \hyp{Σ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f{B[y≔x]}}
  }}}}}}}
}
$$
$$
\proofTree{
  \unaryN{Def}{Σ \sp Γ; Ξ ⊢_\tval \v{λx t} : \f{Π_(a∈A) B}}{
  \unaryN{∀_i}{Σ \sp Γ; Ξ ⊢_\tval \v{λx t} : \f{∀a (a∈A ⇒ B)}}{
  \unaryN{⇒_i}{Σ, a:τ \sp Γ; Ξ ⊢_\tval \v{λx t} : \f{a∈A ⇒ B}}{
  \unaryN{∈_e}{Σ, a:τ, x:ι \sp Γ, x : \f{a∈A}; Ξ ⊢ t : B}{
  \unaryN{≡_{τ,τ}}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ, x≡a ⊢ t : B}{
  \unaryN{Wk}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ, x≡a ⊢ t : \f{B[a≔x]}}{
  \unaryN{Wk}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f{B[a≔x]}}{
    \hyp{Σ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f{B[a≔x]}}
  }}}}}}}
}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t{t v} : \f{B[x≔v]}}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f{v∈A ⇒ B[x≔v]}}{
   \unaryN{Def}{Σ \sp Γ ; Ξ ⊢ t : \f{∀x (x∈A ⇒ B)}}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(x∈A) B}}
   }}
 }{
  \unaryN{↑}{Σ \sp Γ ; Ξ ⊢ v : \f{v∈A}}{
  \unaryN{∈_i}{Σ \sp Γ ; Ξ ⊢_\tval v : \f{v∈A}}{
    \hyp{Σ \sp Γ ; Ξ ⊢_\tval v : A}
  }}
 }
}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t{t v} : \f{B[a≔v]}}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f{v∈A ⇒ B[a≔v]}}{
   \unaryN{Def}{Σ \sp Γ ; Ξ ⊢ t : \f{∀a (a∈A ⇒ B)}}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(a∈A) B}}
   }}
 }{
  \unaryN{↑}{Σ \sp Γ ; Ξ ⊢ v : \f{v∈A}}{
  \unaryN{∈_i}{Σ \sp Γ ; Ξ ⊢_\tval v : \f{v∈A}}{
    \hyp{Σ \sp Γ ; Ξ ⊢_\tval v : A}
  }}
 }
}
$$
\linesAfter(0)
\end{proof}
\end{lem}
\begin{rem}
Note that in the typing rules we consider, the variable bound by the
dependent type (i.e., $x$ or $a$ respectively) does not appear free in
the type $A$. In fact, this restriction is not necessary, and we could
adapt the rules accordingly. However, the considered types would not
correspond to dependent functions anymore.
\end{rem}

Our encoding of the dependent products makes sense with
respect to the semantics. Indeed, their interpretation is similar to
the arrow type as it contains functions, but the type of their body
depends on the value of the input.
\begin{lem}
If $A$, $B ∈ \cal{F}$ are types such that $⊢ A : ο$ and $x : ι ⊢ B : ο$
are derivable then we have the following.
$$
  \vs{Π_(x∈A) B} = \{\v{λx t} \| ∀v∈{\vs{A} ∖ \{\v{□}\}},
                      \t{t[x≔v]} ∈ \ts{B[x≔v]}\} ∪ \{\v{□}\}
$$
Similarly, if $a : τ ⊢ B : ο$ is derivable then we have the following.
$$
  \vs{Π_(a∈A) B} = \{\v{λx t} \| ∀v∈{\vs{A} ∖ \{\v{□}\}},
                      \t{t[x≔v]} ∈ \ts{B[a≔v]}\} ∪ \{\v{□}\}
$$
\begin{proof}
The proof is done using simple equational reasoning starting from the
definition of $\vs{∀x (x∈A ⇒ B)}$ and $\vs{∀a (a∈A ⇒ B)}$ respectively.
\begin{center}
\begin{env}(scale 0.90)
\diagram(
let _ =
  let first e1 e2 = [ e1; <$=$>; e2 ] in
  let line e = [ []; <$=$>; e ] in
  let empty = [[]; []; []] in
  array [`East ; `East ; `West]
  [ empty
  ; first <$\vs{Π_(x∈A) B}$> <$\vs{∀x (x∈A ⇒ B)}$>
  ; line <$\biginter_{Φ∈⟦ι⟧}
      (* FIXME hack *)
      {\vs{Φ∈A ⇒ B[x≔Φ]}^{\mcolor(white){⊥⊥}} \mcolor(white){,}}$>
  ; line <$\biginter_{Φ∈⟦ι⟧} \{\v{λx t} \| ∀v∈{\vs{Φ∈A} ∖ \{\v{□}\}},
      \t{t[x≔v]} ∈ \ts{B[x≔Φ]}\} ∪ \{\v{□}\}$>
  ; line <$\{\v{λx t} \| ∀Φ∈⟦ι⟧, ∀v∈{\{w ∈ \vs{A} \| w ≡ Φ\} ∖ \{\v{□}\}},
      \t{t[x≔v]} ∈ \ts{B[x≔Φ]}\} ∪ \{\v{□}\}$>
  ; line <$\{\v{λx t} \| ∀v∈{\vs{A} ∖ \{\v{□}\}}, \t{t[x≔v]} ∈ \ts{B[x≔v]}\}
      ∪ \{\v{□}\}$>
  ; empty ]
)
\end{env}
\end{center}
The proof for $\vs{∀a (a∈A ⇒ B)}$ is similar but it requires
\lemma("texttyp").
\end{proof}
\end{lem}

=<

=> The limits of the value restriction

In languages like OCaml, the value restriction is not so problematic. Indeed,
it is only required on the typing rule for polymorphism, and programmers
almost never notice it as they mostly define functions (which are values).
Moreover, if an instance of the value restriction is encountered, one can
always use a dummy $λ$-abstraction (or an $η$-expansion) to transform a term
into a value. A common example of this situation arises when working with
combinators (e.g., parser combinators) and partial application. As an
example, let us consider the code below (written in OCaml syntax).
### OCaml
(* type 'a gr                               *)
(* val any : char gr                        *)
(* val seq : 'a gr -> 'b gr -> ('a * 'b) gr *)

let mono = seq any
let poly = fun g -> seq any g
###
Here, ##t gr## represents a parser (or grammar) returning a value of type
##t##. The atomic parser ##any## reads one character on the parsed stream
and returns its value. The combinator ##seq## takes as input two parsers
and puts them in sequence to obtain a new parser. The return value of this
new parser is a couple of the return values of the parsers it is build with.
Now, if ##seq## is partially applied with the parser ##any##, the expected
result is a combinator taking as input a parser ##g##, and returning a
parser for the sequence build with ##any## and ##g##. Of course, we want
this new combinator to be as generic as possible, so that it can be applied
to any parser, with any return type. However, the combinator ##mono##
defined above is only weakly polymorphic. This means that we will only be
able to apply it to parsers of one fixed (but yet unknown) type. Of course,
##seq any## is not a value, and the value restriction applies. To solve
this lack of generality, one need to rely on an $η$-expansion as in
##poly##, which has the expected type ##'a parser -> (char, 'a) parser##.

As the definition of ##seq## is probably something like
##fun p1 p2 -> body##, the value restriction is actually not required in
##mono##. Indeed, the evaluation of ##seq any## would instantly reduce to
a value (without any side-effect) in one $β$-reduction. This means that
##seq any## could actually be considered a value. However, as discussed
in \chapter("intro"), the value restriction is a very simple and elegant
way to ensure the soundness of the type system. For this reason, the
limitations discussed here do not pose a big enough problem to motivate
the design of a more complex criterion in usual ML-like languages.

In our system, however, the value restriction is not only required on
the introduction rule for the universal quantifier, but also on the
introduction rule for
the membership predicate. As it is used to derive the ($Π_{ι,e}$) and
($Π_{τ,e}$) rules, the value restriction is enforced on the argument of
dependent functions. It is indeed necessary as an unrestricted ($∈_i$)
rule breaks the consistency (and the type safety) of our system. To
support this claim, we will consider the system in which ($∈_i$) has
been replaced by the following (unrestricted) typing rule.
\begin{center}
$ \unaryRN{∈_{i,⊥}}{Σ \sp Γ,Ξ ⊢ t : A} {Σ \sp Γ,Ξ ⊢ t : \f{t∈A}}$
\end{center}
In this system, the following (unrestricted) typing rule for the
elimination of the dependent function type can be derived (see the
typing derivation below the rule).
\begin{center}
$
  \binaryRN{Π_{e,⊥}}
    {Σ \sp Γ,Ξ ⊢ t : \f{Π_(a∈A) B}}
    {Σ \sp Γ,Ξ ⊢ u : \f{A}}
    {Σ \sp Γ,Ξ ⊢ \t{t u} : \f{B[a≔u]}}
$
\end{center}
\linesAfter(4) (* FIXME hack *)

\begin{center}
$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t{t u} : \f{B[a≔u]}}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f{u∈A ⇒ B[a≔u]}}{
   \unaryN{Def}{Σ \sp Γ ; Ξ ⊢ t : \f{∀a (a∈A ⇒ B)}}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(a∈A) B}}
   }}
 }{
  \unaryN{∈_{i,⊥}}{Σ \sp Γ ; Ξ ⊢ u : \f{u∈A}}{
    \hyp{Σ \sp Γ ; Ξ ⊢ u : A}
  }
 }
}
$
\end{center}

For convenience, we will also introduce a strong application rule that
can also be derived directly using ($∈_{i,⊥}$). This typing rule will be
used to keep track of the argument used for a function, while typing the
function itself.
\begin{center}
$
  \binaryRN{⇒_{e,{∈},⊥}}
    {Σ \sp Γ;Σ ⊢ t : \f{u∈A⇒B}}
    {Σ \sp Γ;Σ ⊢ u : A}
    {Σ \sp Γ;Σ ⊢ \t{t u} : B}
$
\end{center}

\linesBefore(3) (* FIXME hack *)
\begin{center}
$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t{t u} : \f{B}}{
   \hyp{Σ \sp Γ ; Ξ ⊢ t : \f{u∈A ⇒ B}}
 }{
  \unaryN{∈_{i,⊥}}{Σ \sp Γ ; Ξ ⊢ u : \f{u∈A}}{
    \hyp{Σ \sp Γ ; Ξ ⊢ u : A}
  }
 }
}
$
\end{center}

We will now build a counter-example to the consistency of the system
extended with the ($∈_{i,⊥}$) rule for the membership predicate. We
will construct a typable term that reduces to a value that does not
belong to the expected type. We consider the term $\t{t u}$ defined
thanks to the following subterms.
\begin{center}
\diagram(
let _ =
  let line s1 s2 = [ <$\t(s1)$> ; <$=$>; <$\t(s2)$> ] in
  let empty = [ [] ; [] ; [] ] in
  array [`East ; `East ; `West]
  [ empty
  ; line "t" "λf(λ_v (f F[{}])) (f T[{}])"
  ; line "v" "λy [y | F[_] → C₁[{}] | T[_] → C₀[{}]]"
  ; line "u" "μα λx [x | F[_] → T[{}] | T[_] → [α]λ_ F[{}]]"
  ; empty ]
)
\end{center}
In many reduction steps, we have $\p{t u∗ε} ≻^{∗} \p{C₁[{}]∗ε}$. To
obtain our counter-example, we will show that $\t{t u}$ has type
$\f{[C₀:{} | C₁:{} ∧ u F[{}] ≡ F[{}]]}$. For every stack $π∈Π$ we
have the following reduction sequence.
\begin{center}
\linesBefore(6)
\diagram(
let _ =
  let full s1 s2 = [ <$\p(s1)$> ; <$≻$> ; <$\p(s2)$> ] in
  let line s = [ [] ; <$≻$> ; <$\p(s)$> ] in
  let empty = [ [] ; [] ; [] ] in
  array [`East ; `East ; `West]
  [ empty
  ; full "u F[{}] ∗ π"
         "F[{}] ∗ [u] π"
  ; line "u ∗ F[{}]·π"
  ; line "λx [x | F[_] → T[{}] | T[_] → [F[{}]·π]λ_ F[{}]] ∗ F[{}]·π"
  ; line "[F[{}] | F[_] → T[{}] | T[_] → [F[{}]·π]λ_ F[{}]] ∗ π"
  ; line "T[{}] ∗ π"
  ; empty ]
)
\end{center}
As a consequence, \lemRef("redtosame") tells us that $\t{u F[{}]} ≡
\t{T[{}]}$. As a consequence, it cannot be that $\t{u F[{}]} ≡ \t{F[{}]}$
and thus the type $\f{[C₀:{} | C₁:{} ∧ u F[{}] ≡ F[{}]]}$ is equivalent
to $\f{[C₀ : {}]}$ (i.e., they have the same semantical interpretation).
This means that if we manage to show that $\t{t u}$ has type
$\f{[C₀:{} | C₁:{} ∧ u F[{}] ≡ F[{}]]}$, then we will have a
contradiction to the type safety as $\t{t u}$ reduces to $\v{C₁[{}]}$,
which is not contained in $\vs{[C₀ : {}]}$.

In the typing derivation displayed below, the type $\f{B}$ is
defined as $\f{[T:{}|F:{}]}$, the type $\f{C}$ is defined as
$\f{[C₀:{} | C₁:{} ∧ f F[{}] ≡ F[{}]]}$, the context $Γ₁$ is
defined as $f : \f{B⇒B}$, the context $Γ₂$ is defined as
$f:\f{B⇒B}, y:\f{B}, y≡\t{f F[{}]}$ and $Γ₃$ is defined as
$α:\f{B⇒B}^⊥,x:B$. Note that the proof is split into three pieces
so that it may fit in one page. The first two pieces, labeled $p₁$
and $p₂$ respectively, should be plugged in the main part of the
proof (i.e., the third piece) at corresponding premises.
\begin{env}(scale 0.84)
\begin{proofTree}
\Caml(
let p =
  ax     ~name:<$Ax$>
    <$ Γ₂ ⊢_\tval y : \f{B} $>;

  ax      ~name:<$×_i$> <$ Γ₂, y≡\t{F[{}]} ⊢_\tval \t{{}} : \f{{}}$>;
  hyp <$y≡\t{f F[{}]}, y≡\t{F[{}]} ⊢ \t{f F[{}]} ≡ \t{F[{}]}$>;
  binary ~name:<$\restriction_e$>
    <$ Γ₂, y ≡ \t{F[{}]} ⊢_\tval \t{{}} : \f{{} ∧ f F[{}] ≡ F[{}]} $>;
  unary  ~name:<$+_e$> <$ Γ₂, y ≡ \t{F[{}]} ⊢_\tval \t{C₁[{}]} : \f{C} $>;
  unary  ~name:<$↑$> <$ Γ₂, y ≡ \t{F[{}]} ⊢ \t{C₁[{}]} : \f{C} $>;

  ax      ~name:<$×_i$> <$ Γ₂, y≡\t{T[{}]} ⊢_\tval \t{{}} : \f{{}}$>;
  unary  ~name:<$+_e$> <$ Γ₂, y ≡ \t{T[{}]} ⊢_\tval \t{C₀[{}]} : \f{C} $>;
  unary  ~name:<$↑$> <$ Γ₂, y ≡ \t{T[{}]} ⊢ \t{C₀[{}]} : \f{C} $>;

  ternary  ~name:<$+_e$>
    <$ f:\f{B⇒B}, y:\f{B}, y ≡ \t{f F[{}]}
       ⊢ \t{[y | F[_] → C₁[{}] | T[_] → C₀[{}]]}
       : \f{C} $>;
  unary  ~name:<$∈_e$>
    <$ f:\f{B⇒B}, y:\f{(f F[{}])∈B}
       ⊢ \t{[y | F[_] → C₁[{}] | T[_] → C₀[{}]]}
       : \f{C} $>;
  unary  ~name:<$⇒_ι$>
    <$ f:\f{B⇒B} ⊢_\tval \t{λy [y | F[_] → C₁[{}] | T[_] → C₀[{}]]}
       : \f{(f F[{}])∈B ⇒ C} $>;
  unary   ~name:<$p₁$> (mcolor white <$...$>);
  display_proof ()
)
$$ \id(p) $$
\end{proofTree}
\begin{proofTree}
\Caml(
let p =
  ax      ~name:<$Ax$>  <$ Γ₃ ⊢_\tval x:B $>;
  ax      ~name:<$×_i$> <$ Γ₃ ⊢_\tval \v{{}} : \f{{}} $>;
  unary   ~name:<$+_i$> <$ Γ₃ ⊢_\tval \v{T[{}]} : \f{B} $>;
  unary   ~name:<$↑$> <$ Γ₃ ⊢ \v{T[{}]} : \f{B} $>;
  ax      ~name:<$×_i$> <$ Γ₃ ⊢_\tval \v{{}} : \f{{}} $>;
  unary   ~name:<$+_i$> <$ Γ₃ ⊢_\tval \v{F[{}]} : \f{B} $>;
  unary   ~name:<$↑$> <$ Γ₃ ⊢ \v{F[{}]} : \f{B} $>;
  unary   ~name:<$⇒_i$> <$ Γ₃ ⊢_\tval \v{λ_F[{}]} : \f{B⇒B} $>;
  unary   ~name:<$↑$> <$ Γ₃ ⊢ \v{λ_F[{}]} : \f{B⇒B} $>;
  unary   ~name:<$[\wc]$> <$ Γ₃ ⊢ \t{[α]λ_F[{}]}:\f{B} $>;
  ternary ~name:<$+_e$>
    <$ α:\f{B⇒B}^⊥,x:B ⊢
       \t{[x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]} : B $>;
  unary   ~name:<$⇒_i$>
    <$ α:\f{B⇒B}^⊥ ⊢_\tval
       \t{λx [x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]} : \f{B⇒B} $>;
  unary   ~name:<$↑$>
    <$ α:\f{B⇒B}^⊥ ⊢
       \t{λx [x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]} : \f{B⇒B} $>;
  unary   ~name:<$μ$>
    <$ ⊢ \t{μα λx [x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]} : \f{B⇒B} $>;
  unary   ~name:<$p₂$> (mcolor white <$...$>);
  display_proof ()
)
$$ \id(p) $$
\end{proofTree}
\begin{proofTree}
\Caml(
let p =
  let leaf = ax in
  leaf   ~name:<$p₁$> <$ Γ₁ ⊢_\tval \t{v} : \f{(f F[{}])∈B ⇒ C} $>;
  unary  ~name:<$↑$> <$ Γ₁ ⊢ \t{v} : \f{(f F[{}])∈B ⇒ C} $>;


  ax      ~name:<$Ax$>  <$ Γ₁ ⊢_\tval \t{f} : \f{B⇒B}$>;
  unary   ~name:<$↑$>   <$ Γ₁ ⊢ \t{f} : \f{B⇒B}$>;

  ax      ~name:<$×_i$>  <$ Γ₁ ⊢_\tval \t{{}} : \f{{}}$>;
  unary   ~name:<$+_i$>  <$ Γ₁ ⊢_\tval \t{F[{}]} : \f{B}$>;
  unary   ~name:<$↑$>    <$ Γ₁ ⊢ \t{F[{}]} : \f{B}$>;

  binary  ~name:<$⇒_e$>
    <$ Γ₁ ⊢ \t{f F[{}]} : \f{B} $>;


  binary ~name:<$⇒_{e,{∈},⊥}$> <$ Γ₁ ⊢ \t{v (f F[{}])} : \f{C} $>;
  unary  ~name:<$⇒_i$> <$ Γ₁ ⊢_\tval \t{λ_ v (f F[{}])} : \f{B ⇒ C} $>;
  unary  ~name:<$↑$> <$ Γ₁ ⊢ \t{λ_ v (f F[{}])} : \f{B ⇒ C} $>;


  ax      ~name:<$Ax$>  <$ Γ₁ ⊢_\tval \t{f} : \f{B⇒B}$>;
  unary   ~name:<$↑$>   <$ Γ₁ ⊢ \t{f} : \f{B⇒B}$>;

  ax      ~name:<$×_i$>  <$ Γ₁ ⊢_\tval \t{{}} : \f{{}}$>;
  unary   ~name:<$+_i$>  <$ Γ₁ ⊢_\tval \t{T[{}]} : \f{B}$>;
  unary   ~name:<$↑$>    <$ Γ₁ ⊢ \t{T[{}]} : \f{B}$>;

  binary  ~name:<$⇒_e$>
    <$ Γ₁ ⊢ \t{f T[{}]} : \f{B} $>;


  binary ~name:<$⇒_e$>
    <$ f:\f{B⇒B} ⊢ \t{(λ_ v (f F[{}])) (f T[{}])}
       : \f{[C₀:{} | C₁:{} ∧ f F[{}] ≡ F[{}]]} $>;
  unary  ~name:<$Π_{τ,i}$>
    <$ ⊢_\tval \t{λf (λ_ v (f F[{}])) (f T[{}])}
       : \f{Π_(a∈B⇒B) [C₀:{} | C₁:{} ∧ a F[{}] ≡ F[{}]]} $>;
  unary  ~name:<$↑$>
    <$ ⊢ \t{λf (λ_ v (f F[{}])) (f T[{}])}
       : \f{Π_(a∈B⇒B) [C₀:{} | C₁:{} ∧ a F[{}] ≡ F[{}]]} $>;

  leaf    ~name:<$p₂$>
    <$ ⊢ \t{u} : \f{B⇒B} $>;

  binary ~name:<$Π_{e,⊥}$>
    <$ ⊢ \t{(λf (λ_ v (f F[{}])) (f T[{}])) u}
       : \f{[C₀:{} | C₁:{} ∧ u F[{}] ≡ F[{}]]} $>;
  display_proof ()
)
$$ \id(p) $$
\end{proofTree}
\end{env}

As we have shown that the unrestricted introduction rule for the membership
type is unsound, there is no hope of encoding an unrestricted elimination
rule for the dependent function type into our system. Indeed, only the
membership types are able to link the world of terms and the world of types
thanks to their semantics. The limitation imposed by the value restriction
on dependent functions leads to an expressiveness problem. Indeed, it
completely forbids the composition of dependent functions which is very
common in practice (especially for building proofs). In \chapter("implem")
we will consider several examples including proofs on the natural numbers
and the concatenation of vectors (i.e., lists of fixed length) which could
not be accepted under the usual syntactic restriction. For such examples
to work in our system, we need another criterion accepting more programs,
while still preserving soundness.

=<

=> Semantical value restriction

As discussed in the previous section, value restriction is an issue in
the presence of the membership type (and thus the dependent function
type). To solve the related expressiveness problem, the author introduced
the notion of //semantical value restriction// \cite("Lepigre2016"). The
main idea is to relax the restriction to allow terms "behaving like values",
and not syntactic values only. Thanks to our notion of observational
equivalence, this property can be expressed easily in the syntax. Indeed,
we will substitute a typing rule like
\begin{center}
$ \binaryRN{Π_{τ,e}}{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(a∈A) B}}
    {Σ \sp Γ;Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t{t v} : \f{B[a≔v]}} $
\end{center}
with the following rule, where the restriction to values on the second
premise is replaced by a third premise involving equivalence.
\begin{center}
$ \ternaryR{Σ \sp Γ ; Ξ ⊢ t : \f{Π_(a∈A) B}}{Σ \sp Γ ; Ξ ⊢ u : A}
      {Ξ ⊢ u ≡ v}{Σ \sp Γ ; Ξ ⊢ \t{t u} : \f{B[a≔u]}} $
\end{center}
This third premise requires the term $u$ to be equivalent to some value
$v$. Of course, it is perfectly possible for $u$ not to be a syntactic
value itself.

\begin{rem}
Semantical value restriction is a strict relaxation of value restriction.
Indeed, value restriction exactly corresponds to a version of semantical
value restriction in which we would only be able to use reflexivity to
show that two terms are equivalent.
\end{rem}

In the syntax, semantical value restriction will be presented as a simple
extension of our type system with the following, seemingly obvious, typing
rule.
\begin{center}
$ \unaryRN{↓}{Σ \sp Γ ; Ξ ⊢ v : A}{Σ \sp Γ ; Ξ ⊢_\tval v : A} $
\end{center}
It should not be confused with our (${↑}$) rule, which premise is a value
judgment and which conclusion is a term judgment. Our new (${↓}$) rule
allows us to transform a term judgment into a value judgment, provided
that the considered term is a value. The (${≡}_{τ,τ}$) rule can then be
used to obtain a proof of $Σ \sp Γ ; Ξ ⊢ v : A$ from a proof of
$Σ \sp Γ ; Ξ ⊢ t : A$, provided that $Ξ ⊢ t ≡ v$ can be proved. This
technique can be used, for example, to derive a relaxed version of the
membership introduction typing rule.
\begin{lem}\label("derivmem")
The following typing rule is derivable in our system extended with (${↓}$).
\begin{center}
$ \binaryRN{∈_{i,τ}}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{A}}
    {Ξ ⊢ \t{t} ≡ \t{v}}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{t∈A}} $
\end{center}
\begin{proof}
We can use the following derivation.
\begin{proofTree}
\Caml(
let p =
  hyp                       <$ Σ \sp Γ ; Ξ ⊢ \t{t} : \f{A} $>;
  hyp                       <$ Ξ ⊢ \t{t} ≡ \t{v} $>;
  binary  ~name:<$≡_{τ,τ}$> <$ Σ \sp Γ ; Ξ ⊢ \t{v} : \f{A} $>;
  unary   ~name:<$↓$>       <$ Σ \sp Γ ; Ξ ⊢_\tval \t{v} : \f{A} $>;
  unary   ~name:<$∈_i$>     <$ Σ \sp Γ ; Ξ ⊢_\tval \t{v} : \f{v∈A} $>;
  unary   ~name:<$↑$>       <$ Σ \sp Γ ; Ξ ⊢ \t{v} : \f{v∈A} $>;
  hyp                       <$ Ξ ⊢ \t{t} ≡ \t{v} $>;
  binary  ~name:<$≡_{τ,τ}$> <$ Σ \sp Γ ; Ξ ⊢ \t{t} : \f{t∈A} $>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
\linesAfter(0) (* FIXME hack *)
\end{proof}
\end{lem}
We can then derive a relaxed version of the elimination rule for the
dependent function type. Again, it requires proving that a term is
equivalence to some value.
\begin{lem}
The following typing rule is derivable in our system extended with (${↓}$).
\begin{center}
$ \ternaryRN{Π_{e,τ}}{Σ \sp Γ;Σ ⊢ \t{t} : \f{Π_(a∈A) B}}
    {Σ \sp Γ;Σ ⊢ \t{u} : \f{A}}{Ξ ⊢ \t{u} ≡ \t{v}}
    {Σ \sp Γ;Ξ ⊢ \t{t u} : \f{B[a≔u]}} $
\end{center}
\begin{proof}
Using \lemma("derivmem") we can use the following derivation in the system
extended with the ($∈_{i,τ}$) rule.
\begin{proofTree}
\Caml(
let p =
  hyp                       <$Σ \sp Γ;Σ ⊢ \t{t} : \f{Π_(a∈A) B}$>;
  unary   ~name:<$Def$>     <$Σ \sp Γ;Σ ⊢ \t{t} : \f{∀a (a∈A ⇒ B)}$>;
  unary   ~name:<$∀_e$>     <$Σ \sp Γ;Σ ⊢ \t{t} : \f{u∈A ⇒ B[a≔u]}$>;
  hyp                       <$Σ \sp Γ;Σ ⊢ \t{u} : \f{A}$>;
  hyp                       <$Ξ ⊢ \t{u} ≡ \t{v}$>;
  binary  ~name:<$∈_{i,τ}$> <$Σ \sp Γ;Σ ⊢ \t{u} : \f{u∈A}$>;
  binary  ~name:<$⇒_e$>     <$Σ \sp Γ;Ξ ⊢ \t{t u} : \f{B[a≔u]} $>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
\linesAfter(0) (* FIXME hack *)
\end{proof}
\end{lem}

Additionally, semantical value restriction allows us to derive a strong
typing rule for general application. It can be seen as a relaxed form
of the following rule (which can be derived easily in the initial
system).
\begin{center}
$ \binaryRN{⇒_{e,{∈}}}{Σ \sp Γ;Ξ ⊢ t : \f{v∈A⇒B}}
    {Σ \sp Γ;Ξ ⊢_\tval v : A}{Σ \sp Γ;Ξ ⊢ \t{t v} : B} $
\end{center}
The aim of such a rule is to keep track of the argument that will be applied
to a function, when typing the function itself. This is useful, in particular,
when this argument is used in a case analysis. However, in its restricted
form, this typing rule is not very useful since a term like
$\t{(λx [x|(Ci[xi]→ti) i∈I]) v}$ is equivalent to $\t{[v|(Ci[xi]→ti) i∈I]}$,
and thus the same effect can be obtained using the ($≡_{τ,τ}$). With
semantical value restriction, we can derive a stronger, relaxed rule.
\begin{lem}
The following typing rule is derivable in our system extended with (${↓}$).
\begin{center}
$ \ternaryRN{⇒_{e,{∈},τ}}{Σ \sp Γ;Ξ ⊢ t : \f{u∈A⇒B}}{Σ \sp Γ;Ξ ⊢ u : A}
    {Ξ ⊢ u ≡ v}{Σ \sp Γ;Ξ ⊢ \t{t u} : B} $
\end{center}
\begin{proof}
Using again \lemma("derivmem") to obtain the ($∈_{i,τ}$) rule, we can use
the following derivation.
\begin{proofTree}
\Caml(
let p =
  hyp                       <$Σ \sp Γ;Ξ ⊢ \t{t} : \f{u∈A ⇒ B}$>;
  hyp                       <$Σ \sp Γ;Ξ ⊢ \t{u} : \f{A}$>;
  hyp                       <$Ξ ⊢ \t{u} ≡ \t{v}$>;
  binary  ~name:<$∈_{i,τ}$> <$Σ \sp Γ;Ξ ⊢ \t{u} : \f{u∈A}$>;
  binary  ~name:<$⇒_e$>     <$Σ \sp Γ;Ξ ⊢ \t{t u} : B$>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
\linesAfter(0) (* FIXME hack *)
\end{proof}
\end{lem}
The ($⇒_{e,{∈},τ}$) rule can be used to obtain the following rule for a
generalised form of case analysis ranging over terms (and not only values).
\begin{center}
$\fit{
  \ternaryRN{+_{e,τ}}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{[(Ci : Ai) i∈I]}}
     {[Σ, x_i:ι \sp Γ, x_i:A_i; Ξ, t ≡ \t{Ci[xi]} ⊢ t_i : B]_{i∈I}}
     {Ξ ⊢ t ≡ v}
     {Σ \sp Γ;Ξ ⊢ \t{(λx [x | (Ci[xi] → ti) i∈I]) t} : B}
  }$
\end{center}
Without such a rule, it would be impossible to preserve the equivalences of
the form $t ≡ \t{Ci[xi]}$ in the premises. We would only know that
$x ≡ \t{Ci[xi]}$, which is not enough since we would have no way of linking
$x$ to $t$. The derivation of ($+_{e,τ}$) is given below. Note that we will
omit the sorting contexts for the proof to be more concise. We will also use
the notation $Δ$ for the context $Γ,x:\f{[(Ci : Ai) i∈I]}$.
\Caml(
let subp = <$
  \proofTree{
    \unaryN{≡_{τ,τ}}{
      Δ, x_i:A_i; Ξ, x≡t; x ≡ \t{Ci[xi]} ⊢ t_i : B
    }{
      \unaryN{Wk}{Δ, x_i:A_i; Ξ, x≡t; t ≡ \t{Ci[xi]} ⊢ t_i : B}{
        \hyp{Δ, x_i:A_i; Ξ, t ≡ \t{Ci[xi]} ⊢ t_i : B}
      }
    }
  } $>

let dummy = <$
  \proofTree{
    \unaryN{Ax}{Δ;Ξ,x≡t ⊢_\tval x:\f{[(Ci : Ai) i∈I]}}{
      \hyp{\mcolor(white){1 \over 1}} (* FIXME hack *)
    }
  } $>
)
\begin{proofTree}
\Caml(
let p =
  hyp <$\id(dummy)$>;
  (*
  ax       ~name:<$Ax$> (* FIXME hack, floating in the air *)
    <$Δ \sp Ξ,x≡t ⊢_\tval x:\f{[(Ci : Ai) i∈I]}$>;
  *)
  hyp <$[\id(subp)]_{i∈I}$>;
  binary   ~name:<$+_e$>
    <$Δ;Ξ,x≡t ⊢ \t{[x|(Ci[xi]→ti) i∈I]}:B$>;
  unary    ~name:<$∈_e$>
    <$Δ;Ξ ⊢ \t{[x|(Ci[xi]→ti) i∈I]}:B$>;
  unary    ~name:<$⇒_i$>
    <$Γ;Ξ ⊢_\tval \t{λx [x | (Ci[xi] → ti) i∈I]} :
        \f{t∈[(Ci : Ai) i∈I] ⇒ B}$>;
  unary    ~name:<$↑$>
    <$Γ;Ξ ⊢ \t{λx [x | (Ci[xi] → ti) i∈I]} :
        \f{t∈[(Ci : Ai) i∈I] ⇒ B}$>;
  hyp                       <$Γ;Ξ ⊢ \t{t} : \f{[(Ci : Ai) i∈I]}$>;
  hyp                       <$Ξ ⊢ \t{t} ≡ \t{v}$>;
  ternary  ~name:<$⇒_{e,{∈},τ}$>
    <$Γ;Ξ ⊢ \t{(λx [x | (Ci[xi] → ti) i∈I]) t} : B$>;
  display_proof ()
)
\begin{center}
$$\fit(p)$$
\end{center}
\end{proofTree}

Of course, the derivation of all the new typing rules introduced in this
section is conditioned to the soundness of semantical value restriction.
As a consequence, we need to adapt our model so that the ($↓$) rule is
adequate. As we will see in the next sections, the required modifications
are highly non-trivial and require changing our notions of reduction and
equivalence.

=<

=> Semantics for semantical value restriction

As mentioned in the previous section, semantical value restriction can be
enabled in our system by extending it with the ($↓$) typing rule (recalled
below).
\begin{center}
$ \unaryRN{↓}{Σ \sp Γ ; Ξ ⊢ v : A}{Σ \sp Γ ; Ξ ⊢_\tval v : A} $
\end{center}
In order to give a semantical justification to this rule (i.e., to show
that it is adequate), we need to find a model in which the following
property holds for every $Φ ∈ ⟦ο⟧$.
$$ Φ^{⊥⊥} ∩ Λ_ι^{∗} ⊆ Φ $$
This property is not true in general, and in particular it is not true in
our current model. A counter-example is given in the following theorem.
\begin{thm}
If we choose $({≡}_{≻})$ as our equivalence relation and $({≻})$ as our
reduction relation then there is a pole $\dbot$ and a set of values
$Φ ∈ ⟦ο⟧$ such that $Φ^{⊥⊥} ∩ Λ_ι^{∗}$ contains strictly more values
that $Φ$.
\begin{proof}
(* FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME *)
Let us consider the pole $\dbot = \{p ∈ Λ×Π \| ∃v∈Λ_ι, p ≻^{∗} \p{v∗ε}\}$
and show that the set $Φ = \{v∈\vset \| v ≡_{≻} \v{λx Ω}\} ∪ \{\v{□}\}$
is suitable. As we have $\vset ⊆ \vset^{⊥⊥}$ by \lemRef("orthosimple")
it is enough to show $Φ^⊥ = \vset^⊥$ since in this case we get
$\vset ⊆ Φ^{⊥⊥} = \vset^{⊥⊥}$. Of course, there are many values that
are in $\vset$, but not in $Φ$. For example, we have $\v{{}} ∈ \vset$ but
$\v{{}} \nequiv_{≻} \v{λxΩ}$ according to \thmRef("nequivlamreco").

Since $Φ ⊆ \vset$ we must have $Φ^⊥ ⊇ \vset^⊥$ by \lemRef("orthoinclstack"),
so it only remains to show that $Φ^⊥ ⊆ \vset^⊥$. Let us take a stack
$π ∈ Φ^⊥$. By definition, we know $\p{w∗π} ∈ \dbot$ for all $w ∈ Φ$. Let us
take a value $v₀ ∈ \vset$ and show that $\p{v₀∗π} ∈ \dbot$. If $v₀ = \v{□}$
then this is immediate since $\v{□} ∈ Φ$ so we can assume $v₀ ≠ \v{□}$. We
reason by case on the form of the stack $π$.
\begin{itemize}
\item If $π = ε$, then $\p{v₀∗π} ∈ \dbot$ by definition of $\dbot$.
\item If $π = α$ for some $α∈\cal{V}_σ$ then it cannot be that $π ∈ Φ^⊥$.
      If it were the case, we would have $\p{λxΩ ∗ α} ∈ \dbot$, which
      cannot be true since this process is blocked.
\item If $π = \s{w·ξ}$ for some value $w ∈ Λ_ι$ and stack $ξ ∈ Π$ then
      it cannot be that $π ∈ Φ^⊥$. If it were the case, we would have
      $\p{λxΩ ∗ w·ξ} ≻ \p{Ω ∗ ξ} ∈ \dbot$, which cannot be true since
      this process is non-terminating.
\item If $π = \s{[t]ξ}$ for some term $t ∈ Λ$ and stack $ξ ∈ Π$ then we
      consider the reduction of the process $\p{t ∗ z·ξ}$ where
      $z∈\cal{V}_ι$ is a fresh $λ$-variable. We know that $\p{t∗z·ξ}$
      cannot be non-terminating, as otherwise
      $\p{(t∗z·ξ)[z≔λxΩ]} = \p{t∗λxΩ·ξ}$ would also be non-terminating
      according to \lemRef("redstable"). This would contradict
      $\s{[t]ξ} ∈ Φ^⊥$ since we have $\p{λxΩ∗[t]ξ} ≻ \p{t∗λxΩ·ξ}$.
      Consequently, there is $q ∈ Λ×Π$ such that $\p{z∗[t]ξ} ≻ \p{q}$.
      We now reason by case analysis following \lemRef("possibilities").
      If $q$ is final, then $\p{q[z≔v]}$ is also final by
      \lemRef("redstable"), and thus $\p{v∗[t]ξ} ∈ \dbot$. In all the
      other cases but $\p{z∗[t₀]π₀}$ the process $\p{q[z≔λxΩ]}$ is either
      still blocked or non-terminating, which contradicts the fact that
      $\s{[t]ξ} ∈ Φ^⊥$. In the last case we can iterate the proof in
      a similar way as for \theorem("base_extterm"). In the case where
      also get that $\p{λx Ω ∗ [t]ξ} ∈ \dbot$ since this process is
      non-terminating.
\end{itemize}
\end{proof}
\end{thm}

The idea now is to use our equivalence relation $({≡}_{≻})$ to extend
the reduction relation $({≻})$ with a new, surprising reduction rule. It
will reduce processes having the form $\p{δ(v,w) ∗ π}$ to $\p{v ∗ π}$
in the case where $v \nequiv_{≻} w$, and remain stuck otherwise. With
such a reduction rule, the definitions of reduction and equivalence
become interdependent. Consequently, we need to be very careful so
that everything remains well-defined. We will rely on a stratified
construction of both reduction and equivalence.
\begin{def}
For every $i ∈ \bbN$ we define two relations $({↠}_i)$ and $({≡}_i)$
as follows.
\begin{center}
\diagram(
let _ =
  let line e1 e2 = [ e1 ; <$=$> ; e2 ] in
  array [`East ; `Main ; `West]
  ~horizontal_padding:(function 1 -> 5.0 | _ -> 4.0) (* Fix *)
  [ line <$({↠}_i)$> <$({≻}) ∪ \{(\p{δ(v,w) ∗ π}, \p{v ∗ π}) \st
      ∃j < i, v \nequiv_j w\}$>
  ; line <$({≡}_i)$> <$\{(t,u) \st ∀j ≤ i, ∀π∈Π, ∀ρ∈\cal{S},
      {{\p{tρ∗π}} {⇓}_j} ⇔ {{\p{uρ∗π}} {⇓}_j}\}$> ]
)
\end{center}
Here, all the relations are well-defined as there is no circularity. In
particular, we have $({↠}₀) = ({≻})$ since there is no natural number
that is strictly smaller than $0$. This implies that we also have
$({≡}₀) = ({≡}_{≻})$
\end{def}
\begin{lem}\label("isequiv")
For every $i ∈ \bbN$, the relation $({≡}_i)$ is an equivalence relation.
\begin{proof}
Immediate.
\end{proof}
\end{lem}

We can then define our actual reduction relation and equivalence relation
as a union and an intersection over the previously defined relations.
\begin{def}
We define a reduction relation $({↠})$ and an equivalence relation $({≡})$.
$$
  ({↠}) = \bigcup_{i∈\bbN} ({↠}_i)
  \hspace(8.0)
  ({≡}) = \bigcap_{i∈\bbN} ({≡}_i)
$$
\end{def}
\begin{rem}
We have $({↠}_i) ⊆ ({↠}_{i+1})$ and $({≡}_{i+1}) ⊆ ({≡}_i)$. Consequently,
the construction of $({↠}_i)_{i∈\bbN}$ and $({≡}_i)_{i∈\bbN}$ converges.
In fact, $({↠})$ and $({≡})$ form a fixpoint at ordinal $ω$. Surprisingly,
this property will not be explicitly required in the following.
\end{rem}
\begin{lem}
The relation $({≡})$ is an equivalence relation.
\begin{proof}
Immediate using \lemRef("isequiv") since an intersection of equivalence
relations is itself an equivalence relation.
\end{proof}
\end{lem}
For convenience, the definition of our new reduction and equivalence
relations can be expressed in the following way, where $({\nequiv})$
denotes the negation of $({≡})$.
\begin{center}
\diagram(
let _ =
  let line e1 e2 = [ e1 ; <$=$> ; e2 ] in
  array [`East ; `Main ; `West]
  ~horizontal_padding:(function 1 -> 5.0 | _ -> 4.0) (* Fix *)
  [ line <$({≡})$>
      <$ \{(t,u) \st ∀i∈\bbN, ∀π∈Π, ∀ρ∈\cal{S},
         {{\p{tρ∗π}} {⇓}_i} ⇔ {{\p{uρ∗π}} {⇓}_i}\} $>
  ; line <$({\nequiv})$>
      <$ \{(t,u), (u,t) \st ∃i∈\bbN, ∃π∈Π, ∃ρ∈\cal{S},
         {{\p{tρ∗π}} {⇓}_i} ∧ {{\p{uρ∗π}} {⇑}_i}\}$>
  ; line <$({↠})$>
      <$({≻}) ∪ \{(\p{δ(v,w)∗π}, \p{v∗π}) \st v \nequiv w\}$> ]
)
\end{center}
Note that the definition of $({↠})$ corresponds exactly to what we aimed
for: an extension of $({≻})$ with a reduction rule for $δ$-like terms
carrying two non-equivalent values.

\begin{thm}\label("main")
Let $\dbot ⊆ Λ×Π$ be $↠$-saturated set of processes such that for every
$p∈\dbot$ we have $p {⇓_{↠}}$ and $\p{□∗ε} ∈ \dbot$. If $Φ ∈ ⟦ο⟧$ then
we have the following property.
$$Φ^{⊥⊥} ∩ Λ_ι ⊆ Φ$$
\begin{proof}
We need to show that for every value $v∈Φ^{⊥⊥}$ we also have $v∈Φ$. We
are going to show the contrapositive, so let us assume $v∉Φ$ and show
$v∉Φ^{⊥⊥}$. By definition, we need to find a stack $π∈Φ^⊥$ such that
$\p{v∗π}∉\dbot$. We will take $π=\s{[λxδ(x,v)][□]ε}$ and show that it
is suitable. We first need to prove that $π∈Φ^⊥$ so we take $w∈Φ$ and
we show $\p{w∗π}∈\dbot$. If $w = \v{□}$ then $\p{□∗π} ↠ \p{□∗[□]ε} ↠
\p{□∗ε} ∈ \dbot$ and we can thus conclude since $\dbot$ is
$↠$-saturated. Otherwise, if $w ≠ \v{□}$ then we have the following.
$$
  \p{w∗π} ↠ \p{λxδ(x,v)∗w·[□]ε} ↠ \p{δ(w,v)∗[□]ε} ↠ \p{w∗[□]ε}
    ↠ \p{□∗w·ε} ↠ \p{□∗ε} ∈ \dbot
$$
Note that we have $v \nequiv w$ since $v ∉ Φ$ and $Φ$ is closed under
$({≡})$. We can thus conclude using again the fact that $\dbot$ is
$↠$-saturated. It now remains to show that $\p{v∗π₀}∉\dbot$. It cannot
be that $v = \v{□}$ since we assumed $v ∉ Φ$. As a consequence, we have
the following.
$$
  \p{v∗π} ↠ \p{λxδ(x,v)∗v·[□]ε} ↠ \p{δ(v,v)∗[□]ε} {⇑}_{↠}
$$
Here, $\p{δ(v,v)∗[□]ε}$ is blocked since $v ≡ v$ by reflexivity of
$({≡})$ and thus $\p{v∗π} ∉ \dbot$.
\end{proof}
\end{thm}
\begin{rem}
\thmRef("main") only gives us the required property of the model
for poles of terminating processes (i.e., processes that eventually
reduce to a final states). This limitation is not a problem here as
we will only consider poles having this property.
\end{rem}

=<

=> Final instance of our model

The reduction relation $({↠})$ and the equivalence relation $({≡})$ give
us an essential property for semantical value restriction. However, we
need to verify some properties before being able to fix the parameters of
our model definitively. There is no problem in adopting $({↠})$ as our
reduction relation as it contains $({≻})$. Nevertheless, we need to check
that our equivalence relation $({≡})$ is a congruence and that it is
compatible with $({≡}_{≻})$. Let us first show that it is indeed a
congruence.
\begin{thm}\label("fullsubstequiv")
Let $t$, $u ∈ Λ$ be two terms and $ρ ∈ \cal{S}$ be a substitution. If we
have $\t{t} ≡ \t{u}$ then $\t{tρ} ≡ \t{uρ}$.
\begin{proof}
Let us take $i₀ ∈ \bbN$, $ρ₀ ∈ \cal{S}$ and $π₀ ∈ Π$ and prove
${{\p{(tρ)ρ₀ ∗ π₀}} {⇓}_{i₀}} ⇔ {{\p{(uρ)ρ₀ ∗ π₀}} {⇓}_{i₀}}$,
which can be rewritten as
${{\p{t(ρ ∘ ρ₀) ∗ π₀}} {⇓}_{i₀}} ⇔ {{\p{u(ρ ∘ ρ₀) ∗ π₀}} {⇓}_{i₀}}$.
We can thus conclude by definition of $t ≡ u$ using $i₀$, the
substitution $ρ ∘ ρ₀$ and the stack $π₀$.
\end{proof}
\end{thm}
\begin{thm}\label("fullextval")
Let $v₁$, $v₂∈Λ_ι$ be values, $t∈Λ$ be a term and $x∈\cal{V}_ι$ be a
$λ$-variable. If $v₁ ≡ v₂$ then we have $\t{t[x≔v₁]} ≡ \t{t[x≔v₂]}$.
\begin{proof}
We are going to prove the contrapositive so we suppose $\t{t[x≔v₁]}
\nequiv \t{t[x≔v₂]}$ and we show $v₁ \nequiv v₂$. Let us first assume
that neither $v₁$ nor $v₂$ is equal to $\v{□}$ or to a $λ$-variables.
By definition, we know that there $i ∈ \bbN$, $π∈Π$ and $ρ∈\cal{S}$
such that we have ${\p{(t[x≔v₁])ρ ∗ π}} {⇓}_i$ and
${\p{(t[x≔v₂])ρ ∗ π}} {⇑}_i$ (up to symmetry). As $x$ is bound we
can rename it so that $\t{(t[x≔v₁])ρ} = \t{tρ[x≔v₁ρ]}$ and
$\t{(t[x≔v₂])ρ} = \t{tρ[x≔v₂ρ]}$. To finish the proof, we need to find
$i₀ ∈ \bbN$, $π₀∈Π$ and $ρ₀∈\cal{S}$ such that ${\p{v₁ρ₀ ∗ π₀}} {⇓}_{i₀}$
and ${\p{v₂ρ₀ ∗ π₀}} {⇑}_{i₀}$ (up to symmetry). We can take $i₀ = i$,
$π₀ = \s{[λx tρ]π}$ and $ρ₀ = ρ$ since by definition we have
${\p{v₁ρ ∗ [λx tρ]π}} ↠_i^{∗} {\p{tρ[x≔v₁ρ] ∗ π}} {⇓}_i$ and
${\p{v₂ρ ∗ [λx tρ]π}} ↠_i^{∗} {\p{tρ[x≔v₂ρ] ∗ π}} {⇑}_i$. Note that here,
it is essential that $\v{v₁ρ}$ and $\v{v₂ρ}$ are not equal to $\v{□}$
or to some $λ$-variable as otherwise the first reduction steps could not
be taken.

It remains to show that $v₁ \nequiv v₂$ in the cases where $v₁$,
$v₂$ or both are equal to $\v{□}$ or a $λ$-variable. First, we can
assume that $v₁ ≠ v₂$ as otherwise we would immediately get a
contradiction with $\t{t[x≔v₁]} \nequiv \t{t[x≔v₂]}$ by reflexivity
of $({≡})$. As a consequence, we cannot have $v₁ = v₂ = \v{□}$ or
$v₁ = v₂ = x ∈ \cal{V}_ι$. Now, in all the other cases we must have
$v₁ \nequiv_{≻} v₂$ according to \theorems(["canonbox" ; "varequiv"])
so we get $v₁ \nequiv v₂$.
\end{proof}
\end{thm}

\begin{lem}\label("aposs")
Let $p∈Λ×Π$ be a process, $t∈Λ$ be a term and $a∈\cal{V}_τ$ be a term
variable. If we have ${\p{p[a≔t]}} {⇓}_k$ for some $k∈\bbN$ then
there is a blocked process $q∈Λ×Π$ such that $p ≻^{∗} q$ and either
\begin{itemize}
\item $q = \p{v∗ε}$ for some value $v∈Λ_ι$,
\item $q = \p{a∗π}$ for some stack $π∈Π$,
\item $k ≠ 0$ and $q = \p{δ(v,w)∗π}$ for some values $v$, $w∈Λ_ι$
      and $π∈Π$. Moreover, in this case we know that
      $\v{v[a≔t]} \nequiv_j \v{w[a≔t]}$ for some $j < k$.
\end{itemize}
\begin{proof}
If $p$ is non-terminating then so is $\p{p[a≔t]}$ according to
\lemRef("redstable"). Since $({≻}) ⊆ ({↠}_k)$ this contradicts
${\p{p[a≔t]}} {⇓}_k$ and thus there must be a blocked process
$q∈Λ×Π$ such that $p ≻^{∗} q$. Using \thmRef("redcompatall")
we obtain $\p{p[a≔t]} ≻^{∗} \p{q[a≔t]}$, which tells us that
${\p{q[a≔t]}} {⇓}_k$. This means that $q$ cannot be stuck, as
otherwise $q[a≔t]$ would also be stuck by \lemRef("redstable") and
this would contradict ${\p{q[a≔t]}} {⇓}_k$.
(* *)
Let us now suppose that $p = \p{δ(v,w)∗π}$ for some $v$, $w∈Λ_ι$
and $π∈Π$. Since ${\p{δ(vρ,wρ)∗π}} {⇓}_k$ there must be $j < k$
(and thus $k≠0$) such that $\v{vρ} \nequiv_j \v{wρ}$, otherwise
we would obtain a contradiction.
(* *)
According to \lemRef("possibilities") it remains to rule the
following forms for $q$, where $b≠a$.
\Caml(
  let _ =
    let line = List.map (fun pr -> <<$\p(pr)$>>) in
    let line3 p1 p2 p3    = line [p1; p2; p3] in
    let line4 p1 p2 p3 p4 = line [p1; p2; p3; p4] in
    tabular_layout 0.8 2.0
    [ line3 "x.lk ∗ π"
            "x ∗ v·π"
            "[x | (Ci[xi] → ti) i∈I] ∗ π"
    ; line4 "x ∗ [t]π"
            "R(x,u) ∗ π"
            "b ∗ π"
            "v ∗ α" ]
)
If $q$ was of one of these forms, then $\p{q[a≔t]}$ would still be
blocked, which would again contradict ${\p{q[a≔t]}} {⇓}_k$.
\end{proof}
\end{lem}

\begin{lem}\label("afullextlem")
Let $u₁$, $u₂$, $t∈Λ$ be three terms and $a∈\cal{V}_τ$ be a term
variable. For all $k ∈ \bbN$, if $\t{u₁} ≡_k \t{u₂}$ then
$\t{t[a≔u₁]} ≡_k \t{t[a≔u₂]}$.
\begin{proof}
We do a proof by induction on $k$. If $k = 0$ then this property
exactly corresponds to \theorem("base_extterm"). Let us now take
$k > 0$, suppose $\t{u₁} ≡_k \t{u₂}$ and show $\t{t[a≔u₁]} ≡_k
\t{t[a≔u₂]}$. By definition, we need to take $π∈Π$, $ρ∈\cal{S}$
and show the following.
$$ {{\p{(t[a≔u₁])ρ∗π}} {⇓}_k} ⇔ {{\p{(t[a≔u₂])ρ∗π}} {⇓}_k} $$
Since $a$ is bound we are free to rename it so we may assume
$\t{(t[a≔u₁])ρ} = \t{tρ[a≔u₁ρ]}$, $\t{(t[a≔u₂])ρ} = \t{tρ[a≔u₂ρ]}$
and $a∉FV_τ(π) ∪ FV_τ(t₁) ∪ FV_τ(t₂)$. By symmetry, we can thus
suppose ${\p{tρ[a≔u₁ρ]∗π}} {⇓}_k$ and show ${\p{tρ[a≔u₂ρ]∗π}} {⇓}_k$.

We will now build a sequence $(t_i,π_i,l_i)_{i ∈ I}$ defined in such
a way that for all $i∈I$ we have
$\p{tρ[a≔u₁ρ]∗π} ↠_k^{∗} \p{ti[a≔u₁ρ]∗πi[a≔u₁ρ]}$
in $l_i$ steps. We will also require $(l_i)_{i ∈ I}$ to be increasing
and to have a strictly increasing subsequence. Under this condition our
sequence will be finite. If it was infinite, $\p{tρ[a≔u₁ρ]∗π}$ would
be non-terminating, and this would contradict ${\p{tρ[a≔u₁ρ]∗π}} {⇓}_k$.
As a consequence, our sequence has a finite number $n+1$ of elements
(for some $n∈\bbN$), and we can denote it $(t_i,π_i,l_i)_{i ≤ n}$.
To show that $(l_i)_{i ≤ n}$ has a strictly increasing subsequence,
we will ensure that it does not have three equal consecutive values.

To define $(t₀,π₀,l₀)$ we consider the reduction of the process
$\p{tρ∗π}$. Since we have
$\p{(tρ∗π)[a≔u₁ρ]} = {\p{tρ[a≔u₁]∗π}} {⇓}_k$
we can apply \lemRef("aposs") to obtain a blocked process $p$ such
that $\p{tρ∗π} ≻^j p$. We thus take $\p{t₀∗π₀} = p$ and $l₀=j$.
According to \thmRef("redcompatall") we have
$\p{(tρ∗π)[a≔u₁ρ]} ≻^j \p{t₀[a≔u₁ρ]∗π₀[a≔u₁ρ]}$. Consequently,
we can deduce that
$\p{(tρ∗π)[a≔u₁ρ]} ↠_k^{∗} \p{t₀[a≔u₁ρ]∗π₀[a≔u₁ρ]}$
in $l₀ = j$ steps.

To define $(t_{i+1},π_{i+1},l_{i+1})$ we consider the process
$\p{ti∗πi}$. By construction we know that
$\p{tρ[a≔u₁ρ]∗π} ↠_k^{∗} \p{ti[a≔u₁ρ]∗πi[a≔u₁ρ]}$ in $l_i$ steps.
According to \lemRef("aposs"), $\p{ti∗πi}$ can only be of three
different shapes.
\begin{itemize}
\item If $\p{ti∗πi} = \p{v∗ε}$ for some $v∈Λ_ι$ then the
      sequence ends with $n = i$.
\item If $\t{ti} = a$ then we consider the process $\p{ti[a≔u₁ρ]∗πi}$.
      By construction we know ${\p{(ti[a≔u₁ρ]∗πi)[a≔u₁ρ]}} {⇓}_k$ and
      \lemRef("aposs") gives us a blocked process $p$ such that
      $\p{ti[a≔u₁ρ]∗πi} ≻^j p$. By \thmRef("redcompatall")
      $\p{(ti[a≔u₁ρ]∗πi)[a≔u₁ρ]} ≻^j \p{p[a≔u₁ρ]}$, and hence
      $\p{ti[a≔u₁ρ]∗πi[a≔u₁ρ]} ↠_k^{∗} \p{p[a≔u₁ρ]}$ in $j$ steps.
      We then take as a definition $\p{ti+1∗πi+1} = p$ and
      $l_{i+1} = l_i + j$.

      Now, is it possible to have $j=0$? This can only happen when
      $\p{ti[a≔u₁ρ]∗πi}$ is of one of the three forms of \lemRef("aposs").
      It cannot be of the form $\p{a∗π}$ as we assumed that $a$ does not
      appear in $\t{u₁ρ}$. If it is of the form $\p{v∗ε}$, then we
      reached the end of the sequence with $i = n$ so there is no problem.
      We only have to be careful when $\t{ti[a≔u₁ρ]} = \t{δ(v,w)}$. In
      this case, we will make sure that we always have $l_{i+2} > l_{i+1}$
      (see the following case).
\item If $\t{ti} = \t{δ(v,w)}$ for some $v$, $w∈Λ_ι$ then we know
      $\v{v[a≔u₁ρ]} \nequiv_m \v{w[a≔u₁ρ]}$ for some $m < k$. Hence,
      we have $\p{ti[a≔u₁ρ]∗πi} = \p{δ(v[a≔u₁ρ],w[a≔u₁ρ])∗πi} ↠_k
      \p{v[a≔u₁ρ]∗πi}$ by definition. Moreover,
      $\p{ti[a≔u₁ρ]∗πi[a≔u₁ρ]} ↠_k \p{v[a≔u₁ρ]∗πi[a≔u₁ρ]}$
      by definition of $({↠}_k)$. Since
      $\p{t[a≔u₁ρ]∗π} ↠_k^{∗} \p{ti[a≔u₁ρ]∗πi[a≔u₁ρ]}$ in $l_i$ steps
      we get that $\p{t[a≔u₁ρ]∗π} ↠_k^{∗} \p{v[a≔u₁ρ]∗πi[a≔u₁ρ]}$ in
      $l_i+1$ steps, and hence we have
      $\p{(v[a≔u₁ρ]∗πi)[a≔u₁ρ]} = {\p{v[a≔u₁ρ]∗πi[a≔u₁ρ]}} {⇓}_k$.

      (* FIXME probably useless (two steps in one) *)
      We now consider the reduction of the process $\p{v[a≔u₁ρ]∗πi}$.
      According to \lemRef("aposs") there is a blocked process $p$ such
      that $\p{v[a≔u₁ρ]∗πi} ≻^j p$. Using \thmRef("redcompatall") we
      obtain $\p{v[a≔u₁ρ]∗πi[a≔u₁ρ]} ≻^j \p{p[a≔u₁ρ]}$ from which we can
      deduce that we have $\p{v[a≔u₁ρ]∗πi[a≔u₁ρ]} ↠_k^{∗} \p{p[a≔u₁ρ]}$
      in $j$ steps. We then take $\p{ti+1∗πi+1} = p$ and
      $l_{i+1} = l_i + j + 1$ (and thus $l_{i+1} > l_i$).
\end{itemize}
Intuitively $(t_i,π_i,l_i)_{i ≤ n}$ mimics the reduction of the process
$\p{t[a≔u₁ρ]∗π}$ while making explicit every substitution of $a$ and
every reduction of a $δ$-like state.

To end the proof we will show that for all $i ≤ n$ we have
${\p{ti[a≔u₂ρ]∗πi[a≔u₂ρ]}} {⇓}_k$. For $i = 0$ this will give
us ${\p{t[a≔u₂ρ]∗π}} {⇓}_k$, which is the expected result. As
by construction $\p{tn∗πn} = \p{v∗ε}$, we have
$\p{tn[a≔u₂ρ]∗πn[a≔u₂ρ]} = \p{v[a≔u₂ρ]∗ε}$
from which we get ${\p{tn[a≔u₂ρ]∗πn[a≔u₂ρ]}} {⇓}_k$.
We now suppose that ${\p{ti+1[a≔u₁ρ]∗πi+1[a≔u₂ρ]}} {⇓}_k$ for
$0 ≤ i < n$ and show that ${\p{ti[a≔u₁ρ]∗πi[a≔u₂ρ]}} {⇓}_k$.
By construction $\p{ti∗πi}$ can be of two shapes since only
$\p{tn∗πn}$ can be of the form $\p{v∗ε}$.
\begin{itemize}
\item If $\t{ti} = a$ then we have
      $\p{u₁ρ∗πi} ↠_k^{∗} \p{ti+1 ∗ πi+1}$.
      As a consequence, \thmRef("redcompatall") gives us
      $\p{u₁ρ∗πi[a≔u₂ρ]} ↠_k \p{ti+1[a≔u₂ρ]∗πi[a≔u₂ρ]}$
      from which we can deduce that we have ${\p{u₁ρ∗πi[a≔u₂ρ]}} {⇓}_k$
      by induction hypothesis. Since $\t{u₁} ≡_k \t{u₂}$ by hypothesis,
      we obtain $\p{u₂ρ∗πi[a≔u₂ρ]} = {\p{(ti∗πi)[a≔u₂ρ]}} {⇓}_k$.
\item If $\t{ti} = \t{δ(v,w)}$ then we have
      $\p{v∗πi} ↠_k \p{ti+1∗πi+1}$. As a consequence,
      \thmRef("redcompatall") gives us
      $\p{v[a≔u₂ρ]∗πi[a≔u₂ρ]} ↠_k \p{ti+1[a≔u₂ρ]∗πi+1[a≔u₂ρ]}$.
      Using the induction hypothesis we obtain
      ${\p{v[a≔u₂ρ]∗πi[a≔u₂ρ]}} {⇓}_k$. It remains to show that we have
      $\p{δ(v[a≔u₂ρ],w[a≔u₂ρ])∗πi[a≔u₂ρ]} ↠_k^{∗}
      \p{v[a≔u₂ρ]∗πi[a≔u₂ρ]}$. We need to find $j < k$ such that
      $\v{v[a≔u₂ρ]} \nequiv_k \v{w[a≔u₂ρ]}$.
      By construction, there is $m < k$ such that we have
      $\v{v[a≔u₁ρ]} \nequiv_m \v{w[a≔u₁ρ]}$, and we will show
      $\v{v[a≔u₂ρ]} \nequiv_m \v{w[a≔u₂ρ]}$. Using the global
      induction hypothesis twice, we obtain that
      $\v{v[a≔u₁ρ]} ≡_m \v{v[a≔u₂ρ]}$ and that
      $\v{w[a≔u₁ρ]} ≡_m \v{w[a≔u₂ρ]}$.
      Now if we suppose $\v{v[a≔u₂ρ]} ≡_m \v{w[a≔u₂ρ]}$ then we
      have $\v{v[a≔u₁ρ]} ≡_m \v{v[a≔u₂ρ]} ≡_m \v{w[a≔u₂ρ]} ≡_m
      \v{v[a≔u₁ρ]}$, which contradicts $\v{v[a≔u₁ρ]} \nequiv_m
      \v{w[a≔u₁ρ]}$. Hence we must have $\v{v[a≔u₂ρ]} \nequiv_m
      \v{w[a≔u₂ρ]}$.
\end{itemize}
\end{proof}
\end{lem}
\begin{thm}\label("fullextterm")
Let $u₁$, $u₂$, $t∈Λ$ be three terms and $a∈\cal{V}_τ$ be a term variable.
If $u₁ ≡ u₂$ then $\t{t[a≔u₁]} ≡ \t{t[a≔u₂]}$.
\begin{proof}
We suppose that $u₁ ≡ u₂$ which means that $u₁ ≡_i u₂$ for all $i∈\bbN$. We
need to show that $\t{t[a≔u₁]} ≡ \t{t[a≔u₂]}$ so we take $i₀∈\bbN$ and
show $\t{t[a≔u₁]} ≡_{i₀} \t{t[a≔u₂]}$. By hypothesis we have
$u₁ ≡_{i₀} u₂$ and hence we can conclude using \lemRef("afullextlem").
\end{proof}
\end{thm}

\begin{thm}
The relation $({≡})$ is a congruence.
\begin{proof}
Combination of \thmRef("fullsubstequiv"), \thmRef("fullextval") and
\thmRef("fullextterm").
\end{proof}
\end{thm}

Now that we have proved $({≡})$ to be a congruence, it remains to show that
it is compatible with $({≡}_{≻})$. Intuitively, this will provide us with
sufficient conditions for proving equivalences based on \chapter("obsEquiv").
\begin{thm}\label("fullcompat1")
For every terms $t$, $u∈Λ$ such that $t ≡ u$ we have $t ≡_{≻} u$.
\begin{proof}
Immediate by definition.
\end{proof}
\end{thm}

\begin{thm}\label("fullcompat2")
Let $t$, $u∈Λ$ be two terms. If for every stack $π∈Π$ there is a process
$p ∈ Λ×Π$ such that both $\p{t∗π} ≻^{∗} p$ and $\p{u∗π} ≻^{∗} p$,
then $t ≡ u$.
\begin{proof}
By definition, we need to take $i₀ ∈ \bbN$, $π₀ ∈ Π$ and $ρ₀ ∈ \cal{S}$ and
show that we have ${{\p{tρ₀∗π₀}} {⇓}_{i₀}} ⇔ {{\p{uρ₀∗π₀}} {⇓}_{i₀}}$.
By symmetry, we may assume ${\p{tρ₀∗π₀}} {⇓}_{i₀}$ and show
${\p{uρ₀∗π₀}} {⇓}_{i₀}$. By hypothesis, we know that there is $p₀ ∈ Λ×Π$
such that $\p{t∗π₀} ≻^{∗} p₀$ and $\p{u∗π₀} ≻^{∗} p₀$. Now, using
\thmRef("redcompatall") we obtain $\p{tρ₀∗π₀} ≻^{∗} \p{p₀ρ₀}$ and
$\p{uρ₀∗π₀} ≻^{∗} \p{p₀ρ₀}$. Note that we may assume that $\s{π₀ρ₀} = \s{π₀}$
since we are free to rename the variables bound by $ρ₀$ in $\t{tρ₀}$ and
$\t{uρ₀}$. We can hence deduce that ${\p{p₀ρ₀}} {⇓}_{i₀}$ as otherwise
we could not have ${\p{tρ₀∗π₀}} {⇓}_{i₀}$. Now, since 
$\p{uρ₀∗π₀} ≻^{∗} \p{p₀ρ₀}$ we can conclude that 
${\p{uρ₀∗π₀}} {⇓}_{≻}$.
\end{proof}
\end{thm}

\begin{thm}\label("fullcompat3")
Let $t₁$, $t₂∈Λ$ be two terms such that $x ∈ FV_ι(t₁) ∩ FV_ι(t₂)$. If
there is a term $u∈Λ$ such that for all terms $v∈Λ_ι$ and stacks $π∈Π$
we have $\p{t₁[x≔v]∗[u]π} ≻^{∗} \p{v∗π}$ and
$\p{t₂[x≔v]∗[u]π} ≻^{∗} \p{v∗π}$,
and if $\t{t₁[x≔v₁]} ≡ \t{t₂[x≔v₂]}$ for some values $v₁$, $v₂∈Λ_ι$,
then we have $v₁ ≡ v₂$.
\begin{proof}
Let us take $v₁$, $v₂∈Λ_ι$ such that $v₁ \nequiv v₂$ and show that
$\t{t₁[x≔v₁]} \nequiv \t{t₂[x≔v₂]}$. By definition there is
$i∈\bbN$, $π∈Π$ and $ρ∈\cal{S}$ such that ${\p{v₁ρ∗π}} {⇓}_i$ and
${\p{v₂ρ∗π}} {⇑}_i$ (up to symmetry). We need to find $i₀∈\bbN$,
$π₀∈Π$ and $ρ₀∈\cal{S}$ such that ${\p{(t₁[x≔v₁])ρ₀∗π₀}} {⇓}_{i₀}$
and ${\p{(t₂[x≔v₂])ρ₀∗π₀}} {⇑}_{i₀}$. We will now show that $i₀ = i$,
$π₀ = \s{[u]π}$ and $ρ₀ = ρ$ are suitable. By hypothesis, we know
that $\p{t₁[x≔v₁]∗[u]π} ≻^{∗} \p{v₁∗π}$ and that
$\p{t₂[x≔v₂]∗[u]π} ≻^{∗} \p{v₂∗π}$. We then obtain
$\p{(t₁[x≔v₁])ρ∗[u]π} = \p{(t₁[x≔v₁]∗[u]π)ρ} ≻^{∗}
\p{(v₁∗π)ρ} = {\p{v₁ρ∗π}} {⇓}_i$ and $\p{(t₂[x≔v₂])ρ∗[u]π} =
\p{(t₂[x≔v₂]∗[u]π)ρ} ≻^{∗} \p{(v₂∗π)ρ} = {\p{v₂ρ∗π}} {⇑}_i$
using \lemRef("redcompatall"). Note that we may assume $\t{uρ} = u$
and $\s{πρ} = π$ as we are free to rename the variables bound by $ρ$
in $\t{(t₁[x≔v₁])ρ}$ and $\t{(t₂[x≔v₂])ρ}$.
\end{proof}
\end{thm}

\begin{thm}
The relation $({≡})$ is compatible with $({≡}_{≻})$.
\begin{proof}
Combination of \thmRef("fullcompat1"), \thmRef("fullcompat2") and
\thmRef("fullcompat3").
\end{proof}
\end{thm}

Now that we have fixed our reduction relation to be $({↠})$ and our
equivalence to be $({≡})$, the adequacy lemma is still valid. However,
we can now extend our type system with the typing rule that we aimed for.
\begin{center}
$ \unaryRN{↓}{Σ \sp Γ ; Ξ ⊢ v : A}{Σ \sp Γ ; Ξ ⊢_\tval v : A} $
\end{center}
We can thus extend the adequacy lemma provided that our pole $\dbot$
contains only terminating processes and that $\p{□∗ε} ∈ \dbot$ (i.e.,
requirements of \thmRef("main")).
\begin{thm}\label("full_adequacy")
Let $Σ$ be a sorting context, $Γ$ be a typing context, $Ξ$ be an equational
context and $A ∈ \cal{F}$ be a type. Let $ρ$ be a valuation over $Σ$ such
that $ρ ⊩ Γ$ and $ρ ⊩ Ξ$.
\begin{itemize}
\item If $Σ \sp Γ ; Ξ ⊢ t:A$ is derivable, then $\t{tρ} ∈ \ts{Aρ}$.
\item If $Σ \sp Γ ; Ξ ⊢ π:A^⊥$ is derivable, then $\s{πρ} ∈ \ss{Aρ}$.
\item If $Σ \sp Γ ; Ξ ⊢_\tval v:A$ is derivable, then
      $\v{vρ} ∈ {\vs{Aρ} ∖ \{\v{□}\}}$.
\end{itemize}
\begin{proof}
As for \theorems(["adequacy" ; "stack_adequacy"]), the proof is
done by induction of the derivation of the typing judgments. For all the
rules of \figRef("typerules") and the rules for typing stacks given in
\thmRef("stack_adequacy") the proof does not change. We only have to be
concerned with our new ($↓$) rule. We need to show $\v{vρ} ∈ {\vs{Aρ} ∖
\{\v{□}\}}$, knowing that $\v{vρ} ∈ \ts{Aρ}$ by induction hypothesis.
According to \theorem("main"), every value of $\ts{Aρ}$ is also in
$\vs{Aρ}$. As a consequence, it only remains to show $\v{vρ} ≠ \v{□}$.
In the case where $v$ is a $λ$-abstraction, a variant or a record this
is immediate. If $v = x ∈ \cal{V}_ι$ then this is also immediate since
by definition $\v{ρ(x)} ≠ \v{□}$ for all $x ∈ dom(ρ)$. Finally, it cannot
be that $v = \v{□}$ since it cannot be introduced by any of our typing
rules. In particular, it cannot be brought into focus by rules handling
equivalence as this would require replacing a term or a value that was
equivalent to $\v{□}$. However, $\v{□}$ is only equivalent to itself
according to \theorem("canonbox").
\end{proof}
\end{thm}

(* TODO safety theorem using δ to show extensionality of the pole. *)

We have now obtained a model allowing the use of semantical value
restriction. We will see in the next section that the presence of
coercion rules between value and terms judgments will allow us to make
the type system a lot simpler by only considering one form of judgments.

=<

=> Derived type system

Now that our type system contains both the ($↑$) and the ($↓$) typing
rules, it is always possible to switch between term and value judgments
(at least when the subject of the considered judgment is a value). As
a consequence, we will simply forget about the value judgments and only
work using term judgments. The obtained system will be simpler, in
particular it will have less typing rules.

Note that all the typing rules of our new system will be derivable in
the current one. As a consequence, we will not need to go through a new
adequacy lemma, nor a modification of our semantics. In fact, the
derivation of our new typing rules will mostly consist in composing
the current typing rules with ($↑$) on the conclusion. For example,
we will derive the new arrow introduction rule ($⇒_{i,τ}$) as follows.
\begin{proofTree}
\Caml(
let p =
  hyp                 <$Σ,x:ι \sp Γ,x:A;Ξ ⊢ \t{t} : \f{A}$>;
  unary ~name:<$⇒_i$> <$Σ \sp Γ;Ξ ⊢_\tval \t{λx t} : \f{A⇒B}$>;
  unary ~name:<$↑$>   <$Σ \sp Γ;Ξ ⊢ \t{λx t} : \f{A⇒B}$>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
As for value judgments appearing in a premise, we will simply precompose
them with the ($↓$) rule. For example, we will derive the new product
elimination rule ($×_{e,τ}$) as follows.
\begin{proofTree}
\Caml(
let p =
  hyp                  <$Σ \sp Γ;Ξ ⊢ v : \f{{(li:Ai)i∈I}}$>;
  unary  ~name:<$↓$>   <$Σ \sp Γ;Ξ ⊢_\tval v : \f{{(li:Ai)i∈I}}$>;
  hyp                  <$k∈I$>;
  binary ~name:<$×_e$> <$Σ \sp Γ;Ξ ⊢ \t{v.lk} : \f{Ak}$>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
\Caml(let _ = derived_rules ()) (* NOTE can be moved. *)

The full set of our new rules is displayed in \figRef("derivedrules").
Note that some rules, like ($⇒_e$) for example, remain unchanged.
All the modified rules but ($∀_{i,τ}$) and ($∈_{i,τ}$) can be
derived immediately as demonstrated above. The rules ($∀_{i,τ}$) and
($∈_{i,τ}$) are instances of the semantical value restriction. The
former can be derived as follows, and a derivation for the latter was
given in a previous section.
\begin{proofTree}
\Caml(
let p =
  hyp                      <$Σ,χ:s \sp Γ;Ξ ⊢ \t{t} : \f{A}$>;
  hyp                      <$Ξ ⊢ t ≡ v$>;
  binary ~name:<$≡_{τ,τ}$> <$Σ,χ:s \sp Γ;Ξ ⊢ \t{v} : \f{A}$>;
  unary  ~name:<$↓$>       <$Σ,χ:s \sp Γ;Ξ ⊢_\tval \t{v} : \f{A}$>;
  unary  ~name:<$∀_i$>     <$Σ \sp Γ;Ξ ⊢_\tval \t{v} : \f{∀χ^s A}$>;
  unary  ~name:<$↑$>       <$Σ \sp Γ;Ξ ⊢ \t{v} : \f{∀χ^s A}$>;
  hyp                      <$Ξ ⊢ t ≡ v$>;
  binary ~name:<$≡_{τ,τ}$> <$Σ \sp Γ;Ξ ⊢ \t{t} : \f{∀χ^s A}$>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}

With our new set of typing rules, it is very easy to derive introduction
and elimination rules for the dependent product type. Using the ($∈_{i,τ}$)
rule, semantical value restriction is immediately propagated to the
elimination rules of the dependent product type.
\begin{center}
$ \unaryRN{Π_ι}{Σ,x:ι \sp Γ,x:\f{x∈A};Ξ ⊢ t : \f{B[a≔x]}}
    {Σ \sp Γ;Ξ ⊢ \t{λx t} : \f{Π_(a∈A) B}} $
\end{center}
\linesAfter(2)

\begin{center}
$ \ternaryRN{Π_e}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{Π_(a∈A) B}}
    {Σ \sp Γ;Ξ ⊢ \t{u} : \f{A}}{Ξ ⊢ u ≡ v}
    {Σ \sp Γ;Ξ ⊢ \t{t u} : \f{B[a≔u]}} $
\end{center}
\begin{proofTree}
\Caml(
let p =
  hyp                  <$Σ,x:ι \sp Γ,x:\f{x∈A};Ξ ⊢ t : \f{B[a≔x]}$>;
  unary  ~name:<$Wk$>  <$Σ,a:τ,x:ι \sp Γ,x:\f{x∈A};Ξ ⊢ t : \f{B[a≔x]}$>;
  unary  ~name:<$Wk$>  <$Σ,a:τ,x:ι \sp Γ,x:\f{x∈A};Ξ,{x≡a}⊢t:\f{B[a≔x]}$>;
  ax     ~name:<$⊤$>   <$Ξ,{x≡a} ⊢ x ≡ a$>;
  binary ~name:<$≡_{τ,τ}$> <$Σ,a:τ,x:ι \sp Γ,x:\f{a∈A};Ξ,{x≡a}⊢t:\f{B}$>;
  unary  ~name:<$∈_e$> <$Σ, a:τ, x:ι \sp Γ,x:A;Ξ,{x≡a} ⊢ t : B$>;
  unary  ~name:<$∈_e$> <$Σ, a:τ, x:ι \sp Γ,x:\f{a∈A};Ξ ⊢ t : B$>;
  unary  ~name:<$⇒_i$> <$Σ, a:τ \sp Γ;Ξ ⊢ \t{λx t} : \f{a∈A ⇒ B}$>;
  ax     ~name:<$⊤$>   <$Ξ ⊢ \t{λx t} ≡ \v{λx t}$>;
  binary ~name:<$∀_i$> <$Σ \sp Γ;Ξ ⊢ \t{λx t} : \f{∀a(a∈A ⇒ B)}$>;
  unary  ~name:<$Def$> <$Σ \sp Γ;Ξ ⊢ \t{λx t} : \f{Π_(a∈A) B}$>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
\linesAfter(4)

\begin{proofTree}
\Caml(
let p =
  hyp                  <$Σ \sp Γ;Ξ ⊢ \t{t} : \f{Π_(a∈A) B}$>;
  unary  ~name:<$Def$> <$Σ \sp Γ;Ξ ⊢ \t{t} : \f{∀a(a∈A ⇒ B)}$>;
  unary  ~name:<$∀_e$> <$Σ \sp Γ;Ξ ⊢ \t{t} : \f{u∈A ⇒ B[a≔u]}$>;
  hyp                  <$Σ \sp Γ;Ξ ⊢ \t{u} : \f{A}$>;
  hyp                  <$Ξ ⊢ u ≡ v$>;
  binary ~name:<$∀_e$> <$Σ \sp Γ;Ξ ⊢ \t{u} : \f{u∈A}$>;
  binary ~name:<$⇒_e$> <$Σ \sp Γ;Ξ ⊢ \t{t u} : \f{B[a≔u]}$>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}

\begin{rem}
Dually, it is possible to encode a form of dependent pair type using
existential quantification and product types. As for the dependent
functions, the membership predicate is used to bridge the world
of terms and the world of types.
$$
  \f{Σ_(x∈A) B} ≔ \f{∃x {l₁:x∈A; l₂:B}}
  \hspace(6.0)
  \f{Σ_(a∈A) B} ≔ \f{∃a {l₁:a∈A; l₂:B}}
$$
As dependent pair types are based on records (which can only contain
values in our system), their use is rather limited. It seems however
possible to rely on a dependent product type to obtain satisfactory
typing rules based on terms of the following form.
$$ \t{(λxλy{l₁=x;l₂=y;}) t₁ t₂} $$
\end{rem}

(*
$$
\binaryRN{Σ_{ι,i}}{Σ \sp Γ ; Ξ ⊢ v₁ : A}{Σ \sp Γ ; Ξ ⊢ v₂ : \f{B[y≔v₁]}}
  {Σ \sp Γ ; Ξ ⊢_\tval \v{{l₁ = v₁; l₂ = v₂}} : \f{Σ_(y∈A) B}}
$$
$$
\binaryRN{Σ_{τ,i}}{Σ \sp Γ ; Ξ ⊢ v₁ : A}{Σ \sp Γ ; Ξ ⊢ v₂ : \f{B[a≔v₁]}}
  {Σ \sp Γ ; Ξ ⊢_\tval \v{{l₁ = v₁; l₂ = v₂}} : \f{Σ_(a∈A) B}}
$$
*)

=<

=> Understanding our new equivalence

To better understand our new definition of equivalence, we can compare it
to another equivalence relation with a more intuitive definition. The
definition of this new relation, denoted $({≡}_{↠})$, will be very similar
to that of $({≡}_{≻})$ (see \chapter("obsEquiv")). It can be seen as the
observational equivalence induced by $({↠})$

\begin{def}
The relation $({≡}_{↠}) ⊆ Λ×Λ$ is defined as follows.
$$ ({≡}_{↠}) = \{(t,u) \| ∀π∈Π, ∀ρ∈\cal{S},
     {{\p{tρ∗π}} {⇓}_{↠}} ⇔ {{\p{uρ∗π}} {⇓}_{↠}} \} $$
\end{def}
\begin{lem}
The relation $({≡}_{↠}) ⊆ Λ×Λ$ is an equivalence relation.
\begin{proof}
Immediate.
\end{proof}
\end{lem}

\begin{thm}\label("eq_incl")
If $t$, $u∈Λ$ are two terms such that $t ≡ u$ then $t ≡_{↠} u$. In other
words, we have $({≡}) ⊆ ({≡}_{↠})$
\begin{proof}
Let us suppose that $t ≡ u$, take $π₀∈Π$ and take $ρ₀∈\cal{S}$. By
symmetry we can assume that ${\p{tρ₀∗π₀}} {⇓}_{↠}$ and show that
${\p{uρ₀∗π₀}} {⇓}_{↠}$. By definition there is $i₀∈\bbN$ such that
${\p{tρ₀∗π₀}} {⇓}_{i₀}$. Since $t ≡ u$ we know that for all $i∈\bbN$,
$π∈Π$ and $ρ∈\cal{S}$ we have
${{\p{tσ∗π}} {⇓}_i} ⇔ {{\p{uσ∗π}} {⇓}_i}$.
This is true in particular for $i = i₀$, $π = π₀$ and $ρ = ρ₀$. We
hence obtain ${\p{uρ₀∗π₀}} {⇓}_{i₀}$ which give us
${\p{uρ₀∗π₀}} {⇓}_{↠}$.
\end{proof}
\end{thm}
\begin{rem}
The converse implication is not true in general, that is we do not
have $({≡}) ⊇ ({≡}_{↠})$. A counter-example is given by the terms
$t = \t{δ(λx x, {})}$ and $u = \t{λx x}$ since $t ≡_{↠} u$ but
$t \nequiv_{≻} u$ (and thus $t \nequiv u$). More generally, if
$p$, $q ∈ Λ×Π$ are processes, having ${p {⇓}_{↠}} ⇒ {q {⇓}_{↠}}$
does not imply ${p {⇓}_i} ⇒ {q {⇓}_i}$ for every natural number
$i ∈ \bbN$.
\end{rem}
As shown by the \thmRef("eq_incl"), our $({≡})$ relation is more
fine-grained (i.e., it discriminates more terms than $({≡}_{↠})$).
However, its formulation does not really provide more intuition
on the behaviour of our equivalence relation. Indeed, the definition
of $({↠})$ still involves $({≡})$, an thus the definition of
$({≡}_{↠})$ is still very subtle, even if its statement remains
relatively simple.

In the end, what really matters to us is for our equivalence relation
to be compatible with the notion of reduction. And in fact, the only
part of the reduction relation that will matter in practice is $({≻})$.
Indeed, $δ$-like terms are only provided in the system for obtaining
a well-behaved semantics. In particular, we do not want to expose them
to the users of our implementation. It is thus enough for $({≡})$ to
be compatible with $({≡}_{≻})$.

\begin{rem}
Allowing the user to work with and reason about $δ$-like terms would
not be such a bad idea. Indeed, it could allow the encoding of
mathematical objects into pure terms of the language. In particular,
it would be interesting to investigate the possibility of using the
following alternative reduction rules for $δ$-like processes.
\Caml(
  let _ =
    let line p1 p2 c =
      (<<$\p(p1)$>>, <<$\p(p2)$>>, <<when $\id(c)$>>)
    in
    reduction_def <<$↠$>>
      [ line  "δ(v,w) ∗ π" "C₀[{}] ∗ π" <$v \nequiv w$>
      ; line  "δ(v,w) ∗ π" "C₁[{}] ∗ π" <$v ≡  w$> ]
)
They would allow the definition of non-computable functions in our
language by giving complete access to our equivalence relation.
This would allow, for example, the definition of functions like
$\t{λx λy δ(x,y)}$ (i.e., a general equality function).
\end{rem}

=<

=<
