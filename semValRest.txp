\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>
)
\Include{Macros}

=> A model for a semantical value restriction \label("semValRest")

In this chapter, we consider the encoding of dependent types (i.e. forms
of typed quantifications) into our system. However, the expressiveness of
such constructs is considerably limited by value restriction. To solve
this issue we introduce the notion of //semantical value restriction//,
which allows the system to accept many more programs. Obtaining a model
justifying //semantical value restriction// will require us to change our
notions or reduction and observational equivalence.

=> Dependent function types

As\label("encodedep")
discussed at the begining of \chapter("typeSystem"), it is possible
to encode a form of dependent types into our system using (untyped)
quantification and the membership predicate. The dependent function
types can be encoded as follows, and it may range over either values
or terms.
$$
  \f("Π_(x∈A) B") ≔ \f("∀x(x∈A ⇒ B)")
  \hspace(6.0)
  \f("Π_(a∈A) B") ≔ \f("∀a(a∈A ⇒ B)")
$$
To work with our dependent function types more easily, we can define
the corresponding introduction and elimination rules as follows.
$$
\unaryRN{Π_{ι,i}}{Σ, x : ι \sp Γ, x:A ; Ξ ⊢ t : B[y≔x]}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("λx t") : \f("Π_(y∈A) B")}
$$
$$
\unaryRN{Π_{τ,i}}{Σ, x : ι \sp Γ, x:A ; Ξ ⊢ t : B[a≔x]}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("λx t") : \f("Π_(a∈A) B")}
$$
$$
\binaryRN{Π_{ι,e}}{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(x∈A) B")}
  {Σ \sp Γ ; Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[x≔v]")}
$$
$$
\binaryRN{Π_{τ,e}}{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}
  {Σ \sp Γ ; Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[a≔v]")}
$$
Note that both elemination rules require value restriction on the
side of the argument. In other words, dependent functions can only
be applied to values.

The four new typing rules can immediatly be used to extend the type
system as they are all derivable. In particular, this means that we
do not have to extend our adequacy lemma (\thmRef("adequacy")). The
proofs for the derivation of the rules are given bellow.
$$
\proofTree{
  \unary{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("Π_(y∈A) B")}{
  \unaryN{∀_i}{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("∀y (y∈A ⇒ B)")}{
  \unaryN{⇒_i}{Σ, y:ι \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("y∈A ⇒ B")}{
  \unaryN{∈_e}{Σ, y:ι, x:ι \sp Γ, x : \f("y∈A"); Ξ ⊢ t : B}{
  \unaryN{≡_{τ,ι}}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ, x≡y ⊢ t : B}{
  \unaryN{Wk}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ, x≡y ⊢ t : \f("B[y≔x]")}{
  \unaryN{Wk}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[y≔x]")}{
    \hyp{Σ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[y≔x]")}
  }}}}}}}
}
$$
$$
\proofTree{
  \unary{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("Π_(a∈A) B")}{
  \unaryN{∀_i}{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("∀a (a∈A ⇒ B)")}{
  \unaryN{⇒_i}{Σ, a:τ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("a∈A ⇒ B")}{
  \unaryN{∈_e}{Σ, a:τ, x:ι \sp Γ, x : \f("a∈A"); Ξ ⊢ t : B}{
  \unaryN{≡_{τ,τ}}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ, x≡a ⊢ t : B}{
  \unaryN{Wk}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ, x≡a ⊢ t : \f("B[a≔x]")}{
  \unaryN{Wk}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[a≔x]")}{
    \hyp{Σ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[a≔x]")}
  }}}}}}}
}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[x≔v]")}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f("v∈A ⇒ B[x≔v]")}{
   \unary{Σ \sp Γ ; Ξ ⊢ t : \f("∀x (x∈A ⇒ B)")}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(x∈A) B")}
   }}
 }{
  \unaryN{↑}{Σ \sp Γ ; Ξ ⊢ v : \f("v∈A")}{
  \unaryN{∈_i}{Σ \sp Γ ; Ξ ⊢_\tval v : \f("v∈A")}{
    \hyp{Σ \sp Γ ; Ξ ⊢_\tval v : A}
  }}
 }
}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[a≔v]")}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f("v∈A ⇒ B[a≔v]")}{
   \unary{Σ \sp Γ ; Ξ ⊢ t : \f("∀a (a∈A ⇒ B)")}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}
   }}
 }{
  \unaryN{↑}{Σ \sp Γ ; Ξ ⊢ v : \f("v∈A")}{
  \unaryN{∈_i}{Σ \sp Γ ; Ξ ⊢_\tval v : \f("v∈A")}{
    \hyp{Σ \sp Γ ; Ξ ⊢_\tval v : A}
  }}
 }
}
$$
\begin{rem}
Note that in the typing rules we consider, the variable bound by the
dependent type (i.e. $x$ or $a$ respectively) does not appear free in
the type $A$. In fact, this restriction is not necessary, and we could
addapt our rules accordingly. However, the considered types would not
correspond to dependent functions anymore.
\end{rem}

Note that our encoding of the dependent products makes sense with
respect to the semantics. Indeed, their interpretation is similar to
the arrow type (i.e. non-dependent functions), but the type of the
body depends on the input. If the variable that is quantified over is
a value variable (i.e. a $λ$-variable) then we have
\begin{center}
\diagram(
let _ =
  let first e1 e2 = [ e1; <$=$>; e2 ] in
  let line e = [ []; <$=$>; e ] in
  array [`East ; `East ; `West]
  [ first <$\vs("Π_(x∈A) B")$> <$\vs("∀x (x∈A ⇒ B)")$>
  ; line <$\biginter_{Φ∈⟦ι⟧} \vs("Φ∈A ⇒ B[x≔Φ]")$>
  ; line <$\biginter_{Φ∈⟦ι⟧} \{\v("λx t") \| ∀v∈\vs("Φ∈A"),
      \t("t[x≔v]") ∈ \ts("B[x≔Φ]")\}$>
  ; line <$\{\v("λx t") \| ∀Φ∈⟦ι⟧, ∀v∈\vs("Φ∈A"),
      \t("t[x≔v]") ∈ \ts("B[x≔Φ]")\}$>
  ; line <$\{\v("λx t") \| ∀Φ∈⟦ι⟧, ∀v∈\{w ∈ \vs("A") \| w ≡_{≻} Φ\},
      \t("t[x≔v]") ∈ \ts("B[x≔Φ]")\}$>
  ; line <$\{\v("λx t") \| ∀v∈\vs("A"), \t("t[x≔v]") ∈ \ts("B[x≔v]")\}$> ]
)
\end{center}
and similarly, we have
$$
  \vs("Π_(a∈A) B") = \{\v("λx t") \|
    ∀v∈\vs("A"), \t("t[x≔v]") ∈ \ts("B[x≔v]")\}
$$
if we quantify over a term variable.

(* TODO from here *)

=<

=> The limits of value restriction

In languages like ||OCaml||, value restriction is not an issue. As it is
only required on the typing rule for polymorphism, programmers almost never
notice it as they mostly define functions (which are values). Moreover, if
a problematic instance of value restriction is encountered, one can always
use a dummy $λ$-abstraction (or an $η$-expension) to transform a term into
a value.

$$\v("w") = \v("λx [x | Z[_] → S[Z[{}]] | S[_] → [α]λ_ Z[{}]]")$$
$$\t("t")  = \v("λf ((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (f Z[{}]))) (f S[Z[{}]])")$$

\begin{env}(scale 0.6)
\begin{center}
\linesBefore(4)
\diagram(
let _ =
  let line s = [ []; <$≻$>; <$\p(s)$> ] in
  array [`East ; `East ; `West]
  [ [ <$\p("t (μα w) ∗ ε")$>; <$≻$>; <$\p("μα w ∗ [t] ε")$> ]
  ; line "w[α≔[t]ε] ∗ [t] ε"
  ; line "t ∗ w[α≔[t]ε] · ε"
  ; line "((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (w[α≔[t]ε] Z[{}]))) (w[α≔[t]ε] S[Z[{}]]) ∗ ε"
  ; line "w[α≔[t]ε] S[Z[{}]] ∗ [((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (w[α≔[t]ε] Z[{}])))] ε"
  ; line "S[Z[{}]] ∗ [w[α≔[t]ε]] [((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (w[α≔[t]ε] Z[{}])))] ε"
  ; line "w[α≔[t]ε] ∗ S[Z[{}]] · [((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (w[α≔[t]ε] Z[{}])))] ε"
  ; line "[S[Z[{}]] | Z[_] → S[Z[{}]] | S[_] → [[t]α]λ_ Z[{}]] ∗ [((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (w[α≔[t]ε] Z[{}])))] ε"
  ; line "[[t]α]λ_ Z[{}] ∗ [((λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) (w[α≔[t]ε] Z[{}])))] ε"
  ; line "λ_ Z[{}] ∗ [t]ε"
  ; line "(λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}])) ((λ_ Z[{}]) S[Z[{}]]) ∗ ε"
  ; line "(λ_ Z[{}]) S[Z[{}]] ∗ [λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}])] ε"
  ; line "S[Z[{}]] ∗ [λ_ Z[{}]] [λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}])] ε"
  ; line "λ_ Z[{}] ∗ S[Z[{}]] · [λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}])] ε"
  ; line "Z[{}] ∗ [λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}])] ε"
  ; line "λ_ (λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}]) ∗ Z[{}] · ε"
  ; line "(λy [y | Z[_] → C₁[S[Z[{}]]] | S[_] → C₀[Z[{}]]]) ((λ_ Z[{}]) Z[{}]) ∗ ε"
  ; line "(λ_ Z[{}]) Z[{}] ∗ [λy [y | Z[_]→C₁[S[Z[{}]]] | S[_]→C₀[Z[{}]]]] ε"
  ; line "Z[{}] ∗ [λ_ Z[{}]] [λy [y | Z[_]→C₁[S[Z[{}]]] | S[_]→C₀[Z[{}]]]] ε"
  ; line "λ_ Z[{}] ∗ Z[{}] · [λy [y | Z[_]→C₁[S[Z[{}]]] | S[_]→C₀[Z[{}]]]] ε"
  ; line "Z[{}] ∗ [λy [y | Z[_]→C₁[S[Z[{}]]] | S[_]→C₀[Z[{}]]]] ε"
  ; line "λy [y | Z[_]→C₁[S[Z[{}]]] | S[_]→C₀[Z[{}]]] ∗ Z[{}] · ε"
  ; line "[Z[{}] | Z[_]→C₁[S[Z[{}]]] | S[_]→C₀[Z[{}]]] ∗ ε"
  ; line "C₁[S[Z[{}]]] ∗ ε"
  ]
)
\end{center}
\end{env}
We can show that
$\id([]) ⊢ \t("t (μα w)") : \f("[C₀ : Z[{}]∈A | C₁ : A|(μα w) Z[{}] ≡ Z[{}]]")$,
but we have $⟦\f("A | (μα w) Z[{}] ≡ Z[{}]")⟧ = ∅$ as
$\t("(μα w) Z[{}]") \nequiv_{≻} \t("Z[{}]")$ since
$\p("(μα w) Z[{}] ∗ π") ≻^{∗} \p("S[Z[{}]] ∗ π")$ for all stack $π$ and
obviously $\v("Z[{}]") \nequiv_{≻} \v("S[Z[{}]]")$.

(* TODO *)

=<

=> Reduction, equivalence and $\t("δ(v,w)")$

The idea now is to define a notion of observational equivalence over terms
using a relation $({≡})$. We then extend the reduction relation with a rule
reducing a state of the form $\p("δ(v,w) ∗ π")$ to $\p("v ∗ π")$ if
$v \nequiv w$. If $v ≡ w$ then $\p("δ(v,w) ∗ π")$ is stuck. With such a
reduction rule, the definitions of reduction and equivalence become
interdependent. Consequently, we need to be very careful when changing
our definitions so that everything remains well-defined. We will rely on
a stratified construction of both reduction and equivalence.
\begin{def}
For every $i ∈ \bbN$ we define two relations $({↠}_i)$ and $({≡}_i)$
as follows.
$$ ({↠}_i) = ({≻}) ∪ \{(\p("δ(v,w) ∗ π"), \p("v ∗ π")) \st ∃j < i,
   v \nequiv_j w\} $$
$$ ({≡}_i) = \{(t,u) \st ∀j ≤ i, ∀π, ∀σ,
   {{\p("tσ∗π")} {⇓}_j} ⇔ {{\p("uσ∗π")} {⇓}_j}\} $$
\end{def}
\begin{rem}
Note that $({↠}₀) = ({≻})$ since there is no $j < 0$.
\end{rem}
\begin{thm}\label("isequiv")
For every $i ∈ \bbN$, the relation $({≡}_i)$ is an equivalence relation.
\begin{proof}
Immediate.
\end{proof}
\end{thm}

We can then define our actual reduction relation and equivalence relation
as a union and an intersection over the previously defined relations.
\begin{def}
We define a reduction relation $({↠})$ and an equivalence relation $({≡})$.
$$
  ({↠}) = \bigcup_{i∈\bbN} ({↠}_i)
  \hspace(4.0)
  ({≡}) = \bigcap_{i∈\bbN} ({≡}_i)
$$
\end{def}
\begin{thm}
The relation $({≡})$ is an equivalence relation.
\begin{proof}
Immediate using \lemRef("isequiv") since an intersection of equivalence
relation is an equivalence relation.
\end{proof}
\end{thm}

These relations can be expressed directly (i.e. without the need of a
union or an intersection) in the following way.
\begin{center}
\diagram(
let _ =
  let line e1 e2 = [ e1 ; <$=$> ; e2 ] in
  array [`East ; `Main ; `West]
  ~horizontal_padding:(function 1 -> 5.0 | _ -> 4.0) (* Fix *)
  [ line <$({≡})$>
      <$ \{(t,u) \st ∀i, ∀π, ∀σ,
         {{\p("tσ∗π")} {⇓}_i} ⇔ {{\p("uσ∗π")} {⇓}_i}\} $>
  ; line <$({\nequiv})$>
      <$ \{(t,u), (u,t) \st ∃i, ∃π, ∃σ,
         {{\p("tσ∗π")} {⇓}_i} ∧ {{\p("uσ∗π")} {⇑}_i}\}$>
  ; line <$({↠})$>
      <$({≻}) ∪ \{(\p("δ(v,w)∗π"), \p("v∗π")) \st v \nequiv w\}$> ]
)
\linesAfter(2)
\end{center}

\begin{rem}
Obviously $({↠}_i) ⊆ ({↠}_{i+1})$ and $({≡}_{i+1}) ⊆ ({≡}_i)$. As a
consequence the construction of $({↠}_i)_{i∈\bbN}$ and $({≡}_i)_{i∈\bbN}$
converges. In fact $({↠})$ and $({≡})$ form a fixpoint at ordinal $ω$.
Surprisingly, this property is not explicitly required here.
\end{rem}

\begin{thm}\label("equivpole")
Let $t$ and $u$ be terms. If $t ≡ u$ then for every stack $π ∈ Π$ and
substitution $σ$ we have ${{\p("tσ∗π")} {⇓}_{↠}} ⇔ {{\p("uσ∗π")} {⇓}_{↠}}$.
\begin{proof}
We suppose that $t ≡ u$ and we take $π₀ ∈ Π$ and a substitution $σ₀$. By
symmetry we can assume that ${\p("tσ₀∗π₀")} {⇓}_{↠}$ and show that
${\p("uσ₀∗π₀")} {⇓}_{↠}$. By definition there is $i₀ ∈ \bbN$ such that
${\p("tσ₀∗π₀")} {⇓}_{i₀}$. Since $t ≡ u$ we know that for every $i ∈ \bbN$,
$π ∈ Π$ and substitution $σ$ we have
${{\p("tσ∗π")} {⇓}_i} ⇔ {{\p("uσ∗π")} {⇓}_i}$. This is true in particular
for $i = i₀$, $π = π₀$ and $σ = σ₀$. We hence obtain
${\p("uσ₀∗π₀")} {⇓}_{i₀}$ which give us ${\p("uσ₀∗π₀")} {⇓}_{↠}$.
\end{proof}
\end{thm}

\begin{rem}
The converse implication is not true in general: taking
$t = \t("δ(λx x, {})")$ and $u = \t("λx x")$ gives a counter-example.
More generally ${p {⇓}_{↠}} ⇒ {q {⇓}_{↠}}$ does not necessarily imply
${p {⇓}_i} ⇒ {q {⇓}_i}$ for all $i ∈ \bbN$.
\end{rem}
\begin{cor}\label("eqconvconv")
Let $t$ and $u$ be terms and $π$ be a stack. If $t ≡ u$ and
${\p("t∗π")} {⇓}_{↠}$ then ${\p("u∗π")} {⇓}_{↠}$.
\begin{proof}
Direct consequence of \thmRef("equivpole") using $π$ and an empty
substitution.
\end{proof}
\end{cor}

=<

=> Extensionality of equivalence

In order to be able to work with the equivalence relation $({≡})$, we
need to check that it is extensional. In other words, we need to be able
to replace equals by equals at any place in terms without changing their
observed behaviour. This property is summarized in the following two
theorems.

\begin{thm}\label("extval")
Let $v$ and $w$ be values, $t$ be a term and $x$ be a $λ$-variable. If
$v ≡ w$ then we have $\t("t[x≔v]") ≡ \t("t[x≔w]")$.
\begin{proof}
We are going to prove the contrapositive so we suppose
$\t("t[x≔v]") \nequiv \t("t[x≔w]")$ and show $v \nequiv w$. By definition
there is a natural number $i$, a stack $π$ and a substitution $σ$ such that
we have ${\p("(t[x≔v])σ ∗ π")} {\converge}_i$ and
${\p("(t[x≔w])σ ∗ π")} {\diverge}_i$ (up to symmetry).
Since we can rename $x$ in such a way that it does not appear in $dom(σ)$,
we can suppose that we have ${\p("tσ[x≔vσ] ∗ π")} {\converge}_i$ and
${\p("tσ[x≔wσ] ∗ π")} {\diverge}_i$. To show $v \nequiv w$ we need $i₀$,
$π₀$ and $σ₀$ such that ${\p("vσ₀ ∗ π")₀} {\converge}_{i₀}$ and
${\p("wσ₀ ∗ π₀")} {\diverge}_{i₀}$ (up to symmetry). We take
$i₀ = i$, $π₀ = \s("[λx tσ]π")$ and $σ₀ = σ$ as
${\p("vσ₀ ∗ [λx tσ]π") \epi \p("tσ[x≔vσ] ∗ π")}_i$ and
${\p("wσ₀ ∗ [λx tσ]π") \epi \p("tσ[x≔wσ] ∗ π")}_i$.
\end{proof}
\end{thm}

(* TODO macros from here *)
\begin{lem}\label("aposs")
Let $s$ be a process, $t$ be a term, $a$ be a term variable and $k$ be a
natural number. If $s[a := t] {\converge}_k$ then there is a blocked state
$p$ such that ${s ≻ p}^{∗}$ and either
\begin{itemize}
\item $p = v ∗ α$ for some value $v$ and a stack variable $α$,
\item $p = a ∗ π$ for some stack $π$,
\item $k > 0$ and $p = δ(v,w) ∗ π$ for some values $v$ and $w$ and
      stack $π$, and in this case $v[a := t] \nequiv_j w[a := t]$ for
      some $j < k$.
\end{itemize}
\begin{proof}
Let $σ$ be the substitution $[a := t]$. If $s$ is non-terminating,
\lemRef("redstable") tells us that $sσ$ is also non-terminating, which
contradicts $sσ {\converge}_k$. Consequently, there is a blocked process
$p$ such that ${s ≻ p}^{∗}$ since $({≻}) ⊆ ({\epi}_k)$.
(* *)
Using \thmRef("redcompatall") we get ${sσ ≻ pσ}^{∗}$ from which we obtain
$pσ {\converge}_k$. The process $p$ cannot be stuck, otherwise $pσ$ would
also be stuck by \lemRef("redstable"), which would contradict
$pσ {\converge}_k$. Let us now suppose that $p = δ_{v,w} ∗ π$ for some
values $v$ and $w$ and some stack $π$. Since $δ_{vσ,wσ} ∗ π {\converge}_k$
there must be $i < k$ such that $vσ \nequiv_j wσ$, otherwise this would
contradict $δ_{vσ,wσ} ∗ π {\converge}_k$. In this case we necessarily
have $k > 0$, otherwise there would be no possible candidate for $i$.
According to \lemRef("possibilities") we need to rule out four more forms
of therms: $x.l ∗ π$, $x ∗ v.π$, $case_x B ∗ π$ and $b ∗ π$ in the case
where $b ≠ a$. If $p$ was of one of these forms the substitution $σ$ would
not be able to unblock the reduction of $p$, which would contradict again
$pσ {\converge}_k$.
\end{proof}
\end{lem}

\begin{lem}\label("aextlem")
Let $t₁$, $t₂$ and $E$ be terms and $a$ be a term variable. For every
$k ∈ \bbN$, if $t₁ ≡_k t₂$ then $E[a := t₁] ≡_k E[a := t₂]$.
\begin{proof}
Let us take $k ∈ \bbN$, suppose that ${t₁ ≡ t₂}_k$ and show that
$E[a := t₁] ≡_k E[a := t₁]$. By symmetry we can assume that we have
$i ≤ k$, $π ∈ Π$ and a substitution $σ$ such that $(E[a := t₁])σ ∗ π 
{\converge}_i$ and show that $(E[a := t₂])σ ∗ π {\converge}_i$. As we are
free to rename $a$, we can suppose that it does not appear in $dom(σ)$,
$TV(π)$, $TV(t₁)$ or $TV(t₂)$. In order to lighten the notations we define
$E' = Eσ$, $σ₁ = [a := t₁σ]$ and $σ₂ = [a := t₂σ]$. We are hence assuming
$E'σ₁ ∗ π {\converge}_i$ and trying to show $E'σ₂ ∗ π {\converge}_i$.

We will now build a sequence $(E_i,π_i,l_i)_{i ∈ I}$ such that
${{E'σ₁ ∗ π} \epi {E_iσ₁ ∗ π_iσ₁}}_k$ in $l_i$ steps for every $i ∈ I$.
Furthermore, we require that $(l_i)_{i ∈ I}$ is increasing and that it has
a strictly increasing subsequence. Under this condition our sequence will
be finite. If it was infinite the number of reduction steps that could be
taken from $E'σ₁ ∗ π$ would not be bounded, which would contradict
$E'σ₁ ∗ π {\converge}_i$. We now denote our finite sequence
$(E_i,π_i,l_i)_{i ≤ n}$ with $n ∈ \bbN$. To show that
$(l_i)_{i ≤ n}$ has a strictly increasing subsequence, we will ensure that
it does not have three equal consecutive values. More formally, we will
require that if $0 < i < n$ and $l_{i-1} = l_i$ then $l_{i+1} > l_i$.

To define $(E₀,π₀,l₀)$ we consider the reduction of $E' ∗ π$. Since we know
that we have $(E' ∗ π)σ₁ = E'σ₁ ∗ π {\converge}_i$ we use \lemRef("aposs")
to obtain a blocked state $p$ such that ${{E' ∗ π} ≻ p}^j$. We can now take
$E₀ ∗ π₀ = p$ and $l₀ = j$. By \thmRef("redcompatall") we have ${(E' ∗ π)σ₁
≻ {E₀σ₁ ∗ π₀σ₁}}^j$ from which we can deduce that ${(E' ∗ π)σ₁ \epi {E₀σ₁ ∗
π₀σ₁}}_k$ in $l₀ = j$ steps.

To define $(E_{i+1},π_{i+1},l_{i+1})$ we consider the process $E_iσ₁ ∗ π_i$.
By construction we know that ${{E'σ₁ ∗ π} \epi {E_iσ₁ ∗ π_iσ₁}}_k = (E_iσ₁ ∗
π_i)σ₁$ in $l_i$ steps. Using \lemRef("aposs"), we obtain that the process
$E_i ∗ π_i$ can be of three different shapes.
\begin{itemize}
\item If ${E_i ∗ π_i} = {v ∗ α}$ for some value $v$ and stack variable $α$
      then the end of the sequence was reached with $n = i$.
\item If $E_i = a$ then we consider the reduction of $E_iσ₁ ∗ π_i$. Since
      $(E_iσ₁ ∗ π_i)σ₁ {\converge}_k$ we know from \lemRef("aposs") that
      there is a blocked process $p$ such that ${{E_iσ₁ ∗ π_i} ≻ p}^j$.
      Using \thmRef("redcompatall") we obtain ${{E_iσ₁ ∗ π_iσ₁} ≻ pσ₁}^j$
      from which we can deduce that ${{E_iσ₁ ∗ π_iσ₁} \epi pσ₁}_k$ in $j$
      steps. We then take $E_{i+1} ∗ π_{i+1} = p$ and $l_{i+1} = l_i + j$.

      Is it possible to have $j=0$? This can only happen when $E_iσ₁ ∗ π_i$
      is of one of the three forms of \lemRef("aposs"). It cannot be of the
      form $a ∗ π$ as we assumed that $a$ does not appear in $t₁$ or $σ$.
      If it is of the form $v ∗ α$, then we reached the end of the sequence
      with $i + 1 = n$ so there is no problem. In the case where the process
      $E_iσ₁ ∗ π_i$ is of the form $δ(v,w) ∗ π$, but we will have $l_{i+2} >
      l_{i+1}$.
\item If $E_i = δ(v,w)$ for some values $v$ and $w$ we have $m < k$ such
      that ${vσ₁ \nequiv wσ₁}_m$. Hence ${{E_iσ₁ ∗ π_i = δ(vσ₁,wσ₁) ∗ π_i}
      \epi {vσ₁ ∗ π_i}}_k$ by definition. Moreover, we know that
      ${{E_iσ₁ ∗ π_iσ₁} \epi {vσ₁ ∗ π_iσ₁}}_k$ by \thmRef("redcompatall").
      Since ${{E'σ₁ ∗ π} \epi
      {E_iσ₁ ∗ π_iσ₁}}_k^{∗}$ in $l_i$ steps we get that ${{E'σ₁ ∗ π}
      \epi {vσ₁ ∗ π_iσ₁}}_k^{∗}$ in $l_i + 1$ steps, and hence
      ${(vσ₁ ∗ π_i)σ₁ = vσ₁ ∗ π_iσ₁} {\converge}_k$.
      
      We now consider the reduction of the process $vσ₁ ∗ π_i$. By
      \lemRef("aposs") there is a blocked process $p$ such that
      ${{vσ₁ ∗ π_i} ≻ p}^j$. Using \thmRef("redcompatall") we obtain
      ${{vσ₁ ∗ π_iσ₁} ≻ pσ₁}^j$ from which we deduce that ${{vσ₁ ∗ π_iσ₁}
      \epi pσ₁}_k^{∗}$ in $j$ steps. We then take $E_{i+1} ∗ π_{i+1} = p$
      and $l_{i+1} = l_i + j + 1$. Note that in this case we have $l_{i+1}
      > l_i$.
\end{itemize}
Intuitively $(E_i,π_i,l_i)_{i ≤ n}$ mimics the reduction of $E'σ₁ ∗ π$ while
making explicit every substitution of $a$ and every reduction of a $δ$-like
state.

To end the proof we show that for every $i ≤ n$ we have ${E_iσ₂ ∗ π_iσ₂}
{\converge}_k$. For $i = 0$ this will give us ${E'σ₂ ∗ π} {\converge}_k$,
which is the expected result. Since $E_n ∗ π_n = v ∗ α$ we have $E_nσ₂ ∗
π_nσ₂ = vσ₂ ∗ α$ from which we trivially obtain ${E_nσ₂ ∗ π_nσ₂}
{\converge}_k$. We now suppose that ${E_{i+1}σ₂ ∗ π_iσ₂} {\converge}_k$ for
$0 ≤ i < n$ and show that ${E_iσ₂ ∗ π_iσ₂} {\converge}_k$. By construction
$E_i ∗ π_i$ can be of two shapes since only $E_n ∗ π_n$ can be of the form
$v ∗ α$.
\begin{itemize}
\item If $E_i = a$ then ${{t₁σ ∗ π_i} \epi {E_{i+1} ∗ π_{i+1}}}_k^{∗}$. by
      \thmRef("redcompatall") we get ${{t₁σ ∗ π_iσ₂} \epi {E_{i+1}σ₂ ∗
      π_iσ₂}}_k$ from which we deduce ${t₁σ ∗ π_iσ₂}
      {\converge}_k$ by induction hypothesis. Since ${t₁ ≡ t₂}_k$ we obtain
      ${t₂σ ∗ π_iσ₂ = (E_i ∗ π_i)σ₂} {\converge}_k$.
\item If $E_i = δ(v,w)$ then ${{v ∗ π_i} \epi {E_{i+1} ∗ π_{i+1}}}_k$ and
      hence ${{vσ₂ ∗ π_iσ₂} \epi {E_{i+1}σ₂ ∗ π_{i+1}σ₂}}_k$ by
      \thmRef("redcompatall"). Using the induction hypothesis we obtain
      ${vσ₂ ∗ π_iσ₂} {\converge}_k$. It remains to show that
      ${{δ(vσ₂,wσ₂) ∗ π_iσ₂} \epi {vσ₂ ∗ π_iσ₂}}_k^{∗}$. We need to find
      $j < k$ such that ${vσ₂ \nequiv wσ₂}_j$. By construction there is
      $m < k$ such that ${vσ₁ \nequiv wσ₁}_m$. We are going to show that
      ${vσ₂ \nequiv wσ₂}_m$. By using the global induction hypothesis twice
      we obtain ${vσ₁ ≡ vσ₂}_m$ and ${wσ₁ ≡ vσ₂}_m$. Now if ${vσ₂ ≡ wσ₂}_m$
      then ${{vσ₁ ≡ vσ₂}_m ≡ {wσ₂ ≡ wσ₁}_m}_m$ contradicts
      $vσ₁ \nequiv wσ₁$. Hence we must have ${vσ₂ \nequiv wσ₂}_m$.
\end{itemize}
\end{proof}
\end{lem}

\begin{thm}\label("extterm")
Let $t₁$, $t₂$ and $E$ be three terms and $a$ be a term variable. If
$t₁ ≡ t₂$ then $E[a := t₁] ≡ E[a := t₂]$.
\begin{proof}
We suppose that $t₁ ≡ t₂$ which means that ${t₁ ≡ t₂}_i$ for every
$i ∈ \bbN$. We need to show that $E[a := t₁] ≡ E[a := t₂]$ so we take
$i₀ ∈ \bbN$ and show ${E[a := t₁] ≡ E[a := t₂]}_{i₀}$. By hypothesis we
have ${t₁ ≡ t₂}_{i₀}$ and hence we can conclude using \lemRef("aextlem").
\end{proof}
\end{thm}

=<
=> Derived type system

\Caml(
let r1 =
  <<$\axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Ξ ⊢ \t("x") : A; Δ)}$>>

let r3 =
  <<$\unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Ξ ⊢ \t("t") : B; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \v("λx t") : A ⇒ B; Δ)}$>>

let r4 =
  <<$\binaryRN{⇒_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : A ⇒ B; Δ)}{Σ ⊢ (Γ;Ξ ⊢ \t("u") : A; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t u") : B; Δ)}$>>

let r5 =
  <<$\unaryRN{μ}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("μα t") : A; Δ)}$>>

let r6 =
  <<$\unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
   {Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("[α]t") : B; Δ,α:A)}$>>

(* FIXME add semantical value restriction *)
let r7 =
  <<$\unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Ξ ⊢ \v("v") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("∀χ^s A");Δ)}$>>

let r8 =
  <<$\binaryRN{∀_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∀χ^s A");Δ)}{Σ ⊢ B : s}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]");Δ)}$>>

let r9 =
  <<$\binaryRN{∃_i}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ≔B]");Δ)}{Σ ⊢ B : s}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∃χ^s A");Δ)}$>>

let rA =
  <<$\binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Ξ ⊢ \t("t") : \f("C");Δ)}
   {Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Ξ ⊢ \t("t") : \f("C");Δ)}$>>

(* FIXME add semantical value restriction *)
let rB =
  <<$\unaryRN{∈_i}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("v∈A");Δ)}$>>

let rC =
  <<$\unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,x≡t ⊢ \t("t") : C;Δ)}
   {Σ, x:ι ⊢ (Γ,x:\f("t∈A");Ξ ⊢ \t("t") : C;Δ)}$>>

let rD =
  <<$\unaryRN{↾_i}{Σ ⊢ (Γ;Ξ,t≡u ⊢ \t("t") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A | t≡u");Δ)}$>>

let rE =
  <<$\unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,t≡u ⊢ \t("t") : C;Δ)}
   {Σ, x:ι ⊢ (Γ,x:\f("A | t≡u");Ξ ⊢ \t("t") : C;Δ)}$>>

let rF =
  <<$\unaryRN{×_i}{[Σ ⊢ (Γ;Ξ ⊢ \v("vi") : \f("Ai");Δ)]_{i∈I}}
   {Σ ⊢ (Γ;Ξ ⊢ \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}");Δ)}$>>

let rG =
  <<$\binaryRN{×_e}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("{(li : Ai) i∈I}");Δ)}
   {k∈I}{Σ ⊢ (Γ;Ξ ⊢ \t("v.lk") : A_k;Δ)}$>>

let rH =
  <<$\binaryRN{+_i}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("Ak");Δ)}{k∈I}
   {Σ ⊢ (Γ;Ξ ⊢ \v("Ck[v]") : \f("[(Ci : Ai) i∈I]");Δ)}$>>

let rI =
  <<$\binaryRN{+_e}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("[(Ci : Ai) i∈I]");Δ)}
   {[Σ ⊢ (Γ,x_i:A_i;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B;Δ)]_{i∈I}}
   {Σ ⊢ (Γ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B;Δ)}$>>

let rJ =
  <<$\unaryRN{≡_{l, {val}}}{Σ ⊢ (Γ;Ξ,v≡w ⊢ \t("t[x≔v]") : A;Δ)}
   {Σ ⊢ (Γ;Ξ,v≡w ⊢ \t("t[x≔w]") : A;Δ)}$>>

let rK =
  <<$\unaryRN{≡_{l}}{Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A;Δ)}
   {Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A;Δ)}$>>

let rL =
  <<$\unaryRN{≡_{r, {val}}}{Σ ⊢ (Γ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₁]");Δ)}
   {Σ ⊢ (Γ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₂]");Δ)}$>>

let rM =
  <<$\unaryRN{≡_{r}}{Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]");Δ)}
   {Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]");Δ)}$>>

let rs env =
  let env = resize_env 3.4 env in
  let rs =
    [ [ r1 ; r3 ] ; [ r4 ] ; [ r5 ; r6 ] ; [ r7 ; rA ] ; [ r8 ; r9 ]
    ; [ rB ; rC ] ; [ rD ; rE ] ; [ rG ; rH ] ; [ rF ] ; [ rI ] ; [ rJ ; rK ]
    ; [ rL ; rM ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let _ = figure_here ~name:"sortrules" ~caption:[tT "Typing rules."] (dr rs)
)

(* ADEQUACY CASE
\item If the last used rule is ($↓$) then we need to show
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ |\f("Aρ")|$, hence we can conclude using
      \thmRef("orthonew").
      \begin{center}
        $ \unaryRN{↓}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)} $
      \end{center}
*)

=<

=> Dependent pair types

(* TODO *)
$$
  \f("Σ_(x∈A) B") ≔ \f("∃x {l₁:x∈A; l₂:B}")
  \hspace(6.0)
  \f("Σ_(a∈A) B") ≔ \f("∃a {l₁:a∈A; l₂:B}")
$$

$$
\binaryRN{Σ_{ι,i}}{Σ \sp Γ ; Ξ ⊢ v₁ : A}{Σ \sp Γ ; Ξ ⊢ v₂ : \f("B[y≔v₁]")}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("{l₁ = v₁; l₂ = v₂}") : \f("Σ_(y∈A) B")}
$$
$$
\binaryRN{Σ_{τ,i}}{Σ \sp Γ ; Ξ ⊢ v₁ : A}{Σ \sp Γ ; Ξ ⊢ v₂ : \f("B[a≔v₁]")}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("{l₁ = v₁; l₂ = v₂}") : \f("Σ_(a∈A) B")}
$$

=<

=<
