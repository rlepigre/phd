\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>
)
\Include{Macros}

=> A model for a semantical value restriction \label("semValRest")

In this chapter, we consider the encoding of dependent types (i.e. forms
of typed quantifications) into our system. However, the expressiveness of
such constructs is considerably limited by value restriction. To solve
this issue we introduce the notion of //semantical value restriction//,
which allows the system to accept many more programs. Obtaining a model
justifying //semantical value restriction// will require us to change our
notions or reduction and observational equivalence.

=> Dependent function types

As\label("encodedep")
discussed at the begining of \chapter("typeSystem"), it is possible
to encode a form of dependent types into our system using (untyped)
quantification and the membership predicate. The dependent function
types can be encoded as follows, and it may range over either values
or terms.
$$
  \f("Π_(x∈A) B") ≔ \f("∀x(x∈A ⇒ B)")
  \hspace(6.0)
  \f("Π_(a∈A) B") ≔ \f("∀a(a∈A ⇒ B)")
$$
To work with our dependent function types more easily, we can define
the corresponding introduction and elimination rules as follows.
$$
\unaryRN{Π_{ι,i}}{Σ, x : ι \sp Γ, x:A ; Ξ ⊢ t : B[y≔x]}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("λx t") : \f("Π_(y∈A) B")}
$$
$$
\unaryRN{Π_{τ,i}}{Σ, x : ι \sp Γ, x:A ; Ξ ⊢ t : B[a≔x]}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("λx t") : \f("Π_(a∈A) B")}
$$
$$
\binaryRN{Π_{ι,e}}{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(x∈A) B")}
  {Σ \sp Γ ; Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[x≔v]")}
$$
$$
\binaryRN{Π_{τ,e}}{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}
  {Σ \sp Γ ; Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[a≔v]")}
$$
Note that both elemination rules require value restriction on the
side of the argument. In other words, dependent functions can only
be applied to values.

The four new typing rules can immediatly be used to extend the type
system as they are all derivable. In particular, this means that we
do not have to extend our adequacy lemma (\thmRef("adequacy")). The
proofs for the derivation of the rules are given bellow.
$$
\proofTree{
  \unary{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("Π_(y∈A) B")}{
  \unaryN{∀_i}{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("∀y (y∈A ⇒ B)")}{
  \unaryN{⇒_i}{Σ, y:ι \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("y∈A ⇒ B")}{
  \unaryN{∈_e}{Σ, y:ι, x:ι \sp Γ, x : \f("y∈A"); Ξ ⊢ t : B}{
  \unaryN{≡_{τ,ι}}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ, x≡y ⊢ t : B}{
  \unaryN{Wk}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ, x≡y ⊢ t : \f("B[y≔x]")}{
  \unaryN{Wk}{Σ, y:ι, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[y≔x]")}{
    \hyp{Σ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[y≔x]")}
  }}}}}}}
}
$$
$$
\proofTree{
  \unary{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("Π_(a∈A) B")}{
  \unaryN{∀_i}{Σ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("∀a (a∈A ⇒ B)")}{
  \unaryN{⇒_i}{Σ, a:τ \sp Γ; Ξ ⊢_\tval \v("λx t") : \f("a∈A ⇒ B")}{
  \unaryN{∈_e}{Σ, a:τ, x:ι \sp Γ, x : \f("a∈A"); Ξ ⊢ t : B}{
  \unaryN{≡_{τ,τ}}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ, x≡a ⊢ t : B}{
  \unaryN{Wk}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ, x≡a ⊢ t : \f("B[a≔x]")}{
  \unaryN{Wk}{Σ, a:τ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[a≔x]")}{
    \hyp{Σ, x:ι \sp Γ, x : A; Ξ ⊢ t : \f("B[a≔x]")}
  }}}}}}}
}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[x≔v]")}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f("v∈A ⇒ B[x≔v]")}{
   \unary{Σ \sp Γ ; Ξ ⊢ t : \f("∀x (x∈A ⇒ B)")}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(x∈A) B")}
   }}
 }{
  \unaryN{↑}{Σ \sp Γ ; Ξ ⊢ v : \f("v∈A")}{
  \unaryN{∈_i}{Σ \sp Γ ; Ξ ⊢_\tval v : \f("v∈A")}{
    \hyp{Σ \sp Γ ; Ξ ⊢_\tval v : A}
  }}
 }
}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[a≔v]")}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f("v∈A ⇒ B[a≔v]")}{
   \unary{Σ \sp Γ ; Ξ ⊢ t : \f("∀a (a∈A ⇒ B)")}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}
   }}
 }{
  \unaryN{↑}{Σ \sp Γ ; Ξ ⊢ v : \f("v∈A")}{
  \unaryN{∈_i}{Σ \sp Γ ; Ξ ⊢_\tval v : \f("v∈A")}{
    \hyp{Σ \sp Γ ; Ξ ⊢_\tval v : A}
  }}
 }
}
$$
\begin{rem}
Note that in the typing rules we consider, the variable bound by the
dependent type (i.e. $x$ or $a$ respectively) does not appear free in
the type $A$. In fact, this restriction is not necessary, and we could
addapt our rules accordingly. However, the considered types would not
correspond to dependent functions anymore.
\end{rem}

Note that our encoding of the dependent products makes sense with
respect to the semantics. Indeed, their interpretation is similar to
the arrow type (i.e. non-dependent functions), but the type of the
body depends on the input. If the variable that is quantified over is
a value variable (i.e. a $λ$-variable) then we have
\begin{center}
\diagram(
let _ =
  let first e1 e2 = [ e1; <$=$>; e2 ] in
  let line e = [ []; <$=$>; e ] in
  array [`East ; `East ; `West]
  [ first <$\vs("Π_(x∈A) B")$> <$\vs("∀x (x∈A ⇒ B)")$>
  ; line <$\biginter_{Φ∈⟦ι⟧} \vs("Φ∈A ⇒ B[x≔Φ]")$>
  ; line <$\biginter_{Φ∈⟦ι⟧} \{\v("λx t") \| ∀v∈\vs("Φ∈A"),
      \t("t[x≔v]") ∈ \ts("B[x≔Φ]")\}$>
  ; line <$\{\v("λx t") \| ∀Φ∈⟦ι⟧, ∀v∈\vs("Φ∈A"),
      \t("t[x≔v]") ∈ \ts("B[x≔Φ]")\}$>
  ; line <$\{\v("λx t") \| ∀Φ∈⟦ι⟧, ∀v∈\{w ∈ \vs("A") \| w ≡_{≻} Φ\},
      \t("t[x≔v]") ∈ \ts("B[x≔Φ]")\}$>
  ; line <$\{\v("λx t") \| ∀v∈\vs("A"), \t("t[x≔v]") ∈ \ts("B[x≔v]")\}$> ]
)
\end{center}
and similarly, we have
$$
  \vs("Π_(a∈A) B") = \{\v("λx t") \|
    ∀v∈\vs("A"), \t("t[x≔v]") ∈ \ts("B[a≔v]")\}
$$
if we quantify over a term variable.

=<

=> The limits of value restriction

In languages like ||OCaml||, value restriction is not an issue. As it is
only required on the typing rule for polymorphism, programmers almost never
notice it as they mostly define functions (which are values). Moreover, if
a problematic instance of value restriction is encountered, one can always
use a dummy $λ$-abstraction (or an $η$-expension) to transform a term into
a value. A common example of this situation arises when working with
combinators (e.g. parser combinators) and partial application. As an
example, let us consider the code bellow (written in ||OCaml|| syntax).
### OCaml
(* type 'a gr                               *)
(* val any : char gr                        *)
(* val seq : 'a gr -> 'b gr -> ('a * 'b) gr *)

let mono = seq any
let poly = fun g -> seq any g
###
Here, ##t gr## represents a parser (or grammar) returning a value of type
##t##. The atomic parser ##any## reads one character on the parsed stream
and returns its value. The combinator ##seq## takes as input two parsers
and puts them in sequence to obtain a new parser. The return value of this
new parser is a couple of the return values of the parsers it is build with.
Now, if ##seq## is partially applied with the parser ##any##, the expected
result is a combinator taking as input a parser ##g##, and returning a
parser for the sequence build with ##any## and ##g##. Of course, we want
this new combinator to be as generic as possible, so that it can be applied
to any parser, with any return type. However, the combinator ##mono##
defined above is only weakly polymorphic. This means that we will only be
able to apply it to parsers of one fixed (but yet unknown) type. Of course,
##seq any## is not a value, and value restriction applies. To solve this
lack of generality, one need to rely on an $η$-expension as in ##poly##,
which has the expected type ##'a parser -> (char, 'a) parser##.

As the definition of ##seq## is probably something like
##fun p1 p2 -> body##, the value restriction is actually not required in
##mono##. Indeed, the evaluation of ##seq any## would instantly reduce to
a value (without any side-effect) in one $β$-reduction. This means that
##seq any## could actually be considered a value. However, as discussed
in the introduction, value restriction is a very simple and elegent way
to ensure the soundness of the type system. For this reason, the
limitations discussed here are certainly not enough of a problem to
motivate the design and implementation of a more complex cryterion.

In our system, value restriction is not only required on the introduction
rule for the universal quantifier, but also on the introduction rule for
the membership predicate. As it is used to derive the ($Π_{ι,e}$) and
($Π_{τ,e}$) rules, value restriction is enforced on the argument of
dependent functions. This restriction is indeed necessary as with an
unrestricted ($∈_i$) rule breaks the consistency (and the type safety) of
our system. To support this claim, we will consider the system in which
($∈_i$) has been replaced by the following (unrestricted) typing rule.
$$
\unaryRN{∈_{i,⊥}}
  {Σ \sp Γ,Ξ ⊢ t : A}
  {Σ \sp Γ,Ξ ⊢ t : \f("t∈A")}
$$
In this system, the following (unrestricted) typing rule for the
elimination of the dependent function type can be derived (see the
typing derivation bellow the rule).
$$
  \binaryRN{Π_{e,⊥}}
    {Σ \sp Γ,Ξ ⊢ t : \f("Π_(a∈A) B")}
    {Σ \sp Γ,Ξ ⊢ u : \f("A")}
    {Σ \sp Γ,Ξ ⊢ \t("t u") : \f("B[a≔u]")}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t("t u") : \f("B[a≔u]")}{
   \unaryN{∀_e}{Σ \sp Γ ; Ξ ⊢ t : \f("u∈A ⇒ B[a≔u]")}{
   \unary{Σ \sp Γ ; Ξ ⊢ t : \f("∀a (a∈A ⇒ B)")}{
     \hyp{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}
   }}
 }{
  \unaryN{∈_{i,⊥}}{Σ \sp Γ ; Ξ ⊢ u : \f("u∈A")}{
    \hyp{Σ \sp Γ ; Ξ ⊢ u : A}
  }
 }
}
$$

For convenience, we will also introduced a strong application rule that
can also be derived directly using ($∈_{i,⊥}$). This typing rule will be
used to keep track of the argument used for a function, while typing the
function itself.
$$
  \binaryRN{⇒_{e,{∈},⊥}}
    {Σ \sp Γ;Σ ⊢ t : \f("u∈A⇒B")}
    {Σ \sp Γ;Σ ⊢ u : A}
    {Σ \sp Γ;Σ ⊢ \t("t u") : B}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ \sp Γ ; Ξ ⊢ \t("t u") : \f("B")}{
   \hyp{Σ \sp Γ ; Ξ ⊢ t : \f("u∈A ⇒ B")}
 }{
  \unaryN{∈_{i,⊥}}{Σ \sp Γ ; Ξ ⊢ u : \f("u∈A")}{
    \hyp{Σ \sp Γ ; Ξ ⊢ u : A}
  }
 }
}
$$

We will now build a counter-example to the consistency of the system
without the value restriction on the introduction of the membership
predicate. We will provide a typable term that that reduces to a value
that is not in its type. We consider the term
$t = \t("(λf(λ_v (f F[{}])) (f T[{}])) μα w")$
in which $v$ and $w$ are defined as follows.
\begin{center}
\diagram(
let _ =
  let line s1 s2 = [ <$\t(s1)$> ; <$=$>; <$\t(s2)$> ] in
  array [`East ; `East ; `West]
  [ line "v" "λy [y | F[_] → C₁[{}] | T[_] → C₀[{}]]"
  ; line "w" "λx [x | F[_] → T[{}] | T[_] → [α]λ_ F[{}]]" ]
)
\end{center}
In many reduction steps, we have $\p("t∗ε") ≻^{∗} \p("C₁[{}]∗ε")$. To
obtain our counter-example, we will show that $\t("t")$ has type
$\f("[C₀:{} | C₁:{} ∧ (μα v) F[{}] ≡ F[{}]]")$. As we have
\begin{center}
\linesBefore(6)
\diagram(
let _ =
  let full s1 s2 = [ <$\p(s1)$> ; <$≻$> ; <$\p(s2)$> ] in
  let line s = [ [] ; <$≻$> ; <$\p(s)$> ] in
  array [`East ; `East ; `West]
  [ full "(μα w) F[{}] ∗ π"
         "F[{}] ∗ [μα w] π"
  ; line "μα w ∗ F[{}]·π"
  ; line "w[α≔F[{}]·π] ∗ F[{}]·π"
  ; line "[F[{}] | F[_] → T[{}] | T[_] → [F[{}]·π]λ_ F[{}]] ∗ π"
  ; line "T[{}] ∗ π" ]
)
\end{center}
for every stack $π∈Π$, \lemRef("redtosame") tells us that
$\t("(μα w) F[{}]") ≡_{≻} \t("T[{}]")$. As a consequence, it cannot
be that $\t("(μα w) F[{}]") ≡_{≻} \t("F[{}]")$ and thus the type
$\f("[C₀:{} | C₁:{} ∧ (μα w) F[{}] ≡ F[{}]]")$ is equivalent to
$\f("[C₀ : {}]")$ (i.e. they have the same semantical interpretation).
This means that if we manage to show that $\t("t")$ has type
$\f("[C₀:{} | C₁:{} ∧ (μα w) F[{}] ≡ F[{}]]")$, then we will have a
contradiction to the type safety as $\t("t")$ reduces to $\v("C₁[{}]")$,
which is not contained in $\vs("[C₀ : {}]")$.

In the typing derivation displayed bellow, the type $\f("B")$ is
defined as $\f("[T:{}|F:{}]")$, the type $\f("C")$ is defined as
$\f("[C₀:{} | C₁:{} ∧ f F[{}] ≡ F[{}]]")$, the context $Γ₁$ is
defined as $f : \f("B⇒B")$, the context $Γ₂$ is defined as
$f:\f("B⇒B"), y:\f("B"), y≡\t("f F[{}]")$ and $Γ₃$ is defined as
$α:\f("B⇒B")^⊥,x:B$.
\begin{env}(scale 0.84)
\begin{proofTree}
\Caml(
let p =
  let leaf = ax in
  leaf   ~name:<$p₁$> <$ Γ₁ ⊢_\tval \t("v") : \f("(f F[{}])∈B ⇒ C") $>;
  unary  ~name:<$↑$> <$ Γ₁ ⊢ \t("v") : \f("(f F[{}])∈B ⇒ C") $>;


  ax      ~name:<$Ax$>  <$ Γ₁ ⊢_\tval \t("f") : \f("B⇒B")$>;
  unary   ~name:<$↑$>   <$ Γ₁ ⊢ \t("f") : \f("B⇒B")$>;

  ax      ~name:<$×_i$>  <$ Γ₁ ⊢_\tval \t("{}") : \f("{}")$>;
  unary   ~name:<$+_i$>  <$ Γ₁ ⊢_\tval \t("F[{}]") : \f("B")$>;
  unary   ~name:<$↑$>    <$ Γ₁ ⊢ \t("F[{}]") : \f("B")$>;

  binary  ~name:<$⇒_e$>
    <$ Γ₁ ⊢ \t("f F[{}]") : \f("B") $>;


  binary ~name:<$⇒_{e,{∈},⊥}$> <$ Γ₁ ⊢ \t("v (f F[{}])") : \f("C") $>;
  unary  ~name:<$⇒_i$> <$ Γ₁ ⊢_\tval \t("λ_ v (f F[{}])") : \f("B ⇒ C") $>;
  unary  ~name:<$↑$> <$ Γ₁ ⊢ \t("λ_ v (f F[{}])") : \f("B ⇒ C") $>;


  ax      ~name:<$Ax$>  <$ Γ₁ ⊢_\tval \t("f") : \f("B⇒B")$>;
  unary   ~name:<$↑$>   <$ Γ₁ ⊢ \t("f") : \f("B⇒B")$>;

  ax      ~name:<$×_i$>  <$ Γ₁ ⊢_\tval \t("{}") : \f("{}")$>;
  unary   ~name:<$+_i$>  <$ Γ₁ ⊢_\tval \t("T[{}]") : \f("B")$>;
  unary   ~name:<$↑$>    <$ Γ₁ ⊢ \t("T[{}]") : \f("B")$>;

  binary  ~name:<$⇒_e$>
    <$ Γ₁ ⊢ \t("f T[{}]") : \f("B") $>;


  binary ~name:<$⇒_e$>
    <$ f:\f("B⇒B") ⊢ \t("(λ_ v (f F[{}])) (f T[{}])")
       : \f("[C₀:{} | C₁:{} ∧ f F[{}] ≡ F[{}]]") $>;
  unary  ~name:<$Π_{τ,i}$>
    <$ ⊢_\tval \t("λf (λ_ v (f F[{}])) (f T[{}])")
       : \f("Π_(a∈B⇒B) [C₀:{} | C₁:{} ∧ a F[{}] ≡ F[{}]]") $>;
  unary  ~name:<$↑$>
    <$ ⊢ \t("λf (λ_ v (f F[{}])) (f T[{}])")
       : \f("Π_(a∈B⇒B) [C₀:{} | C₁:{} ∧ a F[{}] ≡ F[{}]]") $>;

  leaf    ~name:<$p₂$>
    <$ ⊢ \t("u") : \f("B⇒B") $>;

  binary ~name:<$Π_{e,⊥}$>
    <$ ⊢ \t("(λf (λ_ v (f F[{}])) (f T[{}])) u")
       : \f("[C₀:{} | C₁:{} ∧ u F[{}] ≡ F[{}]]") $>;
  display_proof ()
)
$$ \id(p) $$
\end{proofTree}
\begin{proofTree}
\Caml(
let p =
  ax     ~name:<$Ax$>
    <$ Γ₂ ⊢_\tval y : \f("B") $>;

  ax      ~name:<$×_i$> <$ Γ₂, y≡\t("F[{}]") ⊢_\tval \t("{}") : \f("{}")$>;
  hyp <$y≡\t("f F[{}]"), y≡\t("F[{}]") ⊢ \t("f F[{}]") ≡ \t("F[{}]")$>;
  binary ~name:<$\restriction_e$>
    <$ Γ₂, y ≡ \t("F[{}]") ⊢_\tval \t("{}") : \f("{} ∧ f F[{}] ≡ F[{}]") $>;
  unary  ~name:<$+_e$> <$ Γ₂, y ≡ \t("F[{}]") ⊢_\tval \t("C₁[{}]") : \f("C") $>;
  unary  ~name:<$↑$> <$ Γ₂, y ≡ \t("F[{}]") ⊢ \t("C₁[{}]") : \f("C") $>;

  ax      ~name:<$×_i$> <$ Γ₂, y≡\t("T[{}]") ⊢_\tval \t("{}") : \f("{}")$>;
  unary  ~name:<$+_e$> <$ Γ₂, y ≡ \t("T[{}]") ⊢_\tval \t("C₀[{}]") : \f("C") $>;
  unary  ~name:<$↑$> <$ Γ₂, y ≡ \t("T[{}]") ⊢ \t("C₀[{}]") : \f("C") $>;

  ternary  ~name:<$+_e$>
    <$ f:\f("B⇒B"), y:\f("B"), y ≡ \t("f F[{}]")
       ⊢ \t("[y | F[_] → C₁[{}] | T[_] → C₀[{}]]")
       : \f("C") $>;
  unary  ~name:<$∈_e$>
    <$ f:\f("B⇒B"), y:\f("(f F[{}])∈B")
       ⊢ \t("[y | F[_] → C₁[{}] | T[_] → C₀[{}]]")
       : \f("C") $>;
  unary  ~name:<$⇒_ι$>
    <$ f:\f("B⇒B") ⊢_\tval \t("λy [y | F[_] → C₁[{}] | T[_] → C₀[{}]]")
       : \f("(f F[{}])∈B ⇒ C") $>;
  unary   ~name:<$p₁$> (mcolor white <$...$>);
  display_proof ()
)
$$ \id(p) $$
\end{proofTree}
\begin{proofTree}
\Caml(
let p =
  ax      ~name:<$Ax$>  <$ Γ₃ ⊢_\tval x:B $>;
  ax      ~name:<$×_i$> <$ Γ₃ ⊢_\tval \v("{}") : \f("{}") $>;
  unary   ~name:<$+_i$> <$ Γ₃ ⊢_\tval \v("T[{}]") : \f("B") $>;
  unary   ~name:<$↑$> <$ Γ₃ ⊢ \v("T[{}]") : \f("B") $>;
  ax      ~name:<$×_i$> <$ Γ₃ ⊢_\tval \v("{}") : \f("{}") $>;
  unary   ~name:<$+_i$> <$ Γ₃ ⊢_\tval \v("F[{}]") : \f("B") $>;
  unary   ~name:<$↑$> <$ Γ₃ ⊢ \v("F[{}]") : \f("B") $>;
  unary   ~name:<$⇒_i$> <$ Γ₃ ⊢_\tval \v("λ_F[{}]") : \f("B⇒B") $>;
  unary   ~name:<$↑$> <$ Γ₃ ⊢ \v("λ_F[{}]") : \f("B⇒B") $>;
  unary   ~name:<$[\wc]$> <$ Γ₃ ⊢ \t("[α]λ_F[{}]"):\f("B") $>;
  ternary ~name:<$+_e$>
    <$ α:\f("B⇒B")^⊥,x:B ⊢
       \t("[x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]") : B $>;
  unary   ~name:<$⇒_i$>
    <$ α:\f("B⇒B")^⊥ ⊢_\tval
       \t("λx [x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]") : \f("B⇒B") $>;
  unary   ~name:<$↑$>
    <$ α:\f("B⇒B")^⊥ ⊢
       \t("λx [x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]") : \f("B⇒B") $>;
  unary   ~name:<$μ$>
    <$ ⊢ \t("μα λx [x|F[_]→T[{}]|T[_]→[α]λ_F[{}]]") : \f("B⇒B") $>;
  unary   ~name:<$p₂$> (mcolor white <$...$>);
  display_proof ()
)
$$ \id(p) $$
\end{proofTree}
\end{env}

As the empty type can be inhabited in the presence of a typing rule
without value restriction for the membership type, we can deduce that
the unrestricted rule is unsound. As a consequence, there is no hope
of encoding an unrestricted elimination rule for the dependent product
into our system. Indeed, only the membership types are able to link
the world of terms and the world of types thanks to their semantics.

The limitation imposed by the value restriction on the dependent
products leads to an expressivity problem. Indeed, it completely
forbids the composition of dependent functions, which is very usual
in practice. In \chapter("implem"), we will consider interesting
examples of programs that could not be accepted under the usual
syntactic restriction. For them to be accepted in our system, we
need another cryterion that accepts more programs, while still being
sound.

=<

=> Semantical value restriction

As discussed in the previous section, value restriction is an issue in
the presence of the membership type (and thus the dependent function
type). To solve the related expressivity problem, the author introduced
the notion of //semantical value restriction// \cite("Lepigre2016").
The main idea is to relax the restriction to allow terms "behaving like",
and not syntactic values only. Thanks to our notion of observational
equivalence, this property can be expressed easily in the syntax. Indeed,
we will replace a typing rule like
\begin{center}
$ \binaryRN{Π_{τ,e}}{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}
    {Σ \sp Γ;Ξ ⊢_\tval v : A}{Σ \sp Γ ; Ξ ⊢ \t("t v") : \f("B[a≔v]")} $
\end{center}
with the following, where value restriction is replaced by an additional
premise involving an equivalence.
\begin{center}
$ \ternaryR{Σ \sp Γ ; Ξ ⊢ t : \f("Π_(a∈A) B")}{Σ \sp Γ ; Ξ ⊢ u : A}
      {Ξ ⊢ u ≡ v}{Σ \sp Γ ; Ξ ⊢ \t("t u") : \f("B[a≔u]")} $
\end{center}
The third premise requires the term $u$, which does not have to be a
value anymore, to be equivalent to some value $v$.

\begin{rem}
Semantical value restriction is a strict relaxation of value restriction.
Indeed, value restriction exactly corresponds to a version of semantical
value restriction in which we would only be able to use reflexivity to
show that two terms are equal.
\end{rem}

In the syntax, semantical value restriction will be presented as a simple
extention of our type system with the following, seemingly obvious, typing
rule.
\begin{center}
$ \unaryRN{↓}{Σ \sp Γ ; Ξ ⊢ v : A}{Σ \sp Γ ; Ξ ⊢_\tval v : A} $
\end{center}
Note that it should not be mistaken with our (${↑}$) rule, which premise
is a value judgment and which conclusion is a term judgment. Our new
(${↓}$) rule allows us to transform a term judgment into a value judgment,
provided that the considered term is a value. The (${≡}_{τ,τ}$) rule can
then be used to obtain a proof of $Σ \sp Γ ; Ξ ⊢ v : A$ from
$Σ \sp Γ ; Ξ ⊢ t : A$, provided $Ξ ⊢ t ≡ v$ can be proved. We can, for
example, derive a relaxed version of the membership introduction typing
rule as follows.
\begin{proofTree}
\Caml(
let p =
  hyp                       <$ Σ \sp Γ ; Ξ ⊢ \t("t") : \f("A") $>;
  hyp                       <$ Ξ ⊢ \t("t") ≡ \t("v") $>;
  binary  ~name:<$≡_{τ,τ}$> <$ Σ \sp Γ ; Ξ ⊢ \t("v") : \f("A") $>;
  unary   ~name:<$↓$>       <$ Σ \sp Γ ; Ξ ⊢_\tval \t("v") : \f("A") $>;
  unary   ~name:<$∈_i$>     <$ Σ \sp Γ ; Ξ ⊢_\tval \t("v") : \f("v∈A") $>;
  unary   ~name:<$↑$>       <$ Σ \sp Γ ; Ξ ⊢ \t("v") : \f("v∈A") $>;
  hyp                       <$ Ξ ⊢ \t("t") ≡ \t("v") $>;
  binary  ~name:<$≡_{τ,τ}$> <$ Σ \sp Γ ; Ξ ⊢ \t("t") : \f("t∈A") $>;
  display_proof ()
)
\begin{center}
$\id(p)$
\end{center}
\end{proofTree}
The obtained, relaxed version of the membership introduction rule
\begin{center}
$ \binaryRN{∈_{i,τ}}{Σ \sp Γ;Σ ⊢ \t("t") : \f("A")}
    {Ξ ⊢ \t("t") ≡ \t("v")}{Σ \sp Γ;Ξ ⊢ \t("t") : \f("t∈A")} $
\end{center}
can then immediatly be used to derive a relaxed version of the
elimination of the dependent function type (having again an equivalence
as a premise).
\begin{center}
$ \ternaryRN{Π_{e,τ}}{Σ \sp Γ;Σ ⊢ \t("t") : \f("Π_(a∈A) B")}
    {Σ \sp Γ;Σ ⊢ \t("u") : \f("A")}{Ξ ⊢ \t("u") ≡ \t("v")}
    {Σ \sp Γ;Ξ ⊢ \t("t u") : \f("B[a≔u]")} $
\end{center}
\begin{proofTree}
\Caml(
let p =
  hyp                       <$Σ \sp Γ;Σ ⊢ \t("t") : \f("Π_(a∈A) B")$>;
  unary                     <$Σ \sp Γ;Σ ⊢ \t("t") : \f("∀a (a∈A ⇒ B)")$>;
  unary   ~name:<$∀_e$>     <$Σ \sp Γ;Σ ⊢ \t("t") : \f("u∈A ⇒ B[a≔u]")$>;
  hyp                       <$Σ \sp Γ;Σ ⊢ \t("u") : \f("A")$>;
  hyp                       <$Ξ ⊢ \t("u") ≡ \t("v")$>;
  binary  ~name:<$∈_{i,τ}$> <$Σ \sp Γ;Σ ⊢ \t("u") : \f("u∈A")$>;
  binary  ~name:<$⇒_e$>     <$Σ \sp Γ;Ξ ⊢ \t("t u") : \f("B[a≔u]") $>;
  display_proof ()
)
\begin{center}
$$\id(p)$$
\end{center}
\end{proofTree}

Aditionally, semantical value restriction allows us to derive a strong
typing rule for general application. It can be seen as a relaxed form
of the following rule (which can be derived easily in the initial
system).
\begin{center}
$ \binaryRN{⇒_{e,{∈}}}{Σ \sp Γ;Ξ ⊢ t : \f("v∈A⇒B")}
    {Σ \sp Γ;Ξ ⊢_\tval v : A}{Σ \sp Γ;Ξ ⊢ \t("t v") : B} $
\end{center}
The interest of such a rule is to keep track of the argument a function
will be applied to, when typing the function itself. In particular, this
is useful to learn equivalences when the argument of a function is used
in a case analysis. However, in its restricted form, this typing rule is
rather useless since a term of the form $\t("(λx [x|(Ci[xi]→ti) i∈I]) v")$
is equivalent to $\t("[v|(Ci[xi]→ti) i∈I]")$, and thus the same effect
can be obtained using the ($≡_{τ,τ}$). Using semantical value restriction,
we can derive the following relaxed rule.
\begin{center}
$ \ternaryRN{⇒_{e,{∈},τ}}{Σ \sp Γ;Ξ ⊢ t : \f("u∈A⇒B")}{Σ \sp Γ;Ξ ⊢ u : A}
    {Ξ ⊢ u ≡ v}{Σ \sp Γ;Ξ ⊢ \t("t u") : B} $
\end{center}
\begin{proofTree}
\Caml(
let p =
  hyp                       <$Σ \sp Γ;Σ ⊢ \t("t") : \f("u∈A ⇒ B")$>;
  hyp                       <$Σ \sp Γ;Σ ⊢ \t("u") : \f("A")$>;
  hyp                       <$Ξ ⊢ \t("u") ≡ \t("v")$>;
  binary  ~name:<$∈_{i,τ}$> <$Σ \sp Γ;Σ ⊢ \t("u") : \f("u∈A")$>;
  binary  ~name:<$⇒_e$>     <$Σ \sp Γ;Ξ ⊢ \t("t u") : B$>;
  display_proof ()
)
\begin{center}
$$\id(p)$$
\end{center}
\end{proofTree}
The relaxed rule is very useful to obtain a typing rule for a generalised
form of case analysis ranging over terms (and not only values).
\begin{center}
$ \ternaryRN{+_{e,τ}}{Σ \sp Γ;Ξ ⊢ \t("t") : \f("[(Ci : Ai) i∈I]")}{Ξ ⊢ t ≡ v}
     {[Σ \sp Γ, x_i:A_i; Ξ, t ≡ \t("Ci[xi]") ⊢ t_i : B]_{i∈I}}
     {Σ \sp Γ;Ξ ⊢ \t("(λx [x | (Ci[xi] → ti) i∈I]) t") : B} $
\end{center}
\begin{env}(scale 0.65)
\Caml(
let subp = <$
    \proofTree{
      \unaryN{≡_{τ,τ}}{Σ \sp Γ, x_i:A_i; Ξ, x≡t; x ≡ \t("Ci[xi]") ⊢ t_i : B}{
        \unaryN{Wk}{Σ \sp Γ, x_i:A_i; Ξ, x≡t; t ≡ \t("Ci[xi]") ⊢ t_i : B}{
          \hyp{Σ \sp Γ, x_i:A_i; Ξ, t ≡ \t("Ci[xi]") ⊢ t_i : B}
        }
      }
    }
  $>
)
\begin{proofTree}
\Caml(
let p =
  ax       ~name:<$Ax$> (* FIXME floating in the air *)
    <$Σ \sp Γ,x:\f("[(Ci : Ai) i∈I]");Σ,x≡t ⊢_\tval x:\f("[(Ci : Ai) i∈I]")$>;
  hyp <$[\id(subp)]_{i∈I}$>;
  binary   ~name:<$+_e$>
    <$Σ \sp Γ,x:\f("[(Ci : Ai) i∈I]");Σ,x≡t ⊢ \t("[x|(Ci[xi]→ti) i∈I]"):B$>;
  unary    ~name:<$∈_e$>
    <$Σ \sp Γ,x:\f("t∈[(Ci : Ai) i∈I]");Σ ⊢ \t("[x|(Ci[xi]→ti) i∈I]"):B$>;
  unary    ~name:<$⇒_i$>
    <$Σ \sp Γ;Σ ⊢_\tval \t("λx [x | (Ci[xi] → ti) i∈I]") :
        \f("t∈[(Ci : Ai) i∈I] ⇒ B")$>;
  unary    ~name:<$↑$>
    <$Σ \sp Γ;Σ ⊢ \t("λx [x | (Ci[xi] → ti) i∈I]") :
        \f("t∈[(Ci : Ai) i∈I] ⇒ B")$>;
  hyp                       <$Σ \sp Γ;Ξ ⊢ \t("t") : \f("[(Ci : Ai) i∈I]")$>;
  hyp                       <$Ξ ⊢ \t("t") ≡ \t("v")$>;
  ternary  ~name:<$⇒_{e,{∈},τ}$>
    <$Σ \sp Γ;Ξ ⊢ \t("(λx [x | (Ci[xi] → ti) i∈I]) t") : B$>;
  display_proof ()
)
\begin{center}
$$\id(p)$$
\end{center}
\end{proofTree}
\end{env}
Note that without the ($+_{e,τ}$) rule, it would be impossible to preserve
the equivalences of the form $t ≡ \t("Ci[xi]")$. We would only know that
$x ≡ \t("Ci[xi]")$, which is not enough since we would have no way of
linking $x$ to the term $t$.

Of course, we can only apply semantical value restriction to our system if
we can addapt our model so that the ($↓$) rule is adequate. As we will see
in the next sections, the required modifications are highly non-trivial and
require a modification of our notions of reduction and equivalence.

=<

=> Semantics for semantical value restriction

As mentioned in the previous section, semantical value restriction can be
enabled in our system by extending it with the ($↓$) typing rule (recalled
bellow).
\begin{center}
$ \unaryRN{↓}{Σ \sp Γ ; Ξ ⊢ v : A}{Σ \sp Γ ; Ξ ⊢_\tval v : A} $
\end{center}
In order to give a semantical justification to this rule (i.e. to show
that it is adequate), we need to find a model in which the following
property holds for every $Φ ∈ ⟦ο⟧$.
$$ Φ^{⊥⊥} ∩ Λ_ι^{∗} ⊆ Φ $$
This property is not true in general, and in particular it is not true in
our current model. A counter-example is given in the following theorem.
\begin{thm}
There is a pole $\dbot$ and a set of values $Φ ∈ ⟦ο⟧$ such that
$Φ^{⊥⊥} ∩ Λ_ι^{∗}$ contains strictly more values that $Φ$.
\begin{proof}
Let us consider the pole $\dbot = \{p ∈ Λ×Π \| ∃v∈Λ_ι, p ≻^{∗} \p("v∗ε")\}$
and show that the set $Φ = \{v∈Λ_ι \| v ≡_{≻} \v("λx Ω")\}$ is suitable. As
we have $Λ_ι ⊆ Λ_ι^{⊥⊥}$ by \lemRef("orthosimple"), it is enough to show
that $Φ^⊥ = Λ_ι^⊥$ since in this case we get $Λ_ι ⊆ Φ^{⊥⊥} = Λ_ι^{⊥⊥}$. Of
course, there are many values that are in $Λ_ι$, but not in $Φ$. For example,
we have $\v("{}") ∈ Λ_ι$ but $\v("{}") \nequiv_{≻} \v("λxΩ")$ according to
\thmRef("nequivlamreco"). Since $Φ ⊆ Λ_ι$ we must have $Φ^⊥ ⊇ Λ_ι^⊥$ by
\lemRef("orthoinclstack"), so it only remains to show that $Φ^⊥ ⊆ Λ_ι^⊥$.
Let us take a stack $π ∈ Φ^⊥$. By definition, we know $\p("w∗π") ∈ \dbot$
for every value $w ≡_{≻} \v("λxΩ")$. Let us now take a value $v∈Λ_ι$ and
show that $\p("v∗π") ∈ \dbot$. We will now perform a case analysis on the
form of $π$.
\begin{itemize}
\item If $π = ε$, then $\p("v∗π") ∈ \dbot$ by definition of $\dbot$.
\item If $π = α$ for some $α∈\cal{V}_σ$ then it cannot be that $π ∈ Φ^⊥$.
      If it were the case, we would have $\p("λxΩ ∗ α") ∈ \dbot$, which
      cannot be true since this process is blocked.
\item If $π = \s("v₀·ξ")$ for some value $v₀ ∈ Λ_ι$ and stack $ξ ∈ Π$ then
      it cannot be that $π ∈ Φ^⊥$. If it were the case, we would have
      $\p("λxΩ ∗ v₀·ξ") ≻ \p("Ω ∗ ξ") ∈ \dbot$, which cannot be true since
      this process is non-terminating.
\item If $π = \s("[t]ξ")$ for some term $t ∈ Λ$ and stack $ξ ∈ Π$ then we
      consider the reduction of the process $\p("t ∗ z·ξ")$, where
      $z∈\cal{V}_ι$ is a fresh $λ$-variable. We know that $\p("t∗z·ξ")$
      cannot be non-terminating, as otherwise
      $\p("(t∗z·ξ)[z≔λxΩ]") = \p("t∗λxΩ·ξ")$ would also be non-terminating
      according to \lemRef("redstable"). This would contradict
      $\s("[t]ξ") ∈ Φ^⊥$ since we have $\p("λxΩ∗[t]ξ") ≻ \p("t∗λxΩ·ξ")$.
      Consequently, there is $q ∈ Λ×Π$ such that $\p("z∗[t]ξ") ≻ \p("q")$.
      We now reason by case analysis following \lemRef("possibilities"). If
      $q$ is final, then $\p("q[z≔v]")$ is also final by
      \lemRef("redstable"), and thus $\p("v∗[t]ξ") ∈ \dbot$. In all the
      other cases, $\p("q[z≔λxΩ]")$ is either still blocked, or
      non-terminating, which contradicts the fact that $\s("[t]ξ") ∈ Φ^⊥$.
\end{itemize}
\end{proof}
\end{thm}

The idea now is to use our equivalence relation $({≡})$ to extend the
reduction relation $({≻})$ with a new, surprising reduction rule. It
will reduce processes having the form $\p("δ(v,w) ∗ π")$ to $\p("v ∗ π")$
in the case where $v \nequiv_{≻} w$, and remain stuck otherwise. With
such a reduction rule, the definitions of reduction and equivalence
become interdependent. Consequently, we need to be very careful so
that everything remains well-defined. We will rely on a stratified
construction of both reduction and equivalence.
\begin{def}
For every $i ∈ \bbN$ we define two relations $({↠}_i)$ and $({≡}_i)$
as follows.
\begin{center}
\diagram(
let _ =
  let line e1 e2 = [ e1 ; <$=$> ; e2 ] in
  array [`East ; `Main ; `West]
  ~horizontal_padding:(function 1 -> 5.0 | _ -> 4.0) (* Fix *)
  [ line <$({↠}_i)$> <$({≻}) ∪ \{(\p("δ(v,w) ∗ π"), \p("v ∗ π")) \st
      ∃j < i, v \nequiv_j w\}$>
  ; line <$({≡}_i)$> <$\{(t,u) \st ∀j ≤ i, ∀π, ∀ρ,
      {{\p("tρ∗π")} {⇓}_j} ⇔ {{\p("uρ∗π")} {⇓}_j}\}$> ]
)
\end{center}
Here, all the relations are well-defined as there is no circularity. In
particular, we have $({↠}₀) = ({≻})$ since there is no natural number
that is strictly smaller than $0$.
\end{def}
\begin{lem}\label("isequiv")
For every $i ∈ \bbN$, the relation $({≡}_i)$ is an equivalence relation.
\begin{proof}
Immediate.
\end{proof}
\end{lem}

We can then define our actual reduction relation and equivalence relation
as a union and an intersection over the previously defined relations.
\begin{def}
We define a reduction relation $({↠})$ and an equivalence relation $({≡})$.
$$
  ({↠}) = \bigcup_{i∈\bbN} ({↠}_i)
  \hspace(8.0)
  ({≡}) = \bigcap_{i∈\bbN} ({≡}_i)
$$
\end{def}
\begin{rem}
Obviously $({↠}_i) ⊆ ({↠}_{i+1})$ and $({≡}_{i+1}) ⊆ ({≡}_i)$. As a
consequence the construction of $({↠}_i)_{i∈\bbN}$ and $({≡}_i)_{i∈\bbN}$
converges. In fact $({↠})$ and $({≡})$ form a fixpoint at ordinal $ω$.
Surprisingly, this property will not be explicitly required in the
following.
\end{rem}
\begin{lem}
The relation $({≡})$ is an equivalence relation.
\begin{proof}
Immediate using \lemRef("isequiv") since an intersection of equivalence
relations is itself an equivalence relation.
\end{proof}
\end{lem}
For convenience, the definition of our new reduction and equivalence
relations can be expressed in the following way, where $({\nequiv})$
denotes the negation of $({≡})$.
\begin{center}
\diagram(
let _ =
  let line e1 e2 = [ e1 ; <$=$> ; e2 ] in
  array [`East ; `Main ; `West]
  ~horizontal_padding:(function 1 -> 5.0 | _ -> 4.0) (* Fix *)
  [ line <$({≡})$>
      <$ \{(t,u) \st ∀i, ∀π, ∀ρ,
         {{\p("tρ∗π")} {⇓}_i} ⇔ {{\p("uρ∗π")} {⇓}_i}\} $>
  ; line <$({\nequiv})$>
      <$ \{(t,u), (u,t) \st ∃i, ∃π, ∃ρ,
         {{\p("tρ∗π")} {⇓}_i} ∧ {{\p("uρ∗π")} {⇑}_i}\}$>
  ; line <$({↠})$>
      <$({≻}) ∪ \{(\p("δ(v,w)∗π"), \p("v∗π")) \st v \nequiv w\}$> ]
)
\end{center}
Note that the definition of $({↠})$ corresponds exactly to what we aimed
for: an extention of $({≻})$ with a reduction rule for $δ$-like terms
carrying two non-equivalent values.

(* TODO from here. *) \todo(None)
\begin{thm}\label("equivpole")
Let $t$ and $u$ be terms. If $t ≡ u$ then for every stack $π ∈ Π$ and
substitution $σ$ we have ${{\p("tσ∗π")} {⇓}_{↠}} ⇔ {{\p("uσ∗π")} {⇓}_{↠}}$.
\begin{proof}
We suppose that $t ≡ u$ and we take $π₀ ∈ Π$ and a substitution $σ₀$. By
symmetry we can assume that ${\p("tσ₀∗π₀")} {⇓}_{↠}$ and show that
${\p("uσ₀∗π₀")} {⇓}_{↠}$. By definition there is $i₀ ∈ \bbN$ such that
${\p("tσ₀∗π₀")} {⇓}_{i₀}$. Since $t ≡ u$ we know that for every $i ∈ \bbN$,
$π ∈ Π$ and substitution $σ$ we have
${{\p("tσ∗π")} {⇓}_i} ⇔ {{\p("uσ∗π")} {⇓}_i}$. This is true in particular
for $i = i₀$, $π = π₀$ and $σ = σ₀$. We hence obtain
${\p("uσ₀∗π₀")} {⇓}_{i₀}$ which give us ${\p("uσ₀∗π₀")} {⇓}_{↠}$.
\end{proof}
\end{thm}

\begin{rem}
The converse implication is not true in general: taking
$t = \t("δ(λx x, {})")$ and $u = \t("λx x")$ gives a counter-example.
More generally ${p {⇓}_{↠}} ⇒ {q {⇓}_{↠}}$ does not necessarily imply
${p {⇓}_i} ⇒ {q {⇓}_i}$ for all $i ∈ \bbN$.
\end{rem}
\begin{cor}\label("eqconvconv")
Let $t$ and $u$ be terms and $π$ be a stack. If $t ≡ u$ and
${\p("t∗π")} {⇓}_{↠}$ then ${\p("u∗π")} {⇓}_{↠}$.
\begin{proof}
Direct consequence of \thmRef("equivpole") using $π$ and an empty
substitution.
\end{proof}
\end{cor}

=<

=> Extensionality of equivalence

In order to be able to work with the equivalence relation $({≡})$, we
need to check that it is extensional. In other words, we need to be able
to replace equals by equals at any place in terms without changing their
observed behaviour. This property is summarized in the following two
theorems.

\begin{thm}\label("extval")
Let $v$ and $w$ be values, $t$ be a term and $x$ be a $λ$-variable. If
$v ≡ w$ then we have $\t("t[x≔v]") ≡ \t("t[x≔w]")$.
\begin{proof}
We are going to prove the contrapositive so we suppose
$\t("t[x≔v]") \nequiv \t("t[x≔w]")$ and show $v \nequiv w$. By definition
there is a natural number $i$, a stack $π$ and a substitution $σ$ such that
we have ${\p("(t[x≔v])σ ∗ π")} {\converge}_i$ and
${\p("(t[x≔w])σ ∗ π")} {\diverge}_i$ (up to symmetry).
Since we can rename $x$ in such a way that it does not appear in $dom(σ)$,
we can suppose that we have ${\p("tσ[x≔vσ] ∗ π")} {\converge}_i$ and
${\p("tσ[x≔wσ] ∗ π")} {\diverge}_i$. To show $v \nequiv w$ we need $i₀$,
$π₀$ and $σ₀$ such that ${\p("vσ₀ ∗ π")₀} {\converge}_{i₀}$ and
${\p("wσ₀ ∗ π₀")} {\diverge}_{i₀}$ (up to symmetry). We take
$i₀ = i$, $π₀ = \s("[λx tσ]π")$ and $σ₀ = σ$ as
${\p("vσ₀ ∗ [λx tσ]π") \epi \p("tσ[x≔vσ] ∗ π")}_i$ and
${\p("wσ₀ ∗ [λx tσ]π") \epi \p("tσ[x≔wσ] ∗ π")}_i$.
\end{proof}
\end{thm}

(* TODO macros from here *)
\begin{lem}\label("aposs")
Let $s$ be a process, $t$ be a term, $a$ be a term variable and $k$ be a
natural number. If $s[a := t] {\converge}_k$ then there is a blocked state
$p$ such that ${s ≻ p}^{∗}$ and either
\begin{itemize}
\item $p = v ∗ α$ for some value $v$ and a stack variable $α$,
\item $p = a ∗ π$ for some stack $π$,
\item $k > 0$ and $p = δ(v,w) ∗ π$ for some values $v$ and $w$ and
      stack $π$, and in this case $v[a := t] \nequiv_j w[a := t]$ for
      some $j < k$.
\end{itemize}
\begin{proof}
Let $σ$ be the substitution $[a := t]$. If $s$ is non-terminating,
\lemRef("redstable") tells us that $sσ$ is also non-terminating, which
contradicts $sσ {\converge}_k$. Consequently, there is a blocked process
$p$ such that ${s ≻ p}^{∗}$ since $({≻}) ⊆ ({\epi}_k)$.
(* *)
Using \thmRef("redcompatall") we get ${sσ ≻ pσ}^{∗}$ from which we obtain
$pσ {\converge}_k$. The process $p$ cannot be stuck, otherwise $pσ$ would
also be stuck by \lemRef("redstable"), which would contradict
$pσ {\converge}_k$. Let us now suppose that $p = δ_{v,w} ∗ π$ for some
values $v$ and $w$ and some stack $π$. Since $δ_{vσ,wσ} ∗ π {\converge}_k$
there must be $i < k$ such that $vσ \nequiv_j wσ$, otherwise this would
contradict $δ_{vσ,wσ} ∗ π {\converge}_k$. In this case we necessarily
have $k > 0$, otherwise there would be no possible candidate for $i$.
According to \lemRef("possibilities") we need to rule out four more forms
of therms: $x.l ∗ π$, $x ∗ v.π$, $case_x B ∗ π$ and $b ∗ π$ in the case
where $b ≠ a$. If $p$ was of one of these forms the substitution $σ$ would
not be able to unblock the reduction of $p$, which would contradict again
$pσ {\converge}_k$.
\end{proof}
\end{lem}

\begin{lem}\label("aextlem")
Let $t₁$, $t₂$ and $E$ be terms and $a$ be a term variable. For every
$k ∈ \bbN$, if $t₁ ≡_k t₂$ then $E[a := t₁] ≡_k E[a := t₂]$.
\begin{proof}
Let us take $k ∈ \bbN$, suppose that ${t₁ ≡ t₂}_k$ and show that
$E[a := t₁] ≡_k E[a := t₁]$. By symmetry we can assume that we have
$i ≤ k$, $π ∈ Π$ and a substitution $σ$ such that $(E[a := t₁])σ ∗ π 
{\converge}_i$ and show that $(E[a := t₂])σ ∗ π {\converge}_i$. As we are
free to rename $a$, we can suppose that it does not appear in $dom(σ)$,
$TV(π)$, $TV(t₁)$ or $TV(t₂)$. In order to lighten the notations we define
$E' = Eσ$, $σ₁ = [a := t₁σ]$ and $σ₂ = [a := t₂σ]$. We are hence assuming
$E'σ₁ ∗ π {\converge}_i$ and trying to show $E'σ₂ ∗ π {\converge}_i$.

We will now build a sequence $(E_i,π_i,l_i)_{i ∈ I}$ such that
${{E'σ₁ ∗ π} \epi {E_iσ₁ ∗ π_iσ₁}}_k$ in $l_i$ steps for every $i ∈ I$.
Furthermore, we require that $(l_i)_{i ∈ I}$ is increasing and that it has
a strictly increasing subsequence. Under this condition our sequence will
be finite. If it was infinite the number of reduction steps that could be
taken from $E'σ₁ ∗ π$ would not be bounded, which would contradict
$E'σ₁ ∗ π {\converge}_i$. We now denote our finite sequence
$(E_i,π_i,l_i)_{i ≤ n}$ with $n ∈ \bbN$. To show that
$(l_i)_{i ≤ n}$ has a strictly increasing subsequence, we will ensure that
it does not have three equal consecutive values. More formally, we will
require that if $0 < i < n$ and $l_{i-1} = l_i$ then $l_{i+1} > l_i$.

To define $(E₀,π₀,l₀)$ we consider the reduction of $E' ∗ π$. Since we know
that we have $(E' ∗ π)σ₁ = E'σ₁ ∗ π {\converge}_i$ we use \lemRef("aposs")
to obtain a blocked state $p$ such that ${{E' ∗ π} ≻ p}^j$. We can now take
$E₀ ∗ π₀ = p$ and $l₀ = j$. By \thmRef("redcompatall") we have ${(E' ∗ π)σ₁
≻ {E₀σ₁ ∗ π₀σ₁}}^j$ from which we can deduce that ${(E' ∗ π)σ₁ \epi {E₀σ₁ ∗
π₀σ₁}}_k$ in $l₀ = j$ steps.

To define $(E_{i+1},π_{i+1},l_{i+1})$ we consider the process $E_iσ₁ ∗ π_i$.
By construction we know that ${{E'σ₁ ∗ π} \epi {E_iσ₁ ∗ π_iσ₁}}_k = (E_iσ₁ ∗
π_i)σ₁$ in $l_i$ steps. Using \lemRef("aposs"), we obtain that the process
$E_i ∗ π_i$ can be of three different shapes.
\begin{itemize}
\item If ${E_i ∗ π_i} = {v ∗ α}$ for some value $v$ and stack variable $α$
      then the end of the sequence was reached with $n = i$.
\item If $E_i = a$ then we consider the reduction of $E_iσ₁ ∗ π_i$. Since
      $(E_iσ₁ ∗ π_i)σ₁ {\converge}_k$ we know from \lemRef("aposs") that
      there is a blocked process $p$ such that ${{E_iσ₁ ∗ π_i} ≻ p}^j$.
      Using \thmRef("redcompatall") we obtain ${{E_iσ₁ ∗ π_iσ₁} ≻ pσ₁}^j$
      from which we can deduce that ${{E_iσ₁ ∗ π_iσ₁} \epi pσ₁}_k$ in $j$
      steps. We then take $E_{i+1} ∗ π_{i+1} = p$ and $l_{i+1} = l_i + j$.

      Is it possible to have $j=0$? This can only happen when $E_iσ₁ ∗ π_i$
      is of one of the three forms of \lemRef("aposs"). It cannot be of the
      form $a ∗ π$ as we assumed that $a$ does not appear in $t₁$ or $σ$.
      If it is of the form $v ∗ α$, then we reached the end of the sequence
      with $i + 1 = n$ so there is no problem. In the case where the process
      $E_iσ₁ ∗ π_i$ is of the form $δ(v,w) ∗ π$, but we will have $l_{i+2} >
      l_{i+1}$.
\item If $E_i = δ(v,w)$ for some values $v$ and $w$ we have $m < k$ such
      that ${vσ₁ \nequiv wσ₁}_m$. Hence ${{E_iσ₁ ∗ π_i = δ(vσ₁,wσ₁) ∗ π_i}
      \epi {vσ₁ ∗ π_i}}_k$ by definition. Moreover, we know that
      ${{E_iσ₁ ∗ π_iσ₁} \epi {vσ₁ ∗ π_iσ₁}}_k$ by \thmRef("redcompatall").
      Since ${{E'σ₁ ∗ π} \epi
      {E_iσ₁ ∗ π_iσ₁}}_k^{∗}$ in $l_i$ steps we get that ${{E'σ₁ ∗ π}
      \epi {vσ₁ ∗ π_iσ₁}}_k^{∗}$ in $l_i + 1$ steps, and hence
      ${(vσ₁ ∗ π_i)σ₁ = vσ₁ ∗ π_iσ₁} {\converge}_k$.
      
      We now consider the reduction of the process $vσ₁ ∗ π_i$. By
      \lemRef("aposs") there is a blocked process $p$ such that
      ${{vσ₁ ∗ π_i} ≻ p}^j$. Using \thmRef("redcompatall") we obtain
      ${{vσ₁ ∗ π_iσ₁} ≻ pσ₁}^j$ from which we deduce that ${{vσ₁ ∗ π_iσ₁}
      \epi pσ₁}_k^{∗}$ in $j$ steps. We then take $E_{i+1} ∗ π_{i+1} = p$
      and $l_{i+1} = l_i + j + 1$. Note that in this case we have $l_{i+1}
      > l_i$.
\end{itemize}
Intuitively $(E_i,π_i,l_i)_{i ≤ n}$ mimics the reduction of $E'σ₁ ∗ π$ while
making explicit every substitution of $a$ and every reduction of a $δ$-like
state.

To end the proof we show that for every $i ≤ n$ we have ${E_iσ₂ ∗ π_iσ₂}
{\converge}_k$. For $i = 0$ this will give us ${E'σ₂ ∗ π} {\converge}_k$,
which is the expected result. Since $E_n ∗ π_n = v ∗ α$ we have $E_nσ₂ ∗
π_nσ₂ = vσ₂ ∗ α$ from which we trivially obtain ${E_nσ₂ ∗ π_nσ₂}
{\converge}_k$. We now suppose that ${E_{i+1}σ₂ ∗ π_iσ₂} {\converge}_k$ for
$0 ≤ i < n$ and show that ${E_iσ₂ ∗ π_iσ₂} {\converge}_k$. By construction
$E_i ∗ π_i$ can be of two shapes since only $E_n ∗ π_n$ can be of the form
$v ∗ α$.
\begin{itemize}
\item If $E_i = a$ then ${{t₁σ ∗ π_i} \epi {E_{i+1} ∗ π_{i+1}}}_k^{∗}$. by
      \thmRef("redcompatall") we get ${{t₁σ ∗ π_iσ₂} \epi {E_{i+1}σ₂ ∗
      π_iσ₂}}_k$ from which we deduce ${t₁σ ∗ π_iσ₂}
      {\converge}_k$ by induction hypothesis. Since ${t₁ ≡ t₂}_k$ we obtain
      ${t₂σ ∗ π_iσ₂ = (E_i ∗ π_i)σ₂} {\converge}_k$.
\item If $E_i = δ(v,w)$ then ${{v ∗ π_i} \epi {E_{i+1} ∗ π_{i+1}}}_k$ and
      hence ${{vσ₂ ∗ π_iσ₂} \epi {E_{i+1}σ₂ ∗ π_{i+1}σ₂}}_k$ by
      \thmRef("redcompatall"). Using the induction hypothesis we obtain
      ${vσ₂ ∗ π_iσ₂} {\converge}_k$. It remains to show that
      ${{δ(vσ₂,wσ₂) ∗ π_iσ₂} \epi {vσ₂ ∗ π_iσ₂}}_k^{∗}$. We need to find
      $j < k$ such that ${vσ₂ \nequiv wσ₂}_j$. By construction there is
      $m < k$ such that ${vσ₁ \nequiv wσ₁}_m$. We are going to show that
      ${vσ₂ \nequiv wσ₂}_m$. By using the global induction hypothesis twice
      we obtain ${vσ₁ ≡ vσ₂}_m$ and ${wσ₁ ≡ vσ₂}_m$. Now if ${vσ₂ ≡ wσ₂}_m$
      then ${{vσ₁ ≡ vσ₂}_m ≡ {wσ₂ ≡ wσ₁}_m}_m$ contradicts
      $vσ₁ \nequiv wσ₁$. Hence we must have ${vσ₂ \nequiv wσ₂}_m$.
\end{itemize}
\end{proof}
\end{lem}

\begin{thm}\label("extterm")
Let $t₁$, $t₂$ and $E$ be three terms and $a$ be a term variable. If
$t₁ ≡ t₂$ then $E[a := t₁] ≡ E[a := t₂]$.
\begin{proof}
We suppose that $t₁ ≡ t₂$ which means that ${t₁ ≡ t₂}_i$ for every
$i ∈ \bbN$. We need to show that $E[a := t₁] ≡ E[a := t₂]$ so we take
$i₀ ∈ \bbN$ and show ${E[a := t₁] ≡ E[a := t₂]}_{i₀}$. By hypothesis we
have ${t₁ ≡ t₂}_{i₀}$ and hence we can conclude using \lemRef("aextlem").
\end{proof}
\end{thm}

=<
=> Derived type system

\Caml(
let r1 =
  <<$\axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Ξ ⊢ \t("x") : A; Δ)}$>>

let r3 =
  <<$\unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Ξ ⊢ \t("t") : B; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \v("λx t") : A ⇒ B; Δ)}$>>

let r4 =
  <<$\binaryRN{⇒_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : A ⇒ B; Δ)}{Σ ⊢ (Γ;Ξ ⊢ \t("u") : A; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t u") : B; Δ)}$>>

let r5 =
  <<$\unaryRN{μ}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("μα t") : A; Δ)}$>>

let r6 =
  <<$\unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
   {Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("[α]t") : B; Δ,α:A)}$>>

(* FIXME add semantical value restriction *)
let r7 =
  <<$\unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Ξ ⊢ \v("v") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("∀χ^s A");Δ)}$>>

let r8 =
  <<$\binaryRN{∀_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∀χ^s A");Δ)}{Σ ⊢ B : s}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]");Δ)}$>>

let r9 =
  <<$\binaryRN{∃_i}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ≔B]");Δ)}{Σ ⊢ B : s}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∃χ^s A");Δ)}$>>

let rA =
  <<$\binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Ξ ⊢ \t("t") : \f("C");Δ)}
   {Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Ξ ⊢ \t("t") : \f("C");Δ)}$>>

(* FIXME add semantical value restriction *)
let rB =
  <<$\unaryRN{∈_i}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("v∈A");Δ)}$>>

let rC =
  <<$\unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,x≡t ⊢ \t("t") : C;Δ)}
   {Σ, x:ι ⊢ (Γ,x:\f("t∈A");Ξ ⊢ \t("t") : C;Δ)}$>>

let rD =
  <<$\unaryRN{↾_i}{Σ ⊢ (Γ;Ξ,t≡u ⊢ \t("t") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A ∧ t≡u");Δ)}$>>

let rE =
  <<$\unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,t≡u ⊢ \t("t") : C;Δ)}
   {Σ, x:ι ⊢ (Γ,x:\f("A ∧ t≡u");Ξ ⊢ \t("t") : C;Δ)}$>>

let rF =
  <<$\unaryRN{×_i}{[Σ ⊢ (Γ;Ξ ⊢ \v("vi") : \f("Ai");Δ)]_{i∈I}}
   {Σ ⊢ (Γ;Ξ ⊢ \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}");Δ)}$>>

let rG =
  <<$\binaryRN{×_e}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("{(li : Ai) i∈I}");Δ)}
   {k∈I}{Σ ⊢ (Γ;Ξ ⊢ \t("v.lk") : A_k;Δ)}$>>

let rH =
  <<$\binaryRN{+_i}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("Ak");Δ)}{k∈I}
   {Σ ⊢ (Γ;Ξ ⊢ \v("Ck[v]") : \f("[(Ci : Ai) i∈I]");Δ)}$>>

let rI =
  <<$\binaryRN{+_e}{Σ ⊢ (Γ;Ξ ⊢ \v("v") : \f("[(Ci : Ai) i∈I]");Δ)}
   {[Σ ⊢ (Γ,x_i:A_i;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B;Δ)]_{i∈I}}
   {Σ ⊢ (Γ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B;Δ)}$>>

let rJ =
  <<$\unaryRN{≡_{l, {val}}}{Σ ⊢ (Γ;Ξ,v≡w ⊢ \t("t[x≔v]") : A;Δ)}
   {Σ ⊢ (Γ;Ξ,v≡w ⊢ \t("t[x≔w]") : A;Δ)}$>>

let rK =
  <<$\unaryRN{≡_{l}}{Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A;Δ)}
   {Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A;Δ)}$>>

let rL =
  <<$\unaryRN{≡_{r, {val}}}{Σ ⊢ (Γ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₁]");Δ)}
   {Σ ⊢ (Γ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₂]");Δ)}$>>

let rM =
  <<$\unaryRN{≡_{r}}{Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]");Δ)}
   {Σ ⊢ (Γ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]");Δ)}$>>

let rs env =
  let env = resize_env 3.4 env in
  let rs =
    [ [ r1 ; r3 ] ; [ r4 ] ; [ r5 ; r6 ] ; [ r7 ; rA ] ; [ r8 ; r9 ]
    ; [ rB ; rC ] ; [ rD ; rE ] ; [ rG ; rH ] ; [ rF ] ; [ rI ] ; [ rJ ; rK ]
    ; [ rL ; rM ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let _ = figure_here ~name:"sortrules" ~caption:[tT "Typing rules."] (dr rs)
)

(* ADEQUACY CASE
\item If the last used rule is ($↓$) then we need to show
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ |\f("Aρ")|$, hence we can conclude using
      \thmRef("orthonew").
      \begin{center}
        $ \unaryRN{↓}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)} $
      \end{center}
*)

=<

=> Dependent pair types

(* TODO *)
$$
  \f("Σ_(x∈A) B") ≔ \f("∃x {l₁:x∈A; l₂:B}")
  \hspace(6.0)
  \f("Σ_(a∈A) B") ≔ \f("∃a {l₁:a∈A; l₂:B}")
$$

$$
\binaryRN{Σ_{ι,i}}{Σ \sp Γ ; Ξ ⊢ v₁ : A}{Σ \sp Γ ; Ξ ⊢ v₂ : \f("B[y≔v₁]")}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("{l₁ = v₁; l₂ = v₂}") : \f("Σ_(y∈A) B")}
$$
$$
\binaryRN{Σ_{τ,i}}{Σ \sp Γ ; Ξ ⊢ v₁ : A}{Σ \sp Γ ; Ξ ⊢ v₂ : \f("B[a≔v₁]")}
  {Σ \sp Γ ; Ξ ⊢_\tval \v("{l₁ = v₁; l₂ = v₂}") : \f("Σ_(a∈A) B")}
$$

=<

=<
