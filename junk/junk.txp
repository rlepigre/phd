\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^\bot $>
  let ts a = <$ ⟦\f(a)⟧^{\bot\bot} $>
)
\Include{Macros}

=> Simple types

In order to prevent undesired computational behaviours such as runtime
errors, functional programming languages rely on syntactic checks. We
will first consider a small type system with only three type constructors:
functions, products (in the form of records) and sums (in the form of
variants).
\begin{def}
The set of all types $\cal{F}$ is built using the following ||bnf|| grammar.
$$ A,B ::= \f("A ⇒ B") \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")$$
\end{def}
\begin{rem}
To lighten the notations, we will consider the function type to be right
associative. That is, we will always read a type of the form
$\f("A ⇒ B ⇒ C")$ as $\f("A ⇒ (B ⇒ C)")$.
\end{rem}
Through the Curry-Howard isomorphism, it is possible to see our type system
as a logic. In particular, a type can be read as a formula in which the
arrow type corresponds to logical implication. Similarly, product and sum
types can be interpreted as logical conjunction and disjunction.

To be able to assign a type to terms containing free variables, we need to
use typing contexts. A typing context will map variables to their assumed
type. Logically, a context will simply correspond to a set of hypothesis.
That is, a set of formulas that are assumed to be true.
\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ such that for all
$λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent contexts using lists generated using the following ||bnf|| grammar.
$$ Γ ::= • \| {Γ, x : A} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgement is a triple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$ and
a context $Γ$ that is denoted $Γ ⊢ t : A$. A judgment is said to be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$ and if $FV_ι(t) ∪ FV_μ(t) = ∅$.
To lighten the notations we will write $⊢ t : A$ instead of $Γ ⊢ t : A$ when
$Γ = •$.
\end{def}
\begin{rem}
Our first type system will only be able to work with terms not containing
$μ$-variables or term variables. The mechanism for handling such variables
will be introduced in later sections.
\end{rem}
\begin{rem}
In the following, we will only consider well-formed judgements. This
information will be kept implicit most of the time.
\end{rem}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B")}{Γ ⊢ u : A}{Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]")}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
\end{def}
\begin{rem}
The derivability of a judgement $⊢ t : A$ is equivalent to the provability
of the logical formula corresponding to $A$ in intuitionistic propositional
logic. As $t$ alone sufices to recover the derivation (only one rule can be
applied for every term constructor), we may think of it as a proof of $A$.
Consequently, we associate a computational behavious to a proof. For example,
a term $t$ of type $\f("A ⇒ B")$ will correspond to a procedure turning a
proof of the formula $A$ into a proof of the formula $B$.
\end{rem}

Let us now consider a few examples of typing derivations. First, we can show
that the term $t = \t("λf λx λy f {l₁ = x; l₂ = y;}")$ has type
$\f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")$ for any given types $A$, $B$
and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx λy f {l₁ = x; l₂ = y;}")
     : \f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C") ⊢ \t("λx λy f {l₁ = x; l₂ = y;}")
     : \f("A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A ⊢ \t("λy f {l₁ = x; l₂ = y;}")
     : \f("B ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("f {l₁ = x; l₂ = y;}") : C
   }{
     \axiomN{Ax}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ f
         : \f("{l₁ : A; l₂ : B;} ⇒ C")
     }
   }{
     \binaryN{×_i}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("{l₁ = x; l₂ = y;}")
         : \f("{l₁ : A; l₂ : B;}")
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ x : A
       }
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ y : B
       }
     }
   }
  }}}}
$$
\end{env}
Similarly, we can show that the term $u = \t("λf λx f x.l₁ x.l₂")$ is also
typable. It can be given the type $\f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")$
for any given types $A$, $B$ and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx f x.l₁ x.l₂") : \f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("A ⇒ B ⇒ C") ⊢ \t("λx f x.l₁ x.l₂") : \f("{l₁ : A; l₂ : B;} ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁ x.l₂") : C
   }{
     \binaryN{⇒_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁")
         : \f("B ⇒ C")
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ f
           : \f("A ⇒ B ⇒ C")
       }
     }{
       \unaryN{×_e}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₁") : A
       }{
         \axiomN{Ax}{
           f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
             : \f("{l₁ : A; l₂ : B;}")
         }
       }
     }
   }{
     \unaryN{×_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₂") : B
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
           : \f("{l₁ : A; l₂ : B;}")
       }
     }
   }
  }}}
$$
\end{env}
The terms $t$ and $u$ correspond respectively to the curryfication operation
and its inverse. The former turns a function taking as input a couple into
a function of two arguments, and the latter turns a function of two arguments
into a function taking as input a couple. Logically, these terms correspond
to both sides of a proof of the following theorem of intuitionistic
propositional logic.
$$ (A \land B → C) ↔ (A → B → C) $$

In the next two sections, we will present two rather orthogonal extensions
of our small type system. The former will provide a mechanism for handling
terms of the \lmcalc, which will allow us to type more terms of our language
and will enable classical reasoning.
(* *)
The second extension will be System F polymorphism, and it will allow
universal quantification over a type. Our system will then correspond
to predicate logic.

=<

=> First extension: \lmcalc and classical logic

We are now going to extend our type system with a mechanism for typing terms
of the \lmcalc, and not only terms of the $λ$-calculus. The \lmcalc provides
control structures, which have been shown to give a computational
interpretation to classical logic by Timothy Griffin \cite("Griffin1990"). As
a consequence, the obtained system will not be limited to intuitionistically
provable formulas anymore.

\begin{def}
A continuation context is a finite map $Δ$ over $\cal{V}_μ$ such that for all
$μ$-variable $α ∈ dom(Δ)$ we have $Δ(α) ∈ \cal{F}$. As for typing contexts,
we will represent continuation contexts using lists generated by the
following ||bnf|| grammar.
$$ Δ ::= • \| {Γ, α : A} $$
We will implicitly consider that variables can only be mapped once in a
continutation context, and that their order is not relevant.
\end{def}

\begin{def}
A typing judgement is a tuple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$, a
typing context $Γ$ and a continuation context $Δ$ that is denoted
$Γ ⊢ t : A; Δ$. A judgment is said to be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) ⊆ dom(Δ)$ and if $FV_ι(t) = ∅$. To lighten the
notations we will write $⊢ t : A; Δ$ (resp. $Γ ⊢ t : A$) instead of
$Γ ⊢ t : A; Δ$ when $Γ = •$ (resp. $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A; Δ}
  \hspace(1.6)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B; Δ}{Γ ⊢ \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(1.6)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B"); Δ}{Γ ⊢ u : A; Δ}{Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i; Δ]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}"); Δ}{Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j; Δ}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"); Δ}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
\end{def}

As an example, the following type derivation shows that the term
$\t("λf μα f λx [α]x")$ can be given a type corresponding to Peirce's Law.
This formula is not intuitionistically provable, and thus this type cannot
be inhabited by a term of the $λ$-calculus.
\begin{env}(scale 0.92)
$$
  \proofTree{
    \unaryN{⇒_i}{
      ⊢ \t("λf μα f λx [α]x") : \f("((A ⇒ B) ⇒ A) ⇒ A")
    }{
      \unaryN{μ}{
        f:\f("(A ⇒ B) ⇒ A") ⊢ \t("μα f λx [α]x") : A
      }{
        \binaryN{⇒_e}{
          f:\f("(A ⇒ B) ⇒ A") ⊢ \t("f λx [α]x") : A; α:A
        }{
          \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A") ⊢ f : \f("(A ⇒ B) ⇒ A"); α:A}
        }{
          \unaryN{⇒_i}{
            f:\f("(A ⇒ B) ⇒ A") ⊢ \t("λx [α]x") : \f("A ⇒ B"); α:A
          }{
            \unaryN{[{-}]}{
              f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ \t("[α]x") : A; α : A
            }{
              \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ x : A; α:A}
            }
          }
        }
      }
    }
  }
$$
\end{env}

=<

=> Second extension: polymorphism and universal quantification

We will now define a second extension of our type system, which will provide
us with more expressive types. Let us consider the term $\t("λx λy x")$,
which can be given type $\f("X ⇒ Y ⇒ X")$ given two types $X$ and $Y$.
$$
\proofTree{
  \unaryN{⇒_i}{⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
  \unaryN{⇒_i}{x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
    \axiomN{Ax}{x : X, y : Y ⊢ x : X}
  }}
}
$$
The term $\t("λx λy x")$ really corresponds to a function taking as input
two arguments, and returning the first one directly. Note that we do not need
to say anything about the nature of the arguments this function may accepts.
In fact, this function can be applied to arguments of any two types. This
information is not conveyed by the type $\f("X ⇒ Y ⇒ X")$, as it only
specifies that the function takes arguments of two particular types $X$ and
$Y$, and returns an element of type $X$.

To solve this expressivity problem, we extend our type system with a new
type constructor for universal quantification, or polymorphism. We will then
be able to use types like $\f("∀X ∀Y X ⇒ Y ⇒ X")$. The obtained system is
called System F, it was introduced by Jean-Yves Girard and John Reynolds
independently \mcite(["Girard1972";"Reynolds1974"]).

\begin{def}
The set of all types (or formulas) $\cal{F}$ is now built from a countable
set of type variables $\cal{V}_ο = \{X, Y, Z...\}$ using the following
||bnf|| grammar.
\Caml(
let _ = sidenote
  << $ A,B ::= \f("X") \| \f("A ⇒ B") \| \f("∀X A") \|
    \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]") $ >>
  << $ X ∈ \cal{V}_ο $ >>
)
We denote $FV_ο(A)$ the set of free type variables contained in $A$. Given
a typing context $Γ$ we will write $FV_ο(Γ)$ the set of free type variables
contained in the types of $Γ$.
\end{def}
\begin{rem}
To lighten the notations, we will consider that universal quantification
binds stronger than the function type. As a consequence, we will read
$\f("∀X ∀Y X ⇒ Y ⇒ X")$ as $\f("∀X (∀Y (X ⇒ (Y ⇒ X)))")$.
\end{rem}

As types can now contain free variables, our typing judgments will carry
a list of type variables with the invariant that only these type variables
can appera free in the judgement.
\begin{def}
A type variable context is a finite set of type variables denoted $Σ$. For
convenience, we will represent type variable contexts using lists generated
using the following ||bnf|| grammar.
\Caml(let _ = sidenote << $ Σ ::= • \| {Σ, X} $ >> << $ X ∈ \cal{V}_ο $ >>)
However, we need to keep in mind that type variables can only appear once
in a type variable context, and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgment is a quadruple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$,
a typing context $Γ$ and a type variable context $Γ$ that is denoted
$Σ; Γ ⊢ t : A$. A judgment is sait do be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) = ∅$, $FV_ι(t) = ∅$, $FV_ο(A) ⊆ Σ$ and
$FV_ο(Γ) ⊆ Σ$. To lighten the notations we will write $Γ ⊢ t : A$ (resp.
$Σ ⊢ t : A$, resp. $⊢ t : A$) instead of $Σ; Γ ⊢ t : A$ when $Γ = •$ (resp.
$Δ = •$, resp. $Γ = •$ and $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system. Note that a rule only
applies if all the involved judgments are well-formed.
$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢ x : A}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B}{Σ; Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(4.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B")}{Σ; Γ ⊢ u : A}{Σ; Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢ v_i : A_i]_{i∈I}}{
    Σ; Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ; Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Σ; Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢ v : A_j)}{
    Σ ⊢ (Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"))}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
$$
  \unaryRN{{∀}_i}{Σ, X; Γ ⊢ t : A}{Σ; Γ ⊢ t : \f("∀X A")}
  \hspace(4.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A")}{Σ; Γ ⊢ t : \f("A[X≔B]")}
$$
\end{def}
\begin{rem}
The condition on the well-formedness of all the judgments imply that the
$∀_i$ rule may only apply when $X ∉ FV_ο(Γ)$. If it were not the case then
the conclusion judgments of the rule could not be well-formed.
\end{rem}

As an example, the proof that $\t("λx λy x")$ has type $\f("∀X ∀Y X ⇒ Y ⇒ X")$
can be derived as follows in the system. Note that this type is fully
specified, in the sense that we did not say anything like
"for all given types".
$$
  \proofTree{
    \unaryN{∀_i}{⊢ \t("λx λy x") : \f("∀X ∀Y X ⇒ Y ⇒ X")}{
    \unaryN{∀_i}{X ⊢ \t("λx λy x") : \f("∀Y X ⇒ Y ⇒ X")}{
      \unaryN{⇒_i}{X, Y ⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
        \unaryN{⇒_i}{X, Y; x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
          \axiomN{Ax}{X, Y; x : X, y : Y ⊢ x : X}
  }}}}}
$$

It would seem that polymophism and classical logic are two rather orthogonal
extensions of the simple system. However, we will see in the next section that
they actually interact in a very subtle way. Indeed, the naive approach breaks
the type safety and the consistency of the system. More generally, the
problem is related to call-by-value evaluation and side-effects. Historicaly,
it was first identified in the context of ||ml||.

=<







\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system. Note that a rule only
applies if all the involved judgments are well-formed.
$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢_\tval x : A; Δ}
  \hspace(4.0)
  \unaryRN{↑}{Σ;Γ ⊢_\tval v : A; Δ}{Σ;Γ ⊢ v : A; Δ}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B; Δ}{
    Σ; Γ ⊢_\tval \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(4.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B"); Δ}{Σ; Γ ⊢ u : A; Δ}{
    Σ; Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢_\tval v_i : A_i; Δ]_{i∈I}}{
    Σ; Γ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ;Γ ⊢_\tval v : \f("{(li : Ai) i∈I}"); Δ}{
    Σ;Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢_\tval v : A_j; Δ)}{
    Σ ⊢ (Γ ⊢_\tval \v("Cj[v]") : \f("[(Ci : Ai) i∈I]")); Δ}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢_\tval v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{{∀}_i}{Σ, X; Γ ⊢_\tval v : A; Δ}{Σ; Γ ⊢_\tval v : \f("∀X A"); Δ}
  \hspace(4.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A"); Δ}{Σ; Γ ⊢ t : \f("A[X≔B]"); Δ}
$$
\end{def}
Here again, the $∀_i$ rule does not apply if $X ∈ FV_ο(Γ)$ or $X ∈ FV_ο(Δ)$.
\begin{rem}
The $↑$ rule is essential for building proofs. It arises naturally as values
are terms, and hence a value judgement subsumes the corresponding term
judgment.
\end{rem}

As an example, we can derive again the type of $\t("λf μα f λx [α]x")$ as
follows. Its type still corresponds to Peirce's Law, but we are now able to
polymorphism.
\begin{env}(scale 0.86)
$$
  \proofTree{
    \unaryN{∀_i}{⊢ \t("λf μα f λx [α]x") : \f("∀X ∀Y ((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{∀_i}{X ⊢ \t("λf μα f λx [α]x") : \f("∀Y ((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{⇒_i}{X,Y ⊢ \t("λf μα f λx [α]x") : \f("((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{μ}{X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("μα f λx [α]x") : X}{
      \binaryN{⇒_e}{
        X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("f λx [α]x") : X; α:X
      }{
        \axiomN{Ax}{X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ f : \f("(X ⇒ Y) ⇒ X"); α:X}
      }{
        \unaryN{⇒_i}{
          X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("λx [α]x") : \f("X ⇒ Y"); α:X
        }{
          \unaryN{[{-}]}{
            X,Y; f:\f("(X ⇒ Y) ⇒ X"), x:X ⊢ \t("[α]x") : X; α : X
          }{
            \axiomN{Ax}{X,Y; f:\f("(X ⇒ Y) ⇒ X"), x:X ⊢ x : X; α:X}
          }
        }
      }
  }}}}}
$$
\end{env}
