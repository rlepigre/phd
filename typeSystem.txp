\Caml(
  open Diagrams
  open ProofTree
  open Lang
)
\Include{Macros}

=> A type system for a higher-order classical \sc{ml} \label("typeSystem")

In this chapter, we introduce the formalisms of type theory and classical
realizability. These theories are used here to build a higher-order type
system for the language defined in \chapter("calculus"). Our types will be
interpreted using standard realisability techniques, which will provide a
semantical justification to our typing rules.

=> Simple types

In order to prevent undesired computational behaviours such as runtime
errors, functional programming languages rely on syntactic checks. We
will first consider a small type system with only three type constructors:
functions, products (in the form of records) and sums (in the form of
variants).
\begin{def}
The set of all types $\cal{F}$ is built using the following ||bnf|| grammar.
$$ A,B ::= \f("A ⇒ B") \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")$$
\end{def}
\begin{rem}
To lighten the notations, we will consider the function type to be right
associative. That is, we will always read a type of the form
$\f("A ⇒ B ⇒ C")$ as $\f("A ⇒ (B ⇒ C)")$.
\end{rem}
Through the Curry-Howard isomorphism, it is possible to see our type system
as a logic. In particular, a type can be read as a formula in which the
arrow type corresponds to logical implication. Similarly, product and sum
types can be interpreted as logical conjunction and disjunction.

To be able to assign a type to terms containing free variables, we need to
use typing contexts. A typing context will map variables to their assumed
type. Logically, a context will simply correspond to a set of hypothesis.
That is, a set of formulas that are assumed to be true.
\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ such that for all
$λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent contexts using lists generated using the following ||bnf|| grammar.
$$ Γ ::= • \| {Γ, x : A} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgement is a triple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$ and
a context $Γ$ that is denoted $Γ ⊢ t : A$. A judgment is said to be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$ and if $FV_ι(t) ∪ FV_μ(t) = ∅$.
To lighten the notations we will write $⊢ t : A$ instead of $Γ ⊢ t : A$ when
$Γ = •$.
\end{def}
\begin{rem}
Our first type system will only be able to work with terms not containing
$μ$-variables or term variables. The mechanism for handling such variables
will be introduced in later sections.
\end{rem}
\begin{rem}
In the following, we will only consider well-formed judgements. This
information will be kept implicit most of the time.
\end{rem}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B")}{Γ ⊢ u : A}{Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]")}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
\end{def}
\begin{rem}
The derivability of a judgement $⊢ t : A$ is equivalent to the provability
of the logical formula corresponding to $A$ in intuitionistic propositional
logic. As $t$ alone sufices to recover the derivation (only one rule can be
applied for every term constructor), we may think of it as a proof of $A$.
Consequently, we associate a computational behavious to a proof. For example,
a term $t$ of type $\f("A ⇒ B")$ will correspond to a procedure turning a
proof of the formula $A$ into a proof of the formula $B$.
\end{rem}

Let us now consider a few examples of typing derivations. First, we can show
that the term $t = \t("λf λx λy f {l₁ = x; l₂ = y;}")$ has type
$\f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")$ for any given types $A$, $B$
and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx λy f {l₁ = x; l₂ = y;}")
     : \f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C") ⊢ \t("λx λy f {l₁ = x; l₂ = y;}")
     : \f("A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A ⊢ \t("λy f {l₁ = x; l₂ = y;}")
     : \f("B ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("f {l₁ = x; l₂ = y;}") : C
   }{
     \axiomN{Ax}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ f
         : \f("{l₁ : A; l₂ : B;} ⇒ C")
     }
   }{
     \binaryN{×_i}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("{l₁ = x; l₂ = y;}")
         : \f("{l₁ : A; l₂ : B;}")
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ x : A
       }
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ y : B
       }
     }
   }
  }}}}
$$
\end{env}
Similarly, we can show that the term $u = \t("λf λx f x.l₁ x.l₂")$ is also
typable. It can be given the type $\f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")$
for any given types $A$, $B$ and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx f x.l₁ x.l₂") : \f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("A ⇒ B ⇒ C") ⊢ \t("λx f x.l₁ x.l₂") : \f("{l₁ : A; l₂ : B;} ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁ x.l₂") : C
   }{
     \binaryN{⇒_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁")
         : \f("B ⇒ C")
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ f
           : \f("A ⇒ B ⇒ C")
       }
     }{
       \unaryN{×_e}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₁") : A
       }{
         \axiomN{Ax}{
           f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
             : \f("{l₁ : A; l₂ : B;}")
         }
       }
     }
   }{
     \unaryN{×_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₂") : B
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
           : \f("{l₁ : A; l₂ : B;}")
       }
     }
   }
  }}}
$$
\end{env}
The terms $t$ and $u$ correspond respectively to the curryfication operation
and its inverse. The former turns a function taking as input a couple into
a function of two arguments, and the latter turns a function of two arguments
into a function taking as input a couple. Logically, these terms correspond
to both sides of a proof of the following theorem of intuitionistic
propositional logic.
$$ (A \land B → C) ↔ (A → B → C) $$

In the next two sections, we will present two rather orthogonal extensions
of our small type system. The former will provide a mechanism for handling
terms of the \lmcalc, which will allow us to type more terms of our language
and will enable classical reasoning.
(* *)
The second extension will be System F polymorphism, and it will allow
universal quantification over a type. Our system will then correspond
to predicate logic.

=<

=> First extension: \lmcalc and classical logic

We are now going to extend our type system with a mechanism for typing terms
of the \lmcalc, and not only terms of the $λ$-calculus. The \lmcalc provides
control structures, which have been shown to give a computational
interpretation to classical logic by Timothy Griffin \cite("Griffin1990"). As
a consequence, the obtained system will not be limited to intuitionistically
provable formulas anymore.

\begin{def}
A continuation context is a finite map $Δ$ over $\cal{V}_μ$ such that for all
$μ$-variable $α ∈ dom(Δ)$ we have $Δ(α) ∈ \cal{F}$. As for typing contexts,
we will represent continuation contexts using lists generated by the
following ||bnf|| grammar.
$$ Δ ::= • \| {Γ, α : A} $$
We will implicitly consider that variables can only be mapped once in a
continutation context, and that their order is not relevant.
\end{def}

\begin{def}
A typing judgement is a tuple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$, a
typing context $Γ$ and a continuation context $Δ$ that is denoted
$Γ ⊢ t : A; Δ$. A judgment is said to be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) ⊆ dom(Δ)$ and if $FV_ι(t) = ∅$. To lighten the
notations we will write $⊢ t : A; Δ$ (resp. $Γ ⊢ t : A$) instead of
$Γ ⊢ t : A; Δ$ when $Γ = •$ (resp. $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A; Δ}
  \hspace(1.6)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B; Δ}{Γ ⊢ \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(1.6)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B"); Δ}{Γ ⊢ u : A; Δ}{Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i; Δ]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}"); Δ}{Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j; Δ}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"); Δ}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
\end{def}

As an example, the following type derivation shows that the term
$\t("λf μα f λx [α]x")$ can be given a type corresponding to Peirce's Law.
This formula is not intuitionistically provable, and thus this type cannot
be inhabited by a term of the $λ$-calculus.
\begin{env}(scale 0.92)
$$
  \proofTree{
    \unaryN{⇒_i}{
      ⊢ \t("λf μα f λx [α]x") : \f("((A ⇒ B) ⇒ A) ⇒ A")
    }{
      \unaryN{μ}{
        f:\f("(A ⇒ B) ⇒ A") ⊢ \t("μα f λx [α]x") : A
      }{
        \binaryN{⇒_e}{
          f:\f("(A ⇒ B) ⇒ A") ⊢ \t("f λx [α]x") : A; α:A
        }{
          \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A") ⊢ f : \f("(A ⇒ B) ⇒ A"); α:A}
        }{
          \unaryN{⇒_i}{
            f:\f("(A ⇒ B) ⇒ A") ⊢ \t("λx [α]x") : \f("A ⇒ B"); α:A
          }{
            \unaryN{[{-}]}{
              f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ \t("[α]x") : A; α : A
            }{
              \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ x : A; α:A}
            }
          }
        }
      }
    }
  }
$$
\end{env}

=<

=> Second extension: polymorphism and universal quantification

We will now define a second extension of our type system, which will provide
us with more expressive types. Let us consider the term $\t("λx λy x")$,
which can be given type $\f("X ⇒ Y ⇒ X")$ given two types $X$ and $Y$.
$$
\proofTree{
  \unaryN{⇒_i}{⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
  \unaryN{⇒_i}{x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
    \axiomN{Ax}{x : X, y : Y ⊢ x : X}
  }}
}
$$
The term $\t("λx λy x")$ really corresponds to a function taking as input
two arguments, and returning the first directly. Note that we do not need
to say anything about the nature of the arguments this function may accepts.
In fact, this function can be applied to arguments of any two types. This
information is not conveyed by the type $\f("X ⇒ Y ⇒ X")$, as it only
specifies that the function takes arguments of two particular types $X$ and
$Y$, and returns an element of type $X$.

To solve this expressivity problem, we extend our type system with a new
type constructor for universal quantification, or polymorphism. We will then
be able to use types like $\f("∀X ∀Y X ⇒ Y ⇒ X")$. The obtained system is
called System F, it was introduced by Jean-Yves Girard and John Reynolds
independently \mcite(["Girard1972";"Reynolds1974"]).

\begin{def}
The set of types (or formulas) $\cal{F}$ is built from a countable set of
type variables $\cal{V}_ο = \{X, Y, Z...\}$ using the following ||bnf||
grammar.
\Caml(
let _ = sidenote
  << $ A,B ::= \f("X") \| \f("A ⇒ B") \| \f("∀X A") $ >>
  << $ X ∈ \cal{V}_ο $ >>
)
We denote $FV(A)$ the set of tree type variables contained in $A$.
\end{def}
\begin{rem}
To lighten the notations, we will consider that universal quantification
binds stronger than the function type. As a consequence, we will read
$\f("∀X ∀Y X ⇒ Y ⇒ X")$ as $\f("∀X (∀Y (X ⇒ (Y ⇒ X)))")$.
\end{rem}

$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢ x : A}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B}{Σ; Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(2.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B")}{Σ; Γ ⊢ u : A}{Σ; Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢ v_i : A_i]_{i∈I}}{
    Σ; Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ; Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Σ; Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢ v : A_j)}{
    Σ ⊢ (Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"))}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
$$
  \binaryRN{{∀}_i}{Σ, X; Γ ⊢ t : A}{X ∉ FV(Γ)}{Σ; Γ ⊢ t : \f("∀X A")}
  \hspace(2.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A")}{Σ; Γ ⊢ t : \f("A[X≔B]")}
$$

As an example, the proof that $\t("λx λy x")$ has type $\f("∀X ∀Y X ⇒ Y ⇒ X")$
can be derived as follows in the system. Note that this type is fully
specified, in the sense that we did not say anything like
"for all give types".
$$
  \proofTree{
    \binaryN{∀_i}{⊢ \t("λx λy x") : \f("∀X ∀Y X ⇒ Y ⇒ X")}{
      \binaryN{∀_i}{X ⊢ \t("λx λy x") : \f("∀Y X ⇒ Y ⇒ X")}{
        \unaryN{⇒_i}{X, Y ⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
          \unaryN{⇒_i}{X, Y; x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
            \axiomN{Ax}{X, Y; x : X, y : Y ⊢ x : X}
          }
        }
      }{\hyp{Y ∉ FV(•)}}
    }{\hyp{X ∉ FV(•)}}
  }
$$

It would seem that polymophism and classical logic are two rather orthogonal
extensions of the simple system. However, we will see in the next section that
they actually interact in a very subtle way. Indeed, the naive approach breaks
the type safety and the consistency of the system. More generally, the
problem is related to call-by-value evaluation and side-effects. Historicaly,
it was first identified in the context of ||ml||.

=<

=> A brief history of ||ml|| and value restriction

A soundness issue related to side-effects and call-by-value evaluation
arose in the seventies with the advent of ML. The problem stems from a
bad interaction between side-effects and Hindley-Milner polymorphism. It was
first formulated in terms of references \citen("Wright1995")("Section 2").
To extend ||ml|| with reference, the naive approach consist in providing the
following three polymorphic procedures (in ||OCaml|| syntax).
### OCaml
  val ref  : 'a -> 'a ref
  val (:=) : 'a ref -> 'a -> unit
  val (!)  : 'a ref -> 'a
###
However, this leads to trouble when working with references of a polymorphic
type. The problem is demonstrated by the following example, which is accepted
by the naive extension of the type system.
### OCaml
  let l = ref [] in
  l := [true]; (List.hd !l) + 1
###
On the first line, variable ##l## is given the polymorphic type
##'a list ref##, which can be unified both with ##bool list ref## and
and ##int list ref## on the second line. This is an obvious violation of
type safety, which is the purpose of a type system.

To solve the problem, many alternative type systems were designed (e.g.
\mcite(["Tofte1990"; "Damas1982"; "Leroy1991"; "Leroy1993"])). However, they
all introduced a complexity that contrasted with the elegance and simplicity
of ||ml|| systems (see \citen("Wright1995")("Section 2") and
\citen("Garrigue2004")("Section 2") for a detailed account).
(* *)
A simple and elegant solution was finally found by Andrew Wright in the
nineties. He suggested restricting generalization in let-bindings (i.e.
expressions of the form ##let x = u in t##) to cases where the bound term
is a syntactic value \mcite(["Wright1994";"Wright1995"]). Indeed,
polymorphism is strongly related to let-bindings in ||ml||.
(* *)
In slightly more expressive type systems, this restriction appears in the
typing rule for the introduction of the universal quantifier.
$$ \binaryR{Γ ⊢ t : A}{X ∉ FV(Γ)}{Γ ⊢ t : ∀X A} $$
This rule cannot be proved safe (in a call-by-value system with side-effects)
if $t$ is not a syntactic value.

In this thesis, we consider control structures, which have been shown to give
a computational interpretation to classical logic by Timothy Griffin
\cite("Griffin1990").
(* *)
In 1991, Robert Harper and Mark Lillibridge found a complex program breaking
the type safety of ML extended with the control operator \emph{call/cc}
\cite("Harper1991").
### OCaml
  let later = callcc
    (fun k -> ((fun x -> x), (fun f -> throw k (f, (fun _ -> ())))))
  in
  print_string ((fst later) "hello world!");
  (snd later) (fun x -> x+2)
###

### OCaml
  callcc : ('a cont -> 'a) -> 'a
  throw  : 'a cont -> 'a -> 'b
###
As with references, value restriction solves the inconsistency and yields a
sound type system. 
(* *)
In the context of the \lmcalc, the soundness issue arises when evaluating
$\t("t (μα u)")$ when $\t("μα u")$ has a polymorphic type. Such a situation
cannot happen with value restriction since $\t("μα u")$ is not a value.

=<

=> Higher-order type system

In this section, we present the higher-order type system that will serve as
a base for the work presented in this thesis. Although the following extends
definitions given in the previous sections, we choose not to avoid
repetitions so that this section remains completely self-contained.

In this thesis, we consider a programming language that is very similar to
the functional programming languages of the ||ml|| family (e.g. SML or
OCaml). In the following, we provide a full formal definition of our
type system. It will provide a product type for records, a sum type for
variants, polymorphism and higher-order quantification, least and greatest
fixpoints.
\begin{def}
We denote $\cal{S}₀$ the set of all the atomic sorts. We require this set to
be finite (or at least countable), and to contain the sort of propositions
denoted $ο$.
\end{def}
\begin{def}
The set of all the sorts is generated from the set of atomic sorts $\cal{S}₀$
using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= {s→r} \| ξ$ >> << $ξ∈\cal{S}₀$ >>)
\end{def}
\begin{def}
We require disjoint countable sets of variables $\cal{V}_s$ for every sort
$s ∈ \cal{S}$. In particular, we will take $\cal{V}_ο = \{X, Y, Z...\}$. The
set of all the variables is denoted $\cal{V}$ and is defined as
$\cal{V} = \bigunion_{s∈\cal{S}} \cal{V}_s$.
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is generated from the set $\cal{V}$
using the following ||bnf|| grammar.
$$
  A,B ::= \f("χ") \| \f("(χ ↦ A)") \| \f("A(B)") \| \f("A ⇒ B") \|
          \f("{(li : Ai) i∈I}") \mbr \| \f("[(Ci : Ai) i∈I]")
          \| \f("∀χ A") \| \f("∃χ A") \| \f("μX A") \| \f("νX A")
$$
\end{def}
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, sorting contexts are
represented using comma-separated lists of sort assignments of the form
$χ : s$. variable of $\cal{V}$ are mapped at most onces in a sorting context,
and their order is irrelevant.
\end{def}

\begin{def}
A sorting judgment is a trile of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the following rules.
$$
\axiomR{Σ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ ↦ A)") : s → r}
\hspace(3.0)
\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}
$$
$$
\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ A ⇒ B : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}
$$
$$
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∀χ A") : r}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∃χ A") : r}
\hspace(3.0)
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("μX A") : ο}
$$
$$
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("νX A") : ο}
$$
\end{def}

\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ and $\cal{V}_μ$ such
that for all $λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$ and for all
$μ$-variable $α ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent typing contexts using comma-separated lists of mappings generated
of the form $x : A$ or $α : A^⊥$. Note that variables can only be mapped once
in a typing context, and that their order is irrelevant.
\end{def}
\begin{def}
A typing context $Γ$ is said to be valid under a sorting context $Σ$ if for
all mapping $x:A$ or $α:A^⊥$ in $Γ$ the judgment $Σ ⊢ Γ(x) : ο$ is valid. If
$Γ$ is valid under $Σ$ then we write $Σ ⊢ Γ$.
\end{def}

(* Typing rules. *)
$$
  \axiomRN{Ax}{Γ, x : A ⊢_\tval x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢_\tval λx t: A ⇒ B}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : A ⇒ B}{Γ ⊢ u : A}{Γ ⊢ (t) u : B}
$$
$$
  \unaryRN{↑}{Γ ⊢_\tval v : A}{Γ ⊢ v : A}
  \hspace(4.0)
  \unaryRN{μ}{Γ, α : ¬A ⊢ t : A}{Γ ⊢ μα t : A}
  \hspace(4.0)
  \unaryRN{[{-}]}{Γ, α : ¬A ⊢ t : A}{Γ, α : ¬A  ⊢ [α] t : B}
$$
$$
  \binaryRN{∀_i}{Γ, X_n ⊢_\tval v : A}{X_n ∉ FV(Γ)}{Γ ⊢_\tval v : ∀X_n A}
  \hspace(4.0)
  \unaryRN{∀_e}{Γ ⊢ t : ∀X_n A}{Γ ⊢ t : A[X_n := P_n]}
$$
$$
  \unaryRN{∃_i}{Γ ⊢ t : A[X_n := P_n]}{Γ ⊢ t : ∃X_n A}
  \hspace(4.0)
  \binaryRN{∃_e}{Γ, X_n, x : A ⊢ t : B}{X_n ∉ FV(Γ,B)}{Γ, x : ∃X_n A ⊢ t : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢_\tval v_i : A_i]_{1≤i≤n}}{
    Γ ⊢_\tval \{l_i = v_i\}_{1≤i≤n} : \{l_i : A_i\}_{1≤i≤n}
  }
  \hspace(4.0)
  \unaryRN{×_e}{Γ ⊢_\tval v : \{l_i : A_i\}_{1≤i≤n}}{Γ ⊢ v{.}l_i : A_i}
$$
$$
  \unaryRN{+_i}{Γ ⊢_\tval v : A_i}{Γ ⊢ C_i[v] : [C_i : A_i]_{1≤i≤n}}
  \hspace(1.0)
  \binaryRN{+_e}{Γ ⊢_\tval v : [C_i : A_i]_{1≤i≤n}}{
    [Γ, x_i : A_i ⊢ t_i : B]_{1≤i≤n}
  }{
    Γ ⊢ case_v [C_i[x_i] → t_i]_{1≤i≤n} : B
  }
$$


(* Sorting rules. *)
$$
\binaryR{Δ ⊢ A : ο}{Δ ⊢ B : ο}{Δ ⊢ A ⇒ B : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ \{l_i : A_i\}_{i∈I} : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ [C_i : A_i]_{i∈I} : ο}
$$
$$
\axiomR{Δ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ E : r}{Δ ⊢ (χ^s ↦ E) : s → r}
\hspace(3.0)
\binaryR{Δ ⊢ E : s → r}{Δ ⊢ F : s}{Δ ⊢ E(F) : r}
$$
$$
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∀χ^s A : ο}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∃χ^s A : ο}
$$
$$
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ μX A : ο}
\hspace(3.0)
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ νX A : ο}
$$
(* TODO *)



=<

=> Call-by-value realisability model

... (* TODO *)

=<

=<
