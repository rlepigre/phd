\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^\bot $>
  let ts a = <$ ⟦\f(a)⟧^{\bot\bot} $>
)
\Include{Macros}

=> Higher-order type system and semantics \label("typeSystem")

In this chapter, we present a new type system which distinguishing feature
is an embedded notion of program equivalence. It enables the specification
of equational properties over programs, which can then be proved using
equational reasoning. Our types are interpreted using standard classical
realisability techniques, which allows for a semantical justification of
our typing rules.

=> Observational equivalence type

One of the main goals of this thesis is to build a type system that can be
used to reason about programs. To achieve this goal, we need to be able to
specify program behaviours using types. We hence introduce equality types
of the form $\f("t ≡ u")$, where $t$ and $u$ are (possibly untyped) terms.
Intuitively, an equality type is interpreted as $⊤$ (i.e. logical truth,
the bigest type) if $t ≡_{≻} u$, and as $⊥$ (i.e. logical absurdity, the
empty type) if $t \nequiv_{≻} u$. For example, the type
$\f("(λx x) λx x ≡ λx x")$ is inhabited as $\t("(λx x) λx x") ≡_{≻}
\t("λx x")$ according to \thmRef("cbvbeta"), but $\f("λx x ≡ {}")$ is empty
as $\t("λx x") \nequiv_{≻} \t("{}")$ according to \thmRef("nequiv").

Of course, it is undecidable whether two terms are equivalent or not. As a
consequence, we will not be able to decide, in general, whether an equality
type is inhabited or not. We will hence need to rely on a partial decision
procedure that will only approximate our observational equivalence relation.
\begin{thm}
Given two terms $t ∈ Λ$ and $u ∈ Λ$ it is undecidable whether $t ≡_{≻} u$
or $t \nequiv_{≡} u$.
\begin{proof}
We are going to encode the halting problem $H_t$ using equivalence. In our
system, $H_t$ can be stated as ${\p("t ∗ ε")} {⇓}_{≻}$. Let us
consider a term $Ω ∈ Λ$ such that ${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$.
We will now show that $H_t$ is equivalent to
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. Let us suppose $H_t$ and show
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. We need to find a stack $π ∈ Π$ such
that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ and ${\p("Ω ∗ π")} {⇑}_{≻}$. This is in fact
true for all $π$ as ${\p("Ω ∗ π")} {⇑}_{≻}$ by hypothesis and
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")} {⇓}_{≻}$ since we supposed $H_t$. We know
suppose ${\t("[ε]t") \nequiv_{≻} \t("Ω")}$ and show $H_t$. By definition,
there must be a stack $π ∈ Π$ such that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ since
${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$. Now since we have
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")}$ we obtain $H_t$.
\end{proof}
\end{thm}

In the system, proving a program equivalence amounts to showing that the
corresponding equivalence type is inhabited. However, an equivalence type
may also be used as an assumption. For example, it is possible to define
a function which input type is an equivalence. As a consequence, we are
going to need a form of context containing a set of program equivalences
that are assumed to be true.
\begin{def}
An equational context $Ξ ⊆ \cal{P}(Λ × Λ)$ is a finite set of couples
of terms denoting hypothetical equivalences. For convenience, we will
represent equational contexts using lists generated using the following
||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Ξ ::= • \| {Ξ, t ≡ u}$ >> << $t,u ∈ Λ$ >>)
\end{def}

(* TODO more *)

\begin{def}
Given an equational context $Ξ$ and a substitution $ρ$, we write $ρ ⊩ Ξ$ if
for every $(t,u) ∈ Ξ$ we have $\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}
\begin{def}
Let $Ξ$ be an equational context and $t ∈ Λ$ and $u ∈ Λ$ be two terms. We
write $Ξ ⊢ t ≡ u$ if our (unspecified by supposed correct) decision
procedure is able to show that for every substitution $ρ$ such that $ρ ⊩ Ξ$
we have $\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}

Although equality types enable the derivation of simple equational
properties, their use is rather limited without a form of quantification.
Indeed, they can only be used to specify static equivalences like
$\t("(λx x) {}") ≡_{≻} \t("{}")$, but not general properties like
"$\t("(λx x) v") ≡_{≻} \t("v")$ for every value $v$".

=<
=> Untyped quantification and membership predicate

A term $t ∈ Λ$ can contain free variables of several sorts: $λ$-variables
(i.e. value variables), term variables and $μ$-variables (i.e. stack
variables). As open terms may appear in types, and in particular in equality
types, it is natural to allow universal and existential quantification over
all three sorts of variables. We can hence encode properties like
$\f("∀y (λx x) y ≡ y")$ or $\f("∀x ∀y x ≡ y ⇒ C[x] ≡ C[y]")$.
\begin{rem}
It is not clear whether quantification over stacks has a parctical use. We
only include it as it fits well in the framework and has no extra cost.
\end{rem}

(* TODO *)

Quantifying over all the (closed) values or terms is not enough. Indeed, it
is sometimes required to quantify over the values or terms of a given type
only. To this aim, we introduce a membership type constructor $\f("t ∈ A")$
where $t ∈ Λ$ is a term and $A$ is a type. Intuitively, the element of a
type $\f("t ∈ A")$ are the elements of $A$ that are equivalent to $t$. In
particular, $\f("t ∈ A")$ is empty if $t$ does not have type $A$.

When a membership type is used as the argument type of a function (i.e. as
an asumption)...

(* TODO *)

A form of dependent function type can be encoded in the following way using
universal quantification and a membership type.
$$ Π_{a : A} B ≔ \f("∀a (a∈A ⇒ B)") $$
And dually, a dependent pair type can be encoded with existential
quantification and a membership type.
$$ Σ_{a : A} B ≔ \f("∃a (a∈A × B)")$$
\begin{rem}
Note that nothing prevents the term variable $a$ to appear in $A$ in a in
the types $\f("∀a (a∈A ⇒ B)")$ and $\f("∃a (a∈A × B)")$.
\end{rem}

=<
=> Sorts and higher-order types

Our type system allows universal and existential quantification over
several sorts of objects. There are first order quantifiers ranging over
values, terms and stack, as shown in the previous section. And the system
also provides second order quantification (i.e. quantification over types),
which corresponds to System F polymorphism and type abstraction. All of
these different forms of quantifiers are handled uniformly in the syntax
and in the semantics thanks to a higher-order formulation.

The higher-order features of the system allow us to define (and quantify
over) types with parameters of any sort. For example, we can define a type
parametrized by another type and a term. This leads to a system in which
it is syntactically correct to use a term or a (not fully applied) parametric
type as a type, although it does not make sense. The usual approach to make
sure that this does not happen is to assign a form of type (called sort) to
the types themselves.
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= κ \| {s→r}$ >> << $κ∈\cal{S}₀$ >>)
\end{def}

(* TODO more *)
\begin{def}
We require a countable set $\cal{V}_ο = \{X, Y, Z...\}$ of propositional
variables that does not intersect with $\cal{V}_ι$, $\cal{V}_τ$ and
$\cal{V}_σ$.
\end{def}
\begin{def}
We require a countable set of variables $\cal{V} = \{χ, ξ, φ...\}$ such that
for every atomic sort $s ∈ \cal{S}₀$ we have $\cal{V}_s ⊆ \cal{V}$.
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is built from $\cal{V}$, $Λ_{val}$,
$Λ$ and $Π$ using the following ||bnf|| grammar.

\linesBefore(1)
\begin{center}
$ A,B ::= v \| t \| π \| \f("χ") \| \f("(χ^s ↦ A)") \| \f("A(B)")
  \| \f("A⇒B") \| \f("t∈A") \| \f("A | t≡u")$

$ \id([]) \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")
  \| \f("∀χ^s A") \| \f("∃χ^s A") $
\end{center}
\end{def}

(* TODO more *)

\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, we will represent
sorting contexts using comma-separated lists of sort assignments generated
by the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Σ ::= • \| {Σ, χ : s}$ >>
  << $χ ∈ \cal{V}, s ∈ \cal{S} $ >>)
\end{def}
\begin{def}
A sorting judgment is a triple of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the following deduction rules.
$$
\unaryR{Σ, x : ι ⊢ \t("t") : τ}{Σ ⊢ \v("λx t") : ι}
\hspace(3.0)
\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \v("C[v]") : ι}
\hspace(3.0)
\unaryR{\{Σ ⊢ \v("vi") : ι\}_{i∈I}}{Σ ⊢ \v("{(li = vi) i∈I}") : ι}
$$
$$
\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("v") : τ}
\hspace(3.0)
\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \t("u") : τ}{Σ ⊢ \t("t u") : τ}
\hspace(3.0)
\unaryR{Σ, α : σ ⊢ \t("t") : τ}{Σ ⊢ \t("μα t") : τ}
$$
$$
\binaryR{Σ ⊢ \s("π") : σ}{Σ ⊢ \t("t") : τ}{Σ ⊢ \t("[π]t") : τ}
\hspace(3.0)
\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("v.l") : τ}
\hspace(3.0)
\binaryR{Σ ⊢ v : ι}{\{Σ, x_i : ι ⊢ \t("ti") : τ\}_{i∈I}}{
  Σ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : τ}
$$
$$
\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("Y(t,v)") : τ}
\hspace(3.0)
\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("U(v)") : τ}
\hspace(3.0)
\binaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \v("w") : ι}{Σ ⊢ \t("δ(v,w)") : τ}
$$
$$
\axiomR{Σ ⊢ \s("ε") : σ}
\hspace(3.0)
\binaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \s("π") : σ}{Σ ⊢ \s("v · π") : σ}
\hspace(3.0)
\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \s("π") : σ}{Σ ⊢ \s("[t] π") : σ}
$$
$$
\axiomR{Σ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ ↦ A)") : s → r}
\hspace(3.0)
\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}
$$
$$
\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f("A ⇒ B") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}
$$
$$
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∀χ A") : r}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∃χ A") : r}
\hspace(3.0)
\binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f("t∈A") : ο}
$$
$$
\ternaryR{Σ ⊢ A : ο}{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f("A | t≡u") : ο}
$$
\end{def}

(* TODO more *)

=<
=> Value and term judgments

As our language is call-by-value and has operations generating side-effects,
we need to be careful to achieve type-safety. In particular, some of our
typing rules will not apply to terms in general, but only to values (as
mentioned in \chapter("intro")).

(* TODO more *)

\begin{def}
A //typing context// is a finite map $Γ$ over $\cal{V}_ι$ such that for all
$x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will represent
typing contexts using comma-separated lists of typ assignments generated
by the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Γ ::= • \| {Γ, x : A}$ >>
  << $x ∈ \cal{V}_ι, A ∈ \cal{F} $ >>)
Given a sorting context $Σ$, we say that the typing context $Γ$ is
well-formed and we write $Σ ⊢ Γ$ if for all $x ∈ dom(Γ)$ we have
$Σ ⊢ Γ(x) : ο$ and $Σ ⊢ x : ι$.
\end{def}
\begin{def}
A //continuation context// is a finite map $Δ$ over $\cal{V}_σ$ such that
for all $α ∈ dom(Δ)$ we have $Δ(α) ∈ \cal{F}$. For convenience, we will
represent typing contexts using comma-separated lists of typ assignments
generated by the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Δ ::= • \| {Δ, α : A}$ >>
  << $α ∈ \cal{V}_σ, A ∈ \cal{F} $ >>)
Given a sorting context $Σ$, we say that the continuation context $Δ$ is
well-formed and we write $Σ ⊢ Δ$ if for all $α ∈ dom(Δ)$ we have
$Σ ⊢ Δ(α) : ο$ and $Σ ⊢ α : σ$.
\end{def}
\begin{def}
Given a sorting context $Σ$, we say the the equational context $Σ$ is
well-formed if for all $(t,u) ∈ Σ$ we have $Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{def}
\begin{def}
A value judgement (resp. term judgment) is a tuple of a typing context $Γ$,
an equational context $Ξ$, a value $v ∈ Λ_{val}$ (resp. a term $t ∈ Λ$), a
type $A ∈ \cal{F}$ and a continuation context $Δ$ that is denoted
$Γ; Ξ ⊢_\tval v : A; Δ$ (resp. $Γ; Ξ ⊢ t : A; Δ$).
\end{def}
\begin{def}
Let $Σ$ be a sorting context. We say that the value judgemnt
$Γ; Ξ ⊢_\tval v : A; Δ$ is well-formed under $Σ$ if we have $Σ ⊢ Γ$,
$Σ ⊢ Ξ$, $Σ ⊢ Δ$, $Σ ⊢ v : ι$ and $Σ ⊢ A : ο$. In this case we write
$Σ ⊢ (Γ; Ξ ⊢_\tval v : A; Δ)$
\end{def}
\begin{def}
Let $Σ$ be a sorting context. We say that the term judgemnt $Γ; Ξ ⊢ t : A; Δ$
is well-formed under $Σ$ if we have $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ Δ$, $Σ ⊢ t : τ$
and $Σ ⊢ A : ο$. In this case we write $Σ ⊢ (Γ; Ξ ⊢ t : A; Δ)$
\end{def}

(* TODO more *)

=<
=> Call-by-value realisability semantics

The abstract machine presented in \chapter("calculus") is part of a
//classical realizability// machinery that will be built upon here.
We aim at obtaining a semantical interpretation of our higher-order
type system. As always in classical realizability, the model is
parametrized by a pole, which serves as an exchange point between
the world of programs and the world of execution contexts, which are
represented as stacks.
\begin{def}
A //pole// is a set of processes $\dbot ⊆ Λ×Π$ which is //saturated//
(i.e. closed under backward reduction). More formally, if we have
$q ∈ \dbot$ and $p ≻ q$ then $p ∈ \dbot$.
\end{def}

The notion of //orthogonality// is central in Krivine's classical
realizability. In this framework a type is interpreted (or realized) by
programs computing corresponding values. This interpretation is spread
in a three-layered construction, even though it is fully determined by
the first layer and the choice of the pole. The first layer consists of
a set of values that we will call the //raw semantics//. It gathers all
the syntactic values that should be considered as having the corresponding
type. As an example, if we were to consider the type of natural numbers,
its raw semantics would be the set $\{\hat{n} \| n ∈ \bbN\}$ where
$\hat{n}$ is some encoding of $n$.
(* *)
The second layer, called //falsity value//, is a set containing every
stack that is a candidate for building a valid process using any value
from the raw semantics. The notion of validity depends on the choice of
the pole. The third layer, called //truth value// is a set of terms that
is built by iterating the process once more. The formalism for the two
levels of orthogonality is given in the following definition.
\begin{def}\label("orthodef")
For every set $Φ ⊆ Λ_{val}$ we define a set $Φ^\bot ⊆ Π$ and a set
$Φ^{\bot\bot} ⊆ Λ$ as follows.
$$
  Φ^\bot = \{π∈Π \| ∀v∈Φ \p("v ∗ π") ∈ \dbot\}
  \hspace(3.0)
  Φ^{\bot\bot} = \{t∈Λ \| ∀π∈Φ^\bot \p("t ∗ π") ∈ \dbot\}
$$
\end{def}

We now give two general properties of orthogonality that are true in
every classical realizability model. They will be useful when proving
the soundness of our type system.
\begin{lem}\label("orthosimple")
If $Φ ⊆ Λ_{val}$ is a set of values, then $Φ ⊆ Φ^{\bot\bot}$.
\begin{proof}
We take $v ∈ Φ$ and show $v ∈ Φ^{\bot\bot}$. By definition we need to
show $\p("v∗π") ∈ \dbot$ for all stack $π ∈ Φ^\bot$. This is immediate
by definition of $Φ^\bot$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclstack")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If $Φ ⊆ Ψ$ then
$Ψ^\bot ⊆ Φ^\bot$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$, take $π ∈ Ψ^\bot$ and show that $π ∈ Φ^\bot$.
By definition, we know that for all $v ∈ Ψ$ we have $\p("v ∗ π") ∈ \dbot$.
Since $Φ ⊆ Ψ$, this is also true for all $v ∈ Φ$, and hence $π ∈ Φ^\bot$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclterm")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If
$Ψ^\bot ⊆ Φ^\bot$ then $Φ^{\bot\bot} ⊆ Ψ^{\bot\bot}$.
\begin{proof}
Let us suppose that $Ψ^⊥ ⊆ Φ^⊥$, take $t ∈ Φ^{⊥⊥}$ and show that
$t ∈ Ψ^{⊥⊥}$. By definition, we know that for all $π ∈ Φ^⊥$ we have
$\p("t ∗ π") ∈ \dbot$. Since $Ψ^⊥ ⊆ Φ^⊥$, this is also true for all
$π ∈ Ψ^⊥$, and hence $t ∈ Ψ^{⊥⊥}$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoblabla")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If $Φ ⊆ Ψ$ then
$Φ^{\bot\bot} ⊆ Ψ^{\bot\bot}$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$ and apply \lemRef("orthoinclstack") to obtain
$Ψ^⊥ ∈ Φ^⊥$. We can then conclude using \lemRef("orthoinclterm").
\end{proof}
\end{lem}

When choosing a pole, it is important to check that it does not yield a
degenerate model. In particular we need to check that no term is able to
face every stacks. If it were the case, such a term could be use as a
proof of $⊥$.
\begin{def}
A pole $\dbot ⊆ Λ×Π$ is said to be consistent if for every closed term
$t ∈ Λ$ there is a stack $π$ such that $\p("t ∗ π") ∉ \dbot$.
\end{def}

\begin{def}
To every type $A ∈ \cal{F}$ we associate a set of value $\vs("A") ⊆ Λ_{val}$
called its raw semantics. It is defined inductively on the structure of $A$
as follows.
\begin{center}
\diagram(
let _ =
  let line s m = [ vs s; <$=$>; m ] in
  array [`East ; `East ; `West]
  [ line "Φ"               <$ Φ $>
  ; line "(χ ↦ A)"         <$ Φ ↦ \vs("A[χ≔Φ]") $>
  ; line "A(B)"            <$ ⟦A⟧(⟦B⟧) $>
  ; line "A ⇒ B"           <$ \{\v("λx t") \| ∀v∈\vs("A")
                                 \t("t[x≔v]") ∈ \ts("B")\} $>
  ; line "{(li : Ai) i∈I}" <$ \{\v("{(li = vi) i∈I}") \| ∀i∈I
                                 \v("vi")∈\vs("Ai")\} $>
  ; line "[(Ci : Ai) i∈I]" <$ \bigcup_{i∈I} \{\v("Ci[v]") \| v∈\vs("Ai")\} $>
  ; line "∀χ^s A"          <$ \biginter_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "∃χ^s A"          <$ \bigcup_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $> ]
)
\end{center}
\end{def}

=<
=> Extended type system

(* Ax rule *)
$$
\axiomRN{Ax}{
  Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)
}
$$

(* Coercion rules. *)
$$
\unaryRN{↑}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}
$$

(*
$$
\unaryRN{↓}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}
$$
*)

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)
}
$$

(* ⇒_e rule *)
$$
\binaryRN{⇒_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)
}
$$

(* μ rule *)
$$
\unaryRN{μ}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)
}
$$

(* ∗ rule *)
$$
\unaryRN{[\wc]}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)
}
$$

(* ∀i rule *)
$$
\unaryRN{∀_i}{
  Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))
}
$$

(* ∀e rule *)
$$
\binaryRN{∀_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))
}
$$

(* ∃i rule *)
$$
\binaryRN{∃_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))
}
$$

(* ∃e rule *)
$$
\binaryRN{∃_e}{
  Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))
}{
  Σ ⊢ B : s
}{
  Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))
}
$$

(* ∈i rule *)
$$
\unaryRN{∈_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))
}
$$

(* ∈e rule *)
$$
\unaryRN{∈_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ↾i rule *)
$$
\unaryRN{↾_i}{
  Σ ⊢ (Γ;Δ;Ξ,t≡u ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A | t≡u"))
}
$$

(* ↾e rule *)
$$
\unaryRN{↾_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,t≡u ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("A | t≡u");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ×i *)
$$
\unaryRN{×_i}{
  [Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))
}
$$

(* ×e *)
$$
\binaryRN{×_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)
}
$$

(* +i *)
$$
\binaryRN{+_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ci[v]") : \f("[(Ci : Ai) i∈I]"))
}
$$

(* +e *)
$$
\binaryRN{+_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))
}{
  [Σ ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)
}
$$

(* ≡ *)
$$
\unaryRN{≡_{l, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔v]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔w]") : A)
}
$$

$$
\unaryRN{≡_{l}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)
}
$$

$$
\unaryRN{≡_{r, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔v]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔w]"))
}
$$

$$
\unaryRN{≡_{r}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))
}
$$

=<
=> Adequacy

\begin{def}
Given a typing context $Γ$, a continuation context $Δ$ and an equational
context $Ξ$ we consider two different forms of typing judgments:
\begin{itemize}
\item value judgments $Γ;Ξ;Δ ⊢_\tval v : A$ meaning that the value $v$ has
      type $A$ and
\item general term judgments $Γ;Ξ;Δ ⊢ t : A$ meaning that the term $t$ has
      type $A$ in the context $Γ;Δ;Ξ$.
\end{itemize}
\end{def}
\begin{def}
Given a sorting context $Σ$ we say that $Γ;Δ;Ξ ⊢ t:A$ is a valid term
judgment and we write $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ when
\begin{itemize}
\item $dom(Γ) ⊆ dom(Σ)$ and hence for all $x ∈ dom(Γ)$ we have $Σ(x) = ι$,
\item $dom(Δ) ⊆ dom(Σ)$ and hence for all $α ∈ dom(Δ)$ we have $Σ(α) = σ$,
\item $Σ ⊢ t : τ$ and $Σ ⊢ A : ο$,
\item $FV_ι(t) ⊆ dom(Γ)$, $FV_σ(t) ⊆ dom(Δ)$ and $FV_τ(t) = ∅$,
\item for all $x ∈ dom(Γ)$ we have $Σ ⊢ Γ(x) : ο$,
\item for all $α ∈ dom(Δ)$ we have $Σ ⊢ Δ(α) : ο$,
\item for all $(t ≡ u) ∈ Σ$ we have $Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{itemize}
\end{def}

\begin{def}
A valuation over a sorting context $Σ$ is a map $ρ$ such that $ρ(χ) ∈ ⟦Σ(χ)⟧$
for every $χ ∈ dom(Σ)$. In particular, this means that $dom(Σ) ⊆ dom(ρ)$.
\end{def}

(* Adequacy lemma. *)
\begin{thm}
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the typing
judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ (resp. $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$) is derivable
and if $ρ ⊩ Γ;Δ;Ξ$ then $\t("tρ") ∈ |\f("Aρ")|$ (resp.
$\t("vρ") ∈ ⟦\f("Aρ")⟧$).
\begin{proof}
We proceed by induction on the derivation of the judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$
or $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$, and we reason by case on the last used rule.
\begin{itemize}
\item In the case of the ($Ax$) rule, we immediately obtain
      $\t("xρ") = \t("ρ(x)") ∈ ⟦\f("Aρ")⟧$ by hypothesis.
      \begin{center}
        $ \axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)} $
      \end{center}
\item If the last used rule is ($↑$) then we need to show
      $\v("vρ") ∈ |\f("Aρ")|$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence we can conclude using
      \thmRef("orthosimple").
      \begin{center}
        $ \unaryRN{↑}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
           Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)} $
      \end{center}
\item If the last used rule is ($↓$) then we need to show
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ |\f("Aρ")|$, hence we can conclude using
      \thmRef("orthonew").
      \begin{center}
        $ \unaryRN{↓}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)} $
      \end{center}
\item If the last used rule is ($⇒_i$) then we need to show that
      $\t("(λx t)ρ") ∈ ⟦\f("(A ⇒ B)ρ")⟧$. Let us take $v ∈ ⟦\f("Aρ")⟧$ and
      show that $\t("(tρ)[x ≔ v]") ∈ |\f("Bρ")|$. We can then conclude by
      induction hypothesis using the valuation $\subs("ρ[x ≔ v]")$.
      \begin{center}
        $ \unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)} $
      \end{center}
\item If the last used rule is ($⇒_e$) then we need to show
      $\t("(t u)ρ") = \t("tρ uρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("tρ uρ ∗ π") ∈ \dbot$. Since
      $\p("tρ uρ ∗ π") ≻ \p("uρ ∗ [tρ]π")$ and $\dbot$ is saturated, is is
      enough to show $\p("uρ ∗ [tρ]π") ∈ \dbot$. By induction hypothesis,
      we know that $\t("uρ") ∈ |\f("Aρ")|$, hence it only remains to show
      $\s("[tρ]π") ∈ ||\f("Aρ")||$. Let us now take $\v("v") ∈ ⟦\f("Aρ")⟧$
      and show that $\p("v ∗ [tρ]π") ∈ \dbot$. Since
      $\p("v ∗ [tρ]π") ≻ \p("tρ ∗ v·π")$ and $\dbot$ is saturated, it is
      enough to show that $\p("tρ ∗ v·π") ∈  \dbot$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A ⇒ B)ρ")| = |\f("Aρ ⇒ Bρ")|$, hence it only remains
      to show $\s("v·π") ∈ ||\f("Aρ ⇒ Bρ")||$. Let us now take a value
      $\v("λx f") ∈ ⟦\f("Aρ ⇒ Bρ")⟧$ and show that $\p("λx f ∗ v·π") ∈ \dbot$.
      Since $\p("λx f ∗ v·π") ≻ \p("f[x ≔ v] ∗ π")$ and $\dbot$ is saturated,
      it is enough to show that $\p("f[x ≔ v] ∗ π") ∈ \dbot$. Since
      $\s("π") ∈ ||\f("Bρ")||$ it only remains to show that
      $\t("f[x ≔ v]") ∈ |\f("Bρ")|$. This is true by definition of
      $⟦\f("Aρ ⇒ Bρ")⟧$ since $\v("v") ∈ ⟦\f("Aρ")⟧$.
      \begin{center}
        $ \binaryRN{⇒_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)} $
      \end{center}
\item If the last used rule is ($μ$) then we need to show that
      $\t("(μα t)ρ") = \t("μα tρ") ∈ |\f("Aρ")|$. Let us take
      $π ∈ ||\f("Aρ")||$ and show $\p("μα tρ ∗ π") ∈ \dbot$. Since
      $\p("μα tρ ∗ π") ≻ \p("tρ[α ≔ π] ∗ π")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ[α ≔ π] ∗ π") ∈ \dbot$. We can then conclude
      by induction hypothesis using the valuation $\subs("ρ[α ≔ π]")$.
      \begin{center}
        $ \unaryRN{μ}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)} $
      \end{center}
\item If the last used rule is ($[\wc]$) then we need to show
      $\t("([α]t)ρ") = \t("[ρ(α)]tρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("[ρ(α)]tρ ∗ π") ∈ \dbot$. Since
      $\p("[ρ(α)]tρ ∗ π") ≻ \p("tρ ∗ ρ(α)")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ ∗ ρ(α)") ∈ \dbot$. By induction hypothesis,
      we know that $\t("tρ") ∈ \f("Aρ")$, hence we only need to show that
      $\s("ρ(α)") ∈ ||\f("Aρ")||$. This is true by hypothesis since we have
      $α ∈ dom(Σ, α:σ)$ and $Δ(α) = A$.
      \begin{center}
        $ \unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)} $
      \end{center}
\item If the last used rule is ($∀_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(∀χ^s A)ρ")⟧$. By definition we have
      $⟦\f("(∀χ^s A)ρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$,
      hence it is enough to take $\f("B") ∈ ⟦s⟧$ and show
      $\v("vρ") ∈ ⟦\f("Aρ[χ ≔ B]")⟧$. Note that $\v("vρ") = \v("vρ[χ ≔ B]")$
      as $\f("χ")$ cannot appear in $\v("v")$ for the conclusion judgment to
      be well-formed. We conclude by induction hypothesis with the
      valuation $\subs("ρ[χ ≔ B]")$.
      \begin{center}
        $ \unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))} $
      \end{center}
\item If the last used rule is ($∀_e$) then we need to show
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(∀χ^s A)ρ")|$, hence it is enough to show
      $|\f("(∀χ^s A)ρ")| ⊆ |\f("(A[χ ≔ B])ρ")|$, or
      $⟦\f("(∀χ^s A)ρ")⟧ ⊆ ⟦\f("(A[χ ≔ B])ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume that $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("∀χ^s Aρ")⟧ ⊆ ⟦\f("Aρ[χ ≔ Bρ]")⟧$. The
      inclusion follows since
      $⟦\f("∀χ^s Aρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∀_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))} $
      \end{center}
\item If the last used rule is ($∃_i$) then we need to show
      $\t("tρ") ∈ |\f("(∃χ^s A)ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$, hence it is enough to show
      $|\f("(A[χ ≔ B])ρ")| ⊆ |\f("(∃χ^s A)ρ")|$, or
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∃χ^s A)ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. Now,
      the inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_i}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))} $
      \end{center}
\item If the last used rule is ($∃_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("(A[χ ≔ B])ρ")⟧$ provided
      $\v("ρ(x)") ∈ ⟦\f("(∃χ^s A)ρ")⟧$. In other words, we need to show
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∀χ^s A)ρ")⟧$. Up to renaming, we can
      assume $χ ∉ dom(Σ)$, hence our goal rewrites to 
      $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. The inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))}{
          Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))} $
      \end{center}
\item If the last used rule is ($∈_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(v ∈ A)ρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence it is enough to show
      $⟦\f("(v∈A)ρ")⟧ ⊆ ⟦\f("Aρ")⟧$. This is immediate as
      $⟦\f("(v∈A)ρ")⟧ = ⟦\f("vρ∈Aρ")⟧ = \{w∈⟦\f("Aρ")⟧ \st w≡\v("vρ")\}$
      by definition.
      \begin{center}
        $ \unaryRN{∈_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))} $
      \end{center}
\item If the last used rule is ($∈_e$) then we need to show
      $\t("uρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("aρ")⟧$ and that
      $\v("ρ(x)")≡\t("tρ")$, provided that we have
      $\v("xρ") ∈ ⟦\f("(t∈A)ρ")⟧$. By definition
      $⟦\f("(t∈A)ρ")⟧ = ⟦\f("tρ∈Aρ")⟧ = \{v∈⟦\f("Aρ")⟧ \st v≡\t("tρ")\}$,
      and hence $\v("ρ(x)") ∈ ⟦\f("Aρ")⟧$ and $\v("ρ(x)")≡\t("tρ")$.
      \begin{center}
        $ \unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("u") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("u") : C)} $
      \end{center}
\item If the last used rule is ($↾_i$) then we need to show
      $\t("tρ") ∈ |\f("(A | u₁≡u₂)ρ")|$. By hypothesis, we know that
      $\t("u₁ρ") ≡ \t("u₂ρ")$, and hence
      $|\f("(A|u₁≡u₂)ρ")| = |\f("Aρ | u₁ρ ≡ u₂ρ")| = |\f("Aρ")|$. As a
      consequence, we can immediatly conclude by induction hypothesis.
      \begin{center}
        $ \unaryRN{↾_i}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : \f("A | u₁≡u₂"))} $
      \end{center}
\item If the last used rule is ($↾_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To be able to apply the induction hypothesis,
      we need to show that $ρ(x) ∈ ⟦\f("Aρ")⟧$ and $u₁ρ ≡ u₂ρ$ provided that
      $ρ(x) ∈ ⟦\f("(A | u₁ ≡ u₂)ρ")⟧ = ⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧ ≠ ∅$. This
      immediately follows from the definition of $⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧$
      since it is non-empty.
      \begin{center}
        $ \unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,u₁ ≡ u₂ ⊢ \t("t") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("A | u₁ ≡ u₂");Δ;Ξ ⊢ \t("t") : C)} $
      \end{center}
\item If the last used rule is ($×_i$) then we need to show
      $\v("{(li = vi) i∈I}ρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$. By definition it
      is enough to show that $\v("viρ") ∈ ⟦\f("Aiρ")⟧$ for all index $i$ in
      $I$. This exactly corresponds to the induction hypotheses.
      \begin{center}
        $ \unaryRN{×_i}{[Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))} $
      \end{center}
\item If the last used rule is ($×_e$) then we need to show that
      $\t("(v.lk)ρ") ∈ |\f("Akρ")|$. By induction hypothesis we know that
      $\v("vρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$, hence by definition
      $\v("vρ") = \v("{(li = vi) i∈I}")$ and for all index $i$ in $I$ we
      have $\v("vi") ∈ ⟦\f("Aiρ")⟧$. Let us now take $π ∈ ||\f("Akρ")||$ and
      show that $\p("{(li = vi) i∈I}.lk ∗ π") ∈ \dbot$. As $k$ is in $I$, we
      have $\p("{(li = viρ) i∈I}.lk ∗ π") ≻ \p("viρ ∗ π")$, hence it is enough
      to show $\p("vkρ ∗ π") ∈ \dbot$ as $\dbot$ is saturated. Since
      $π ∈ ||\f("Akρ")||$, we only have to show $\v("vkρ") ∈ |\f("Akρ")|$.
      We can hence conclude using \thmRef("orthosimple") since we know that
      $\v("vkρ") ∈ ⟦\f("Akρ")⟧$.
      \begin{center}
        $ \binaryRN{×_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))}{
          k∈I}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)} $
      \end{center}
\item If the last used rule is ($+_i$) then we need to show
      $\t("(Ck[v])ρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$. By definition we only need
      to show $\v("vρ") ∈ ⟦\f("Akρ")⟧$ since the index $k$ is in $I$. This is
      exactly the induction hypothesis.
      \begin{center}
        $ \binaryRN{+_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))}{k∈I}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]"))} $
      \end{center}
\item If the last used rule is ($+_e$) then we need to show
      $\t("[v | (Ci[xi] → ti) i∈I]ρ") ∈ |\f("Bρ")|$. By induction hypothesis
      we know that $\v("vρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$, hence by definition
      $\v("vρ") = \v("Ck[w]")$ for some index $k$ in $I$ and $w ∈ \f("Akρ")$.
      Let us now take a stack $π ∈ ||\f("Bρ")||$ and show that
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ∈ \dbot$. As
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ≻ \p("tkρ[xk≔w] ∗ π")$ and
      $\dbot$ is saturated, it is enough to show
      $\p("tkρ[xk≔w] ∗ π") ∈ \dbot$. Let us now consider the valuation
      $\subs("ρ[xk≔w]")$. Up to renaming, we can assume that $\v("xk")$ does
      not appear free in $\f("B")$, hence $\f("Bρ") = \f("Bρ[xi≔w]")$.
      Consequently we have $π ∈ ||\f("Bρ[xk≔w]")||$, hence it is enough to
      show that $\t("tkρ[xk≔w]") ∈ |\f("Bρ[xk≔w]")|$. We can conclude by
      induction hypothesis using the valuation $\subs("ρ[xk≔w]")$ since
      $\v("vρ[xk≔w]") ≡ \v("Ck[w]")$.
      \begin{center}
        $ \binaryRN{+_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))}{
          [Σ, x_i : ι ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)} $
      \end{center}
\item If the last used rule is ($≡_{l, {val}}$) then we need to show
      $\t("(t[x≔v₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $x ∉ dom(ρ)$, hence $\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$
      and $\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$. By hypothesis we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$, hence \thmRef("extvalue") gives us
      $\t("tρ[x≔v₁ρ]") ≡ \t("tρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[x≔v₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_{l, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_l$) then we need to show
      $\t("(t[a≔u₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $a ∉ dom(ρ)$, hence $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$
      and $\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$. By hypothesis we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$, hence \thmRef("extterm") gives us
      $\t("tρ[a≔u₁ρ]") ≡ \t("tρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[a≔u₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_l}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_{r, {val}}$) then we need to show
      $\t("tρ") ∈ |\f("(A[x≔v₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[x≔v₂])ρ")|$ so we will show
      $|\f("(A[x≔v₁])ρ")| = |\f("(A[x≔v₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[x≔v₁])ρ")⟧ = ⟦\f("(A[x≔v₂])ρ")⟧$.
      Without loss of generality we may assume that $x ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[x≔v₁ρ]")⟧ = ⟦\f("Aρ[x≔v₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformvalue") as we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_{r, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₁]"))} $
      \end{center}
\item If the last used rule is ($≡_r$) then we need to show
      $\t("tρ") ∈ |\f("(A[a≔u₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[a≔u₂])ρ")|$ so we will show
      $|\f("(A[a≔u₁])ρ")| = |\f("(A[a≔u₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[a≔u₁])ρ")⟧ = ⟦\f("(A[a≔u₂])ρ")⟧$.
      Without loss of generality we may assume that $a ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[a≔u₁ρ]")⟧ = ⟦\f("Aρ[a≔u₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformterm") as we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_r}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))} $
      \end{center}
\end{itemize}
\end{proof}
\end{thm}

=<
=> Derived rules for dependent types

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{Σ; {Γ, x:A}; Δ; Ξ ⊢ t : B}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : A ⇒ B}
\hspace(1.5)
\binaryRN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t : A ⇒ B}{Σ; Γ; Δ; Ξ ⊢ u : A}{
  Σ; Γ; Δ; Ξ ⊢ t u : B}
$$

(* The weak Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, x:ι_v}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{x ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, x:ι_v}; Γ; Δ; Ξ ⊢_\tval λx t : x∈A ⇒ B}{
   \unaryN{∈}{{Σ, x:ι_v}; {Γ, x:{x∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, x:ι_v}; {Γ, x:A}; Δ; {Ξ, x≡x} ⊢ t : B}{
     \hyp{{Σ, x:ι_v} ; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{x ∉ FV(Γ; Δ; Σ)}}
}
$$
(* The weak Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[x := v] ⇒ B[x := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[x := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[x := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]}
   }
  }
 }
}
$$

(* The Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{a ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, a:ι}; Γ; Δ; Ξ ⊢_\tval λx t : a∈A ⇒ B}{
   \unaryN{∈}{{Σ, a:ι}; {Γ, x:{a∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, a:ι}; {Γ, x:A}; Δ; {Ξ, x≡a} ⊢ t : B}{
     \hyp{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{a ∉ FV(Γ; Δ; Σ)}}
}
$$

(* The Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[a := v] ⇒ B[a := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[a := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[a := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]}
   }
  }
 }
}
$$
(* TODO *)

=<

=<
