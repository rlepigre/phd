\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^\bot $>
  let ts a = <$ ⟦\f(a)⟧^{\bot\bot} $>
)
\Include{Macros}

=> Higher-order type system and semantics \label("typeSystem")

In this chapter, we present a new type system which distinguishing feature
is an embedded notion of program equivalence. It enables the specification
of equational properties over programs, which can then be proved using
equational reasoning. Our types are interpreted using standard classical
realisability techniques, which allows for a semantical justification of
our typing rules.

=> Observational equivalence type

One of the main goals of this thesis is to build a type system that can be
used to reason about programs. To achieve this goal, we need to be able to
specify program behaviours using types. To this aim, we introduce equality
types of the form $\f("t ≡ u")$, where $t$ and $u$ are (possibly untyped)
terms. Intuitively, an equality type will be interpreted $⊤$ (i.e. logical
truth, the bigest type) if $t ≡_{≻} u$, and as $⊥$ (i.e. logical absurdity,
the empty type) if $t \nequiv_{≻} u$. For example, the type
$\f("(λx x) λx x ≡ λx x")$ is inhabited as $\t("(λx x) λx x") ≡_{≻}
\t("λx x")$ according to \thmRef("cbvbeta"), but $\f("λx x ≡ {}")$ is empty
since $\t("λx x") \nequiv_{≻} \t("{}")$ according to \thmRef("nequiv").

Of course, it is undecidable whether two terms are equivalent or not. As a
consequence, we will not be able to decide, in general, whether an equality
type is inhabited or not. We will hence need to rely on a partial decision
procedure that will only approximate our observational equivalence relation.
\begin{thm}
Given two terms $t ∈ Λ$ and $u ∈ Λ$ it is undecidable whether $t ≡_{≻} u$
or $t \nequiv_{≡} u$.
\begin{proof}
We are going to encode the halting problem $H_t$ using equivalence. In our
system, $H_t$ can be stated as ${\p("t ∗ ε")} {⇓}_{≻}$. Let us
consider a term $Ω ∈ Λ$ such that ${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$.
We will now show that $H_t$ is equivalent to
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. Let us suppose $H_t$ and show
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. We need to find a stack $π ∈ Π$ such
that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ and ${\p("Ω ∗ π")} {⇑}_{≻}$. This is in fact
true for all $π$ as ${\p("Ω ∗ π")} {⇑}_{≻}$ by hypothesis and
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")} {⇓}_{≻}$ since we supposed $H_t$. We know
suppose ${\t("[ε]t") \nequiv_{≻} \t("Ω")}$ and show $H_t$. By definition,
there must be a stack $π ∈ Π$ such that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ since
${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$. Now since we have
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")}$ we obtain $H_t$.
\end{proof}
\end{thm}

In the system, proving a program equivalence amounts to showing that the
corresponding equivalence type is inhabited. However, an equivalence type
may also be used as an assumption. For example, it is possible to define
a function which input type is an equivalence. As a consequence, we are
going to need a form of context containing a set of program equivalences
that are assumed to be true.
\begin{def}
An equational context $Ξ ⊆ \cal{P}(Λ × Λ)$ is a finite set of couples
of terms denoting hypothetical equivalences. For convenience, we will
represent equational contexts using lists generated using the following
||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Ξ ::= • \| {Ξ, t ≡ u}$ >> << $t,u ∈ Λ$ >>)
\end{def}

(* TODO more *)

\begin{def}
Given an equational context $Ξ$ and a substitution $ρ$, we write $ρ ⊩ Ξ$ if
for every $(t,u) ∈ Ξ$ we have $\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}
\begin{def}
Let $Ξ$ be an equational context and $t ∈ Λ$ and $u ∈ Λ$ be two terms. We
write $Ξ ⊢ t ≡ u$ if our (unspecified by supposed correct) decision
procedure is able to show that for every substitution $ρ$ such that $ρ ⊩ Ξ$
we have $\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}

Although equality types enable the derivation of simple equational
properties, their use is rather limited without a form of quantification.
Indeed, they can only be used to specify static equivalences like
$\t("(λx x) {}") ≡_{≻} \t("{}")$, but not general properties like
"$\t("(λx x) v") ≡_{≻} \t("v")$ for every value $v$".

=<
=> Untyped quantification and membership predicate

A term $t ∈ Λ$ can contain free variables of several sorts: $λ$-variables
(i.e. value variables), term variables and $μ$-variables (i.e. stack
variables). As open terms may appear in types, and in particular in equality
types, it is natural to allow universal and existential quantification over
all all three sorts of variables. We can hence encode properties like
$\f("∀y (λx x) y ≡ y")$ or $\f("∀x ∀y x ≡ y ⇒ C[x] ≡ C[y]")$.
\begin{rem}
It is not clean whether quantification over stacks has a parctical use. We
only include it as it fits well in the framework and seems rather natural.
\end{rem}

(* TODO *)

Still, quantifying over all the (closed) values or terms is not enough.
Indeed, it is sometimes required to quantify over the values or terms of
a given type only. To this aim, we introduce a membership type constructor
$\f("t ∈ A")$ where $t ∈ Λ$ is a term and $A$ is a type. Intuitively, the
element of a type $\f("t ∈ A")$ are the elements of $A$ that are equivalent
to $t$. In particular, $\f("t ∈ A")$ is empty if $t$ does not have type $A$.

(* TODO *)

When a membership type is used as the argument type of a function...

$$ Π_{a : A} B ≔ \f("∀a (a∈A ⇒ B)") $$

$$ Σ_{a : A} B ≔ \f("∀a {l₁ : a∈A; l₂ : B}") $$

=<
=> Sorts and higher-order types

Our system also provides quantifiers
ranging over types, which correspond to System F polymorphism and type
abstraction.

Although our system provides several different sorts of quantifiers, they
are going to be handled uniformly in the semantics.



In this section, we present the higher-order type system that will serve as
a base for the work presented in this thesis. Although the following extends
definitions given in the previous sections, we choose not to avoid
repetitions so that this section remains completely self-contained.

We here consider a type system that is very similar to the type system of
the functional languages of the ||ml|| family (e.g. SML or OCaml). It will
provide a product type for records, a sum type for polymorphic variants,
polymorphism and higher-order quantification, least and greatest fixpoints.
The higher-order features of the system will allow us to define types using
functions taking as arguments types or other functions. This leads to a
system in which it is syntactically correct to use a type function as a
type, although it does not make sense. To solve this problem, the usual
approach is to assign a form of type (called sort) to the types themselves.
\begin{def}
The set $\cal{S}$ of all the sorts is generated using the following ||bnf||
grammar, where $ο$ denotes the sort of propositions.
$$ s,r ::= ο \| {s→r} $$
\end{def}
\begin{def}
The set of types (or formulas) is built from a countable set of
variables $\cal{V} = \{χ... X, Y, Z ...\}$ containing the set of
propositional variables $\cal{V}_ο = \{X, Y, Z...\}$. It is generated
using the following ||bnf|| grammar.
$$
  A,B ::= \f("χ") \| \f("(χ^s ↦ A)") \| \f("A(B)") \| \f("A ⇒ B") \|
          \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]") \mbr 
          \| \f("∀χ^s A") \| \f("∃χ^s A") \| \f("μX A") \| \f("νX A")
$$
\end{def}
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, sorting contexts are
represented using comma-separated lists of sort assignments of the form
$χ : s$. variable of $\cal{V}$ are mapped at most onces in a sorting context,
and their order is irrelevant.
\end{def}

\begin{def}
A sorting judgment is a triple of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the following deduction rules.
$$
\axiomR{Σ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ ↦ A)") : s → r}
\hspace(3.0)
\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}
$$
$$
\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f("A ⇒ B") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}
$$
$$
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∀χ A") : r}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∃χ A") : r}
\hspace(3.0)
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("μX A") : ο}
$$
$$
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("νX A") : ο}
$$
\end{def}

\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ and $\cal{V}_μ$ such
that for all $λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$ and for all
$μ$-variable $α ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent typing contexts using comma-separated lists of mappings generated
of the form $x : A$ or $α : A^⊥$. Note that variables can only be mapped once
in a typing context, and that their order is irrelevant.
\end{def}
\begin{def}
A typing context $Γ$ is said to be valid under a sorting context $Σ$ if for
all mapping $x:A$ or $α:A^⊥$ in $Γ$ the judgment $Σ ⊢ Γ(x) : ο$ is valid. If
$Γ$ is valid under $Σ$ then we write $Σ ⊢ Γ$.
\end{def}

(* Typing rules. *)
$$
  \axiomRN{Ax}{Γ, x : A ⊢_\tval x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢_\tval λx t: A ⇒ B}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : A ⇒ B}{Γ ⊢ u : A}{Γ ⊢ (t) u : B}
$$
$$
  \unaryRN{↑}{Γ ⊢_\tval v : A}{Γ ⊢ v : A}
  \hspace(4.0)
  \unaryRN{μ}{Γ, α : ¬A ⊢ t : A}{Γ ⊢ μα t : A}
  \hspace(4.0)
  \unaryRN{[{-}]}{Γ, α : ¬A ⊢ t : A}{Γ, α : ¬A  ⊢ [α] t : B}
$$
$$
  \binaryRN{∀_i}{Γ, X_n ⊢_\tval v : A}{X_n ∉ FV(Γ)}{Γ ⊢_\tval v : ∀X_n A}
  \hspace(4.0)
  \unaryRN{∀_e}{Γ ⊢ t : ∀X_n A}{Γ ⊢ t : A[X_n := P_n]}
$$
$$
  \unaryRN{∃_i}{Γ ⊢ t : A[X_n := P_n]}{Γ ⊢ t : ∃X_n A}
  \hspace(4.0)
  \binaryRN{∃_e}{Γ, X_n, x : A ⊢ t : B}{X_n ∉ FV(Γ,B)}{Γ, x : ∃X_n A ⊢ t : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢_\tval v_i : A_i]_{1≤i≤n}}{
    Γ ⊢_\tval \{l_i = v_i\}_{1≤i≤n} : \{l_i : A_i\}_{1≤i≤n}
  }
  \hspace(4.0)
  \unaryRN{×_e}{Γ ⊢_\tval v : \{l_i : A_i\}_{1≤i≤n}}{Γ ⊢ v{.}l_i : A_i}
$$
$$
  \unaryRN{+_i}{Γ ⊢_\tval v : A_i}{Γ ⊢ C_i[v] : [C_i : A_i]_{1≤i≤n}}
  \hspace(1.0)
  \binaryRN{+_e}{Γ ⊢_\tval v : [C_i : A_i]_{1≤i≤n}}{
    [Γ, x_i : A_i ⊢ t_i : B]_{1≤i≤n}
  }{
    Γ ⊢ case_v [C_i[x_i] → t_i]_{1≤i≤n} : B
  }
$$


(* Sorting rules. *)
$$
\binaryR{Δ ⊢ A : ο}{Δ ⊢ B : ο}{Δ ⊢ A ⇒ B : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ \{l_i : A_i\}_{i∈I} : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ [C_i : A_i]_{i∈I} : ο}
$$
$$
\axiomR{Δ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ E : r}{Δ ⊢ (χ^s ↦ E) : s → r}
\hspace(3.0)
\binaryR{Δ ⊢ E : s → r}{Δ ⊢ F : s}{Δ ⊢ E(F) : r}
$$
$$
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∀χ^s A : ο}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∃χ^s A : ο}
$$
$$
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ μX A : ο}
\hspace(3.0)
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ νX A : ο}
$$
(* TODO *)

=<
=> Encoding value restriction

As mentioned in the previous section, the languages of the ||ml|| family
need a restriction on polymorphism to remain type-safe. With the value
restriction, the typing rule for ||ml|| polymorphism becomes the following.
$$ \ternaryR{Γ ⊢ v : B}{Γ, x : ∀X₁,...,X_n B ⊢ t : A}{v value}
    {Γ ⊢ let x = v in t : A} $$
When the value that is bound by a let-binding is not a value its type is
not generalized and the following rule applies.
$$ \binaryR{Γ ⊢ u : B}{Γ, x : B ⊢ t : A}{Γ ⊢ let x = u in t : A} $$

In slightly more expressive type systems like System F, the value
restriction appears in the typing rule for the introduction of the
universal quantifier. The ususal typing rule
$$ \binaryRN{∀_i}{Σ,X;Γ ⊢ t:A}{X ∉ FV(Γ)}{Σ; Γ ⊢ t : ∀X A} $$
cannot be proved safe (in a call-by-value system with side-effects) if
$t$ is not a syntactic value. This will also be the case in our system
when we bring together polymorphism and the \lmcalc.

\begin{def}
A value judgement (resp. term judgment) is a tuple of a value $v ∈ Λ_{val}$
(resp. a term $t ∈ Λ$), a type $A ∈ \cal{F}$, a typing context $Γ$, a
continuation context $Δ$ and a type variable context $Σ$ that is denoted
$Σ; Γ ⊢_\tval v : A; Δ$ (resp. $Σ; Γ ⊢ t : A; Δ$). A judgment is sait do be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) ⊆ dom(Δ)$, $FV_ι(t) = ∅$,
$FV_ο(A) ⊆ Σ$, $FV_ο(Γ) ⊆ Σ$ and $FV_ο(Δ) ⊆ Σ$. To lighten the notations,
we will sometimes ommit empty contexts.
\end{def}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system. Note that a rule only
applies if all the involved judgments are well-formed.
$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢_\tval x : A; Δ}
  \hspace(4.0)
  \unaryRN{↑}{Σ;Γ ⊢_\tval v : A; Δ}{Σ;Γ ⊢ v : A; Δ}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B; Δ}{
    Σ; Γ ⊢_\tval \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(4.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B"); Δ}{Σ; Γ ⊢ u : A; Δ}{
    Σ; Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢_\tval v_i : A_i; Δ]_{i∈I}}{
    Σ; Γ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ;Γ ⊢_\tval v : \f("{(li : Ai) i∈I}"); Δ}{
    Σ;Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢_\tval v : A_j; Δ)}{
    Σ ⊢ (Γ ⊢_\tval \v("Cj[v]") : \f("[(Ci : Ai) i∈I]")); Δ}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢_\tval v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{{∀}_i}{Σ, X; Γ ⊢_\tval v : A; Δ}{Σ; Γ ⊢_\tval v : \f("∀X A"); Δ}
  \hspace(4.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A"); Δ}{Σ; Γ ⊢ t : \f("A[X≔B]"); Δ}
$$
\end{def}
Here again, the $∀_i$ rule does not apply if $X ∈ FV_ο(Γ)$ or $X ∈ FV_ο(Δ)$.
\begin{rem}
The $↑$ rule is essential for building proofs. It arises naturally as values
are terms, and hence a value judgement subsumes the corresponding term
judgment.
\end{rem}

As an example, we can derive again the type of $\t("λf μα f λx [α]x")$ as
follows. Its type still corresponds to Peirce's Law, but we are now able to
polymorphism.
\begin{env}(scale 0.86)
$$
  \proofTree{
    \unaryN{∀_i}{⊢ \t("λf μα f λx [α]x") : \f("∀X ∀Y ((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{∀_i}{X ⊢ \t("λf μα f λx [α]x") : \f("∀Y ((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{⇒_i}{X,Y ⊢ \t("λf μα f λx [α]x") : \f("((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{μ}{X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("μα f λx [α]x") : X}{
      \binaryN{⇒_e}{
        X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("f λx [α]x") : X; α:X
      }{
        \axiomN{Ax}{X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ f : \f("(X ⇒ Y) ⇒ X"); α:X}
      }{
        \unaryN{⇒_i}{
          X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("λx [α]x") : \f("X ⇒ Y"); α:X
        }{
          \unaryN{[{-}]}{
            X,Y; f:\f("(X ⇒ Y) ⇒ X"), x:X ⊢ \t("[α]x") : X; α : X
          }{
            \axiomN{Ax}{X,Y; f:\f("(X ⇒ Y) ⇒ X"), x:X ⊢ x : X; α:X}
          }
        }
      }
  }}}}}
$$
\end{env}

=<
=> Call-by-value realisability semantics

The abstract machine presented in \chapter("calculus") is part of a
//classical realizability// machinery that will be built upon here.
We aim at obtaining a semantical interpretation of our higher-order
type system. As always in classical realizability, the model is
parametrized by a pole, which serves as an exchange point between
the world of programs and the world of execution contexts, which are
represented as stacks.
\begin{def}
A //pole// is a set of processes $\dbot ⊆ Λ×Π$ which is //saturated//
(i.e. closed under backward reduction). More formally, if we have
$q ∈ \dbot$ and $p ≻ q$ then $p ∈ \dbot$.
\end{def}

The notion of //orthogonality// is central in Krivine's classical
realizability. In this framework a type is interpreted (or realized) by
programs computing corresponding values. This interpretation is spread
in a three-layered construction, even though it is fully determined by
the first layer and the choice of the pole. The first layer consists of
a set of values that we will call the //raw semantics//. It gathers all
the syntactic values that should be considered as having the corresponding
type. As an example, if we were to consider the type of natural numbers,
its raw semantics would be the set $\{\hat{n} \| n ∈ \bbN\}$ where
$\hat{n}$ is some encoding of $n$.
(* *)
The second layer, called //falsity value//, is a set containing every
stack that is a candidate for building a valid process using any value
from the raw semantics. The notion of validity depends on the choice of
the pole. The third layer, called //truth value// is a set of terms that
is built by iterating the process once more. The formalism for the two
levels of orthogonality is given in the following definition.
\begin{def}\label("orthodef")
For every set $Φ ⊆ Λ_{val}$ we define a set $Φ^\bot ⊆ Π$ and a set
$Φ^{\bot\bot} ⊆ Λ$ as follows.
$$
  Φ^\bot = \{π∈Π \| ∀v∈Φ \p("v ∗ π") ∈ \dbot\}
  \hspace(3.0)
  Φ^{\bot\bot} = \{t∈Λ \| ∀π∈Φ^\bot \p("t ∗ π") ∈ \dbot\}
$$
\end{def}

We now give two general properties of orthogonality that are true in
every classical realizability model. They will be useful when proving
the soundness of our type system.
\begin{lem}\label("orthosimple")
If $Φ ⊆ Λ_{val}$ is a set of values, then $Φ ⊆ Φ^{\bot\bot}$.
\begin{proof}
We take $v ∈ Φ$ and show $v ∈ Φ^{\bot\bot}$. By definition we need to
show $\p("v∗π") ∈ \dbot$ for all stack $π ∈ Φ^\bot$. This is immediate
by definition of $Φ^\bot$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclstack")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If $Φ ⊆ Ψ$ then
$Ψ^\bot ⊆ Φ^\bot$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$, take $π ∈ Ψ^\bot$ and show that $π ∈ Φ^\bot$.
By definition, we know that for all $v ∈ Ψ$ we have $\p("v ∗ π") ∈ \dbot$.
Since $Φ ⊆ Ψ$, this is also true for all $v ∈ Φ$, and hence $π ∈ Φ^\bot$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclterm")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If
$Ψ^\bot ⊆ Φ^\bot$ then $Φ^{\bot\bot} ⊆ Ψ^{\bot\bot}$.
\begin{proof}
Let us suppose that $Ψ^⊥ ⊆ Φ^⊥$, take $t ∈ Φ^{⊥⊥}$ and show that
$t ∈ Ψ^{⊥⊥}$. By definition, we know that for all $π ∈ Φ^⊥$ we have
$\p("t ∗ π") ∈ \dbot$. Since $Ψ^⊥ ⊆ Φ^⊥$, this is also true for all
$π ∈ Ψ^⊥$, and hence $t ∈ Ψ^{⊥⊥}$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoblabla")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If $Φ ⊆ Ψ$ then
$Φ^{\bot\bot} ⊆ Ψ^{\bot\bot}$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$ and apply \lemRef("orthoinclstack") to obtain
$Ψ^⊥ ∈ Φ^⊥$. We can then conclude using \lemRef("orthoinclterm").
\end{proof}
\end{lem}

When choosing a pole, it is important to check that it does not yield a
degenerate model. In particular we need to check that no term is able to
face every stacks. If it were the case, such a term could be use as a
proof of $⊥$.
\begin{def}
A pole $\dbot ⊆ Λ×Π$ is said to be consistent if for every closed term
$t ∈ Λ$ there is a stack $π$ such that $\p("t ∗ π") ∉ \dbot$.
\end{def}

\begin{def}
To every type $A ∈ \cal{F}$ we associate a set of value $\vs("A") ⊆ Λ_{val}$
called its raw semantics. It is defined inductively on the structure of $A$
as follows.
\begin{center}
\diagram(
let _ =
  let line s m = [ vs s; <$=$>; m ] in
  array [`East ; `East ; `West]
  [ line "Φ"               <$ Φ $>
  ; line "(χ ↦ A)"         <$ Φ ↦ \vs("A[χ≔Φ]") $>
  ; line "A(B)"            <$ ⟦A⟧(⟦B⟧) $>
  ; line "A ⇒ B"           <$ \{\v("λx t") \| ∀v∈\vs("A")
                                 \t("t[x≔v]") ∈ \ts("B")\} $>
  ; line "{(li : Ai) i∈I}" <$ \{\v("{(li = vi) i∈I}") \| ∀i∈I
                                 \v("vi")∈\vs("Ai")\} $>
  ; line "[(Ci : Ai) i∈I]" <$ \bigcup_{i∈I} \{\v("Ci[v]") \| v∈\vs("Ai")\} $>
  ; line "∀χ^s A"          <$ \biginter_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "∃χ^s A"          <$ \bigcup_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "μX A"            <$ ... $>
  ; line "νX A"            <$ ... $> ]
)
\end{center}
\end{def}

=<








=> Membership and typed quantification

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{Σ; {Γ, x:A}; Δ; Ξ ⊢ t : B}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : A ⇒ B}
\hspace(1.5)
\binaryRN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t : A ⇒ B}{Σ; Γ; Δ; Ξ ⊢ u : A}{
  Σ; Γ; Δ; Ξ ⊢ t u : B}
$$

(* The weak Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, x:ι_v}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{x ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, x:ι_v}; Γ; Δ; Ξ ⊢_\tval λx t : x∈A ⇒ B}{
   \unaryN{∈}{{Σ, x:ι_v}; {Γ, x:{x∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, x:ι_v}; {Γ, x:A}; Δ; {Ξ, x≡x} ⊢ t : B}{
     \hyp{{Σ, x:ι_v} ; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{x ∉ FV(Γ; Δ; Σ)}}
}
$$
(* The weak Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[x := v] ⇒ B[x := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[x := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[x := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]}
   }
  }
 }
}
$$

(* The Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{a ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, a:ι}; Γ; Δ; Ξ ⊢_\tval λx t : a∈A ⇒ B}{
   \unaryN{∈}{{Σ, a:ι}; {Γ, x:{a∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, a:ι}; {Γ, x:A}; Δ; {Ξ, x≡a} ⊢ t : B}{
     \hyp{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{a ∉ FV(Γ; Δ; Σ)}}
}
$$

(* The Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[a := v] ⇒ B[a := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[a := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[a := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]}
   }
  }
 }
}
$$
(* TODO *)

=<
=> Extended type system

(* Ax rule *)
$$
\axiomRN{Ax}{
  Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)
}
$$

(* Coercion rules. *)
$$
\unaryRN{↑}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}
$$

$$
\unaryRN{↓}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}
$$

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)
}
$$

(* ⇒_e rule *)
$$
\binaryRN{⇒_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)
}
$$

(* μ rule *)
$$
\unaryRN{μ}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)
}
$$

(* ∗ rule *)
$$
\unaryRN{[\wc]}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)
}
$$

(* ∀i rule *)
$$
\unaryRN{∀_i}{
  Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))
}
$$

(* ∀e rule *)
$$
\binaryRN{∀_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))
}
$$

(* ∃i rule *)
$$
\binaryRN{∃_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))
}
$$

(* ∃e rule *)
$$
\binaryRN{∃_e}{
  Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))
}{
  Σ ⊢ B : s
}{
  Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))
}
$$

(* ∈i rule *)
$$
\unaryRN{∈_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))
}
$$

(* ∈e rule *)
$$
\unaryRN{∈_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ↾i rule *)
$$
\unaryRN{↾_i}{
  Σ ⊢ (Γ;Δ;Ξ,t≡u ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A | t≡u"))
}
$$

(* ↾e rule *)
$$
\unaryRN{↾_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,t≡u ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("A | t≡u");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ×i *)
$$
\unaryRN{×_i}{
  [Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))
}
$$

(* ×e *)
$$
\binaryRN{×_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)
}
$$

(* +i *)
$$
\binaryRN{+_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ci[v]") : \f("[(Ci : Ai) i∈I]"))
}
$$

(* +e *)
$$
\binaryRN{+_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))
}{
  [Σ ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)
}
$$

(* ≡ *)
$$
\unaryRN{≡_{l, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔v]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔w]") : A)
}
$$

$$
\unaryRN{≡_{l}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)
}
$$

$$
\unaryRN{≡_{r, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔v]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔w]"))
}
$$

$$
\unaryRN{≡_{r}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))
}
$$

=<

=> Adequacy

We will now give the formal definition of our new type system.
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= {s→r} \| ξ$ >> << $ξ∈\cal{S}₀$ >>)
\end{def}
\begin{def}
Given a typing context $Γ$, a continuation context $Δ$ and an equational
context $Ξ$ we consider two different forms of typing judgments:
\begin{itemize}
\item value judgments $Γ;Ξ;Δ ⊢_\tval v : A$ meaning that the value $v$ has
      type $A$ and
\item general term judgments $Γ;Ξ;Δ ⊢ t : A$ meaning that the term $t$ has
      type $A$ in the context $Γ;Δ;Ξ$.
\end{itemize}
\end{def}
\begin{def}
Given a sorting context $Σ$ we say that $Γ;Δ;Ξ ⊢ t:A$ is a valid term
judgment and we write $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ when
\begin{itemize}
\item $dom(Γ) ⊆ dom(Σ)$ and hence for all $x ∈ dom(Γ)$ we have $Σ(x) = ι$,
\item $dom(Δ) ⊆ dom(Σ)$ and hence for all $α ∈ dom(Δ)$ we have $Σ(α) = σ$,
\item $Σ ⊢ t : τ$ and $Σ ⊢ A : ο$,
\item $FV_ι(t) ⊆ dom(Γ)$, $FV_σ(t) ⊆ dom(Δ)$ and $FV_τ(t) = ∅$,
\item for all $x ∈ dom(Γ)$ we have $Σ ⊢ Γ(x) : ο$,
\item for all $α ∈ dom(Δ)$ we have $Σ ⊢ Δ(α) : ο$,
\item for all $(t ≡ u) ∈ Σ$ we have $Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{itemize}
\end{def}

\begin{def}
A valuation over a sorting context $Σ$ is a map $ρ$ such that $ρ(χ) ∈ ⟦Σ(χ)⟧$
for every $χ ∈ dom(Σ)$. In particular, this means that $dom(Σ) ⊆ dom(ρ)$.
\end{def}

(* Adequacy lemma. *)
\begin{thm}
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the typing
judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ (resp. $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$) is derivable
and if $ρ ⊩ Γ;Δ;Ξ$ then $\t("tρ") ∈ |\f("Aρ")|$ (resp.
$\t("vρ") ∈ ⟦\f("Aρ")⟧$).
\begin{proof}
We proceed by induction on the derivation of the judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$
or $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$, and we reason by case on the last used rule.
\begin{itemize}
\item In the case of the ($Ax$) rule, we immediately obtain
      $\t("xρ") = \t("ρ(x)") ∈ ⟦\f("Aρ")⟧$ by hypothesis.
      \begin{center}
        $ \axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)} $
      \end{center}
\item If the last used rule is ($↑$) then we need to show
      $\v("vρ") ∈ |\f("Aρ")|$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence we can conclude using
      \thmRef("orthosimple").
      \begin{center}
        $ \unaryRN{↑}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
           Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)} $
      \end{center}
\item If the last used rule is ($↓$) then we need to show
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ |\f("Aρ")|$, hence we can conclude using
      \thmRef("orthonew").
      \begin{center}
        $ \unaryRN{↓}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)} $
      \end{center}
\item If the last used rule is ($⇒_i$) then we need to show that
      $\t("(λx t)ρ") ∈ ⟦\f("(A ⇒ B)ρ")⟧$. Let us take $v ∈ ⟦\f("Aρ")⟧$ and
      show that $\t("(tρ)[x ≔ v]") ∈ |\f("Bρ")|$. We can then conclude by
      induction hypothesis using the valuation $\subs("ρ[x ≔ v]")$.
      \begin{center}
        $ \unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)} $
      \end{center}
\item If the last used rule is ($⇒_e$) then we need to show
      $\t("(t u)ρ") = \t("tρ uρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("tρ uρ ∗ π") ∈ \dbot$. Since
      $\p("tρ uρ ∗ π") ≻ \p("uρ ∗ [tρ]π")$ and $\dbot$ is saturated, is is
      enough to show $\p("uρ ∗ [tρ]π") ∈ \dbot$. By induction hypothesis,
      we know that $\t("uρ") ∈ |\f("Aρ")|$, hence it only remains to show
      $\s("[tρ]π") ∈ ||\f("Aρ")||$. Let us now take $\v("v") ∈ ⟦\f("Aρ")⟧$
      and show that $\p("v ∗ [tρ]π") ∈ \dbot$. Since
      $\p("v ∗ [tρ]π") ≻ \p("tρ ∗ v·π")$ and $\dbot$ is saturated, it is
      enough to show that $\p("tρ ∗ v·π") ∈  \dbot$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A ⇒ B)ρ")| = |\f("Aρ ⇒ Bρ")|$, hence it only remains
      to show $\s("v·π") ∈ ||\f("Aρ ⇒ Bρ")||$. Let us now take a value
      $\v("λx f") ∈ ⟦\f("Aρ ⇒ Bρ")⟧$ and show that $\p("λx f ∗ v·π") ∈ \dbot$.
      Since $\p("λx f ∗ v·π") ≻ \p("f[x ≔ v] ∗ π")$ and $\dbot$ is saturated,
      it is enough to show that $\p("f[x ≔ v] ∗ π") ∈ \dbot$. Since
      $\s("π") ∈ ||\f("Bρ")||$ it only remains to show that
      $\t("f[x ≔ v]") ∈ |\f("Bρ")|$. This is true by definition of
      $⟦\f("Aρ ⇒ Bρ")⟧$ since $\v("v") ∈ ⟦\f("Aρ")⟧$.
      \begin{center}
        $ \binaryRN{⇒_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)} $
      \end{center}
\item If the last used rule is ($μ$) then we need to show that
      $\t("(μα t)ρ") = \t("μα tρ") ∈ |\f("Aρ")|$. Let us take
      $π ∈ ||\f("Aρ")||$ and show $\p("μα tρ ∗ π") ∈ \dbot$. Since
      $\p("μα tρ ∗ π") ≻ \p("tρ[α ≔ π] ∗ π")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ[α ≔ π] ∗ π") ∈ \dbot$. We can then conclude
      by induction hypothesis using the valuation $\subs("ρ[α ≔ π]")$.
      \begin{center}
        $ \unaryRN{μ}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)} $
      \end{center}
\item If the last used rule is ($[\wc]$) then we need to show
      $\t("([α]t)ρ") = \t("[ρ(α)]tρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("[ρ(α)]tρ ∗ π") ∈ \dbot$. Since
      $\p("[ρ(α)]tρ ∗ π") ≻ \p("tρ ∗ ρ(α)")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ ∗ ρ(α)") ∈ \dbot$. By induction hypothesis,
      we know that $\t("tρ") ∈ \f("Aρ")$, hence we only need to show that
      $\s("ρ(α)") ∈ ||\f("Aρ")||$. This is true by hypothesis since we have
      $α ∈ dom(Σ, α:σ)$ and $Δ(α) = A$.
      \begin{center}
        $ \unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)} $
      \end{center}
\item If the last used rule is ($∀_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(∀χ^s A)ρ")⟧$. By definition we have
      $⟦\f("(∀χ^s A)ρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$,
      hence it is enough to take $\f("B") ∈ ⟦s⟧$ and show
      $\v("vρ") ∈ ⟦\f("Aρ[χ ≔ B]")⟧$. Note that $\v("vρ") = \v("vρ[χ ≔ B]")$
      as $\f("χ")$ cannot appear in $\v("v")$ for the conclusion judgment to
      be well-formed. We conclude by induction hypothesis with the
      valuation $\subs("ρ[χ ≔ B]")$.
      \begin{center}
        $ \unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))} $
      \end{center}
\item If the last used rule is ($∀_e$) then we need to show
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(∀χ^s A)ρ")|$, hence it is enough to show
      $|\f("(∀χ^s A)ρ")| ⊆ |\f("(A[χ ≔ B])ρ")|$, or
      $⟦\f("(∀χ^s A)ρ")⟧ ⊆ ⟦\f("(A[χ ≔ B])ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume that $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("∀χ^s Aρ")⟧ ⊆ ⟦\f("Aρ[χ ≔ Bρ]")⟧$. The
      inclusion follows since
      $⟦\f("∀χ^s Aρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∀_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))} $
      \end{center}
\item If the last used rule is ($∃_i$) then we need to show
      $\t("tρ") ∈ |\f("(∃χ^s A)ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$, hence it is enough to show
      $|\f("(A[χ ≔ B])ρ")| ⊆ |\f("(∃χ^s A)ρ")|$, or
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∃χ^s A)ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. Now,
      the inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_i}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))} $
      \end{center}
\item If the last used rule is ($∃_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("(A[χ ≔ B])ρ")⟧$ provided
      $\v("ρ(x)") ∈ ⟦\f("(∃χ^s A)ρ")⟧$. In other words, we need to show
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∀χ^s A)ρ")⟧$. Up to renaming, we can
      assume $χ ∉ dom(Σ)$, hence our goal rewrites to 
      $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. The inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))}{
          Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))} $
      \end{center}
\item If the last used rule is ($∈_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(v ∈ A)ρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence it is enough to show
      $⟦\f("(v∈A)ρ")⟧ ⊆ ⟦\f("Aρ")⟧$. This is immediate as
      $⟦\f("(v∈A)ρ")⟧ = ⟦\f("vρ∈Aρ")⟧ = \{w∈⟦\f("Aρ")⟧ \st w≡\v("vρ")\}$
      by definition.
      \begin{center}
        $ \unaryRN{∈_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))} $
      \end{center}
\item If the last used rule is ($∈_e$) then we need to show
      $\t("uρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("aρ")⟧$ and that
      $\v("ρ(x)")≡\t("tρ")$, provided that we have
      $\v("xρ") ∈ ⟦\f("(t∈A)ρ")⟧$. By definition
      $⟦\f("(t∈A)ρ")⟧ = ⟦\f("tρ∈Aρ")⟧ = \{v∈⟦\f("Aρ")⟧ \st v≡\t("tρ")\}$,
      and hence $\v("ρ(x)") ∈ ⟦\f("Aρ")⟧$ and $\v("ρ(x)")≡\t("tρ")$.
      \begin{center}
        $ \unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("u") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("u") : C)} $
      \end{center}
\item If the last used rule is ($↾_i$) then we need to show
      $\t("tρ") ∈ |\f("(A | u₁≡u₂)ρ")|$. By hypothesis, we know that
      $\t("u₁ρ") ≡ \t("u₂ρ")$, and hence
      $|\f("(A|u₁≡u₂)ρ")| = |\f("Aρ | u₁ρ ≡ u₂ρ")| = |\f("Aρ")|$. As a
      consequence, we can immediatly conclude by induction hypothesis.
      \begin{center}
        $ \unaryRN{↾_i}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : \f("A | u₁≡u₂"))} $
      \end{center}
\item If the last used rule is ($↾_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To be able to apply the induction hypothesis,
      we need to show that $ρ(x) ∈ ⟦\f("Aρ")⟧$ and $u₁ρ ≡ u₂ρ$ provided that
      $ρ(x) ∈ ⟦\f("(A | u₁ ≡ u₂)ρ")⟧ = ⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧ ≠ ∅$. This
      immediately follows from the definition of $⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧$
      since it is non-empty.
      \begin{center}
        $ \unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,u₁ ≡ u₂ ⊢ \t("t") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("A | u₁ ≡ u₂");Δ;Ξ ⊢ \t("t") : C)} $
      \end{center}
\item If the last used rule is ($×_i$) then we need to show
      $\v("{(li = vi) i∈I}ρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$. By definition it
      is enough to show that $\v("viρ") ∈ ⟦\f("Aiρ")⟧$ for all index $i$ in
      $I$. This exactly corresponds to the induction hypotheses.
      \begin{center}
        $ \unaryRN{×_i}{[Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))} $
      \end{center}
\item If the last used rule is ($×_e$) then we need to show that
      $\t("(v.lk)ρ") ∈ |\f("Akρ")|$. By induction hypothesis we know that
      $\v("vρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$, hence by definition
      $\v("vρ") = \v("{(li = vi) i∈I}")$ and for all index $i$ in $I$ we
      have $\v("vi") ∈ ⟦\f("Aiρ")⟧$. Let us now take $π ∈ ||\f("Akρ")||$ and
      show that $\p("{(li = vi) i∈I}.lk ∗ π") ∈ \dbot$. As $k$ is in $I$, we
      have $\p("{(li = viρ) i∈I}.lk ∗ π") ≻ \p("viρ ∗ π")$, hence it is enough
      to show $\p("vkρ ∗ π") ∈ \dbot$ as $\dbot$ is saturated. Since
      $π ∈ ||\f("Akρ")||$, we only have to show $\v("vkρ") ∈ |\f("Akρ")|$.
      We can hence conclude using \thmRef("orthosimple") since we know that
      $\v("vkρ") ∈ ⟦\f("Akρ")⟧$.
      \begin{center}
        $ \binaryRN{×_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))}{
          k∈I}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)} $
      \end{center}
\item If the last used rule is ($+_i$) then we need to show
      $\t("(Ck[v])ρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$. By definition we only need
      to show $\v("vρ") ∈ ⟦\f("Akρ")⟧$ since the index $k$ is in $I$. This is
      exactly the induction hypothesis.
      \begin{center}
        $ \binaryRN{+_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))}{k∈I}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]"))} $
      \end{center}
\item If the last used rule is ($+_e$) then we need to show
      $\t("[v | (Ci[xi] → ti) i∈I]ρ") ∈ |\f("Bρ")|$. By induction hypothesis
      we know that $\v("vρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$, hence by definition
      $\v("vρ") = \v("Ck[w]")$ for some index $k$ in $I$ and $w ∈ \f("Akρ")$.
      Let us now take a stack $π ∈ ||\f("Bρ")||$ and show that
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ∈ \dbot$. As
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ≻ \p("tkρ[xk≔w] ∗ π")$ and
      $\dbot$ is saturated, it is enough to show
      $\p("tkρ[xk≔w] ∗ π") ∈ \dbot$. Let us now consider the valuation
      $\subs("ρ[xk≔w]")$. Up to renaming, we can assume that $\v("xk")$ does
      not appear free in $\f("B")$, hence $\f("Bρ") = \f("Bρ[xi≔w]")$.
      Consequently we have $π ∈ ||\f("Bρ[xk≔w]")||$, hence it is enough to
      show that $\t("tkρ[xk≔w]") ∈ |\f("Bρ[xk≔w]")|$. We can conclude by
      induction hypothesis using the valuation $\subs("ρ[xk≔w]")$ since
      $\v("vρ[xk≔w]") ≡ \v("Ck[w]")$.
      \begin{center}
        $ \binaryRN{+_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))}{
          [Σ, x_i : ι ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)} $
      \end{center}
\item If the last used rule is ($≡_{l, {val}}$) then we need to show
      $\t("(t[x≔v₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $x ∉ dom(ρ)$, hence $\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$
      and $\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$. By hypothesis we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$, hence \thmRef("extvalue") gives us
      $\t("tρ[x≔v₁ρ]") ≡ \t("tρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[x≔v₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_{l, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_l$) then we need to show
      $\t("(t[a≔u₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $a ∉ dom(ρ)$, hence $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$
      and $\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$. By hypothesis we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$, hence \thmRef("extterm") gives us
      $\t("tρ[a≔u₁ρ]") ≡ \t("tρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[a≔u₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_l}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_{r, {val}}$) then we need to show
      $\t("tρ") ∈ |\f("(A[x≔v₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[x≔v₂])ρ")|$ so we will show
      $|\f("(A[x≔v₁])ρ")| = |\f("(A[x≔v₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[x≔v₁])ρ")⟧ = ⟦\f("(A[x≔v₂])ρ")⟧$.
      Without loss of generality we may assume that $x ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[x≔v₁ρ]")⟧ = ⟦\f("Aρ[x≔v₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformvalue") as we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_{r, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₁]"))} $
      \end{center}
\item If the last used rule is ($≡_r$) then we need to show
      $\t("tρ") ∈ |\f("(A[a≔u₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[a≔u₂])ρ")|$ so we will show
      $|\f("(A[a≔u₁])ρ")| = |\f("(A[a≔u₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[a≔u₁])ρ")⟧ = ⟦\f("(A[a≔u₂])ρ")⟧$.
      Without loss of generality we may assume that $a ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[a≔u₁ρ]")⟧ = ⟦\f("Aρ[a≔u₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformterm") as we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_r}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))} $
      \end{center}
\end{itemize}
\end{proof}
\end{thm}

=<

(*
=> Simple types

In order to prevent undesired computational behaviours such as runtime
errors, functional programming languages rely on syntactic checks. We
will first consider a small type system with only three type constructors:
functions, products (in the form of records) and sums (in the form of
variants).
\begin{def}
The set of all types $\cal{F}$ is built using the following ||bnf|| grammar.
$$ A,B ::= \f("A ⇒ B") \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")$$
\end{def}
\begin{rem}
To lighten the notations, we will consider the function type to be right
associative. That is, we will always read a type of the form
$\f("A ⇒ B ⇒ C")$ as $\f("A ⇒ (B ⇒ C)")$.
\end{rem}
Through the Curry-Howard isomorphism, it is possible to see our type system
as a logic. In particular, a type can be read as a formula in which the
arrow type corresponds to logical implication. Similarly, product and sum
types can be interpreted as logical conjunction and disjunction.

To be able to assign a type to terms containing free variables, we need to
use typing contexts. A typing context will map variables to their assumed
type. Logically, a context will simply correspond to a set of hypothesis.
That is, a set of formulas that are assumed to be true.
\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ such that for all
$λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent contexts using lists generated using the following ||bnf|| grammar.
$$ Γ ::= • \| {Γ, x : A} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgement is a triple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$ and
a context $Γ$ that is denoted $Γ ⊢ t : A$. A judgment is said to be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$ and if $FV_ι(t) ∪ FV_μ(t) = ∅$.
To lighten the notations we will write $⊢ t : A$ instead of $Γ ⊢ t : A$ when
$Γ = •$.
\end{def}
\begin{rem}
Our first type system will only be able to work with terms not containing
$μ$-variables or term variables. The mechanism for handling such variables
will be introduced in later sections.
\end{rem}
\begin{rem}
In the following, we will only consider well-formed judgements. This
information will be kept implicit most of the time.
\end{rem}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B")}{Γ ⊢ u : A}{Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]")}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
\end{def}
\begin{rem}
The derivability of a judgement $⊢ t : A$ is equivalent to the provability
of the logical formula corresponding to $A$ in intuitionistic propositional
logic. As $t$ alone sufices to recover the derivation (only one rule can be
applied for every term constructor), we may think of it as a proof of $A$.
Consequently, we associate a computational behavious to a proof. For example,
a term $t$ of type $\f("A ⇒ B")$ will correspond to a procedure turning a
proof of the formula $A$ into a proof of the formula $B$.
\end{rem}

Let us now consider a few examples of typing derivations. First, we can show
that the term $t = \t("λf λx λy f {l₁ = x; l₂ = y;}")$ has type
$\f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")$ for any given types $A$, $B$
and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx λy f {l₁ = x; l₂ = y;}")
     : \f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C") ⊢ \t("λx λy f {l₁ = x; l₂ = y;}")
     : \f("A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A ⊢ \t("λy f {l₁ = x; l₂ = y;}")
     : \f("B ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("f {l₁ = x; l₂ = y;}") : C
   }{
     \axiomN{Ax}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ f
         : \f("{l₁ : A; l₂ : B;} ⇒ C")
     }
   }{
     \binaryN{×_i}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("{l₁ = x; l₂ = y;}")
         : \f("{l₁ : A; l₂ : B;}")
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ x : A
       }
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ y : B
       }
     }
   }
  }}}}
$$
\end{env}
Similarly, we can show that the term $u = \t("λf λx f x.l₁ x.l₂")$ is also
typable. It can be given the type $\f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")$
for any given types $A$, $B$ and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx f x.l₁ x.l₂") : \f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("A ⇒ B ⇒ C") ⊢ \t("λx f x.l₁ x.l₂") : \f("{l₁ : A; l₂ : B;} ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁ x.l₂") : C
   }{
     \binaryN{⇒_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁")
         : \f("B ⇒ C")
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ f
           : \f("A ⇒ B ⇒ C")
       }
     }{
       \unaryN{×_e}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₁") : A
       }{
         \axiomN{Ax}{
           f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
             : \f("{l₁ : A; l₂ : B;}")
         }
       }
     }
   }{
     \unaryN{×_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₂") : B
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
           : \f("{l₁ : A; l₂ : B;}")
       }
     }
   }
  }}}
$$
\end{env}
The terms $t$ and $u$ correspond respectively to the curryfication operation
and its inverse. The former turns a function taking as input a couple into
a function of two arguments, and the latter turns a function of two arguments
into a function taking as input a couple. Logically, these terms correspond
to both sides of a proof of the following theorem of intuitionistic
propositional logic.
$$ (A \land B → C) ↔ (A → B → C) $$

In the next two sections, we will present two rather orthogonal extensions
of our small type system. The former will provide a mechanism for handling
terms of the \lmcalc, which will allow us to type more terms of our language
and will enable classical reasoning.
(* *)
The second extension will be System F polymorphism, and it will allow
universal quantification over a type. Our system will then correspond
to predicate logic.

=<

=> First extension: \lmcalc and classical logic

We are now going to extend our type system with a mechanism for typing terms
of the \lmcalc, and not only terms of the $λ$-calculus. The \lmcalc provides
control structures, which have been shown to give a computational
interpretation to classical logic by Timothy Griffin \cite("Griffin1990"). As
a consequence, the obtained system will not be limited to intuitionistically
provable formulas anymore.

\begin{def}
A continuation context is a finite map $Δ$ over $\cal{V}_μ$ such that for all
$μ$-variable $α ∈ dom(Δ)$ we have $Δ(α) ∈ \cal{F}$. As for typing contexts,
we will represent continuation contexts using lists generated by the
following ||bnf|| grammar.
$$ Δ ::= • \| {Γ, α : A} $$
We will implicitly consider that variables can only be mapped once in a
continutation context, and that their order is not relevant.
\end{def}

\begin{def}
A typing judgement is a tuple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$, a
typing context $Γ$ and a continuation context $Δ$ that is denoted
$Γ ⊢ t : A; Δ$. A judgment is said to be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) ⊆ dom(Δ)$ and if $FV_ι(t) = ∅$. To lighten the
notations we will write $⊢ t : A; Δ$ (resp. $Γ ⊢ t : A$) instead of
$Γ ⊢ t : A; Δ$ when $Γ = •$ (resp. $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A; Δ}
  \hspace(1.6)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B; Δ}{Γ ⊢ \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(1.6)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B"); Δ}{Γ ⊢ u : A; Δ}{Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i; Δ]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}"); Δ}{Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j; Δ}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"); Δ}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
\end{def}

As an example, the following type derivation shows that the term
$\t("λf μα f λx [α]x")$ can be given a type corresponding to Peirce's Law.
This formula is not intuitionistically provable, and thus this type cannot
be inhabited by a term of the $λ$-calculus.
\begin{env}(scale 0.92)
$$
  \proofTree{
    \unaryN{⇒_i}{
      ⊢ \t("λf μα f λx [α]x") : \f("((A ⇒ B) ⇒ A) ⇒ A")
    }{
      \unaryN{μ}{
        f:\f("(A ⇒ B) ⇒ A") ⊢ \t("μα f λx [α]x") : A
      }{
        \binaryN{⇒_e}{
          f:\f("(A ⇒ B) ⇒ A") ⊢ \t("f λx [α]x") : A; α:A
        }{
          \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A") ⊢ f : \f("(A ⇒ B) ⇒ A"); α:A}
        }{
          \unaryN{⇒_i}{
            f:\f("(A ⇒ B) ⇒ A") ⊢ \t("λx [α]x") : \f("A ⇒ B"); α:A
          }{
            \unaryN{[{-}]}{
              f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ \t("[α]x") : A; α : A
            }{
              \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ x : A; α:A}
            }
          }
        }
      }
    }
  }
$$
\end{env}

=<

=> Second extension: polymorphism and universal quantification

We will now define a second extension of our type system, which will provide
us with more expressive types. Let us consider the term $\t("λx λy x")$,
which can be given type $\f("X ⇒ Y ⇒ X")$ given two types $X$ and $Y$.
$$
\proofTree{
  \unaryN{⇒_i}{⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
  \unaryN{⇒_i}{x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
    \axiomN{Ax}{x : X, y : Y ⊢ x : X}
  }}
}
$$
The term $\t("λx λy x")$ really corresponds to a function taking as input
two arguments, and returning the first one directly. Note that we do not need
to say anything about the nature of the arguments this function may accepts.
In fact, this function can be applied to arguments of any two types. This
information is not conveyed by the type $\f("X ⇒ Y ⇒ X")$, as it only
specifies that the function takes arguments of two particular types $X$ and
$Y$, and returns an element of type $X$.

To solve this expressivity problem, we extend our type system with a new
type constructor for universal quantification, or polymorphism. We will then
be able to use types like $\f("∀X ∀Y X ⇒ Y ⇒ X")$. The obtained system is
called System F, it was introduced by Jean-Yves Girard and John Reynolds
independently \mcite(["Girard1972";"Reynolds1974"]).

\begin{def}
The set of all types (or formulas) $\cal{F}$ is now built from a countable
set of type variables $\cal{V}_ο = \{X, Y, Z...\}$ using the following
||bnf|| grammar.
\Caml(
let _ = sidenote
  << $ A,B ::= \f("X") \| \f("A ⇒ B") \| \f("∀X A") \|
    \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]") $ >>
  << $ X ∈ \cal{V}_ο $ >>
)
We denote $FV_ο(A)$ the set of free type variables contained in $A$. Given
a typing context $Γ$ we will write $FV_ο(Γ)$ the set of free type variables
contained in the types of $Γ$.
\end{def}
\begin{rem}
To lighten the notations, we will consider that universal quantification
binds stronger than the function type. As a consequence, we will read
$\f("∀X ∀Y X ⇒ Y ⇒ X")$ as $\f("∀X (∀Y (X ⇒ (Y ⇒ X)))")$.
\end{rem}

As types can now contain free variables, our typing judgments will carry
a list of type variables with the invariant that only these type variables
can appera free in the judgement.
\begin{def}
A type variable context is a finite set of type variables denoted $Σ$. For
convenience, we will represent type variable contexts using lists generated
using the following ||bnf|| grammar.
\Caml(let _ = sidenote << $ Σ ::= • \| {Σ, X} $ >> << $ X ∈ \cal{V}_ο $ >>)
However, we need to keep in mind that type variables can only appear once
in a type variable context, and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgment is a quadruple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$,
a typing context $Γ$ and a type variable context $Γ$ that is denoted
$Σ; Γ ⊢ t : A$. A judgment is sait do be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) = ∅$, $FV_ι(t) = ∅$, $FV_ο(A) ⊆ Σ$ and
$FV_ο(Γ) ⊆ Σ$. To lighten the notations we will write $Γ ⊢ t : A$ (resp.
$Σ ⊢ t : A$, resp. $⊢ t : A$) instead of $Σ; Γ ⊢ t : A$ when $Γ = •$ (resp.
$Δ = •$, resp. $Γ = •$ and $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system. Note that a rule only
applies if all the involved judgments are well-formed.
$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢ x : A}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B}{Σ; Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(4.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B")}{Σ; Γ ⊢ u : A}{Σ; Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢ v_i : A_i]_{i∈I}}{
    Σ; Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ; Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Σ; Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢ v : A_j)}{
    Σ ⊢ (Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"))}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
$$
  \unaryRN{{∀}_i}{Σ, X; Γ ⊢ t : A}{Σ; Γ ⊢ t : \f("∀X A")}
  \hspace(4.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A")}{Σ; Γ ⊢ t : \f("A[X≔B]")}
$$
\end{def}
\begin{rem}
The condition on the well-formedness of all the judgments imply that the
$∀_i$ rule may only apply when $X ∉ FV_ο(Γ)$. If it were not the case then
the conclusion judgments of the rule could not be well-formed.
\end{rem}

As an example, the proof that $\t("λx λy x")$ has type $\f("∀X ∀Y X ⇒ Y ⇒ X")$
can be derived as follows in the system. Note that this type is fully
specified, in the sense that we did not say anything like
"for all given types".
$$
  \proofTree{
    \unaryN{∀_i}{⊢ \t("λx λy x") : \f("∀X ∀Y X ⇒ Y ⇒ X")}{
    \unaryN{∀_i}{X ⊢ \t("λx λy x") : \f("∀Y X ⇒ Y ⇒ X")}{
      \unaryN{⇒_i}{X, Y ⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
        \unaryN{⇒_i}{X, Y; x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
          \axiomN{Ax}{X, Y; x : X, y : Y ⊢ x : X}
  }}}}}
$$

It would seem that polymophism and classical logic are two rather orthogonal
extensions of the simple system. However, we will see in the next section that
they actually interact in a very subtle way. Indeed, the naive approach breaks
the type safety and the consistency of the system. More generally, the
problem is related to call-by-value evaluation and side-effects. Historicaly,
it was first identified in the context of ||ml||.

=<

*)


=<
