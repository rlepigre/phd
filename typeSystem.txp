\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>
)
\Include{Macros}

=> Higher-order types and semantics \label("typeSystem")

In this chapter, we present a new type system which distinguishing feature
is an embedded notion of program equivalence. It enables the specification
of equational properties over programs, which can then be proved using
equational reasoning. Our types are interpreted using standard classical
realisability techniques, which allows for a semantical justification of
our typing rules.

=> Observational equivalence type

One of the main goals of this thesis is to build a type system that can be
used to reason about programs. To achieve this goal, we need to be able to
specify program behaviours using types. We hence introduce equality types
of the form $\f("t ≡ u")$, where $t$ and $u$ are (possibly untyped) terms.
Intuitively, an equality type is interpreted as $⊤$ (i.e. logical truth,
the biggest type) if $t ≡_{≻} u$, and as $⊥$ (i.e. logical absurdity, the
empty type) if $t \nequiv_{≻} u$. For example, the type
$\f("(λx x) λx x ≡ λx x")$ is inhabited as $\t("(λx x) λx x") ≡_{≻}
\t("λx x")$ according to \thmRef("cbvbeta"), but $\f("λx x ≡ {}")$ is empty
as $\t("λx x") \nequiv_{≻} \t("{}")$ according to \thmRef("nequiv").

Of course, it is undecidable whether two terms are equivalent or not. As a
consequence, we will not be able to decide, in general, whether an equality
type is inhabited or not. We will hence need to rely on a partial decision
procedure that will only approximate our observational equivalence relation.
\begin{thm}
Given $t ∈ Λ$ and $u ∈ Λ$ it is undecidable whether $t ≡_{≻} u$ or
$t \nequiv_{≻} u$.
\begin{proof}
We are going to encode the halting problem $H_t$ using equivalence. In our
system, $H_t$ can be stated as ${\p("t ∗ ε")} {⇓}_{≻}$. Let us
consider a term $Ω ∈ Λ$ such that ${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$.
We will now show that $H_t$ is equivalent to
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. Let us suppose $H_t$ and show
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. We need to find a stack $π ∈ Π$ such
that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ and ${\p("Ω ∗ π")} {⇑}_{≻}$. This is in fact
true for all $π$ as ${\p("Ω ∗ π")} {⇑}_{≻}$ by hypothesis and
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")} {⇓}_{≻}$ since we supposed $H_t$. We now
suppose ${\t("[ε]t") \nequiv_{≻} \t("Ω")}$ and show $H_t$. By definition,
there must be a stack $π ∈ Π$ such that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ since
${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$. Now since we have
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")}$ we obtain $H_t$.
\end{proof}
\end{thm}

In the system, proving a program equivalence amounts to showing that the
corresponding equality type is inhabited. However, an equivalence type
may also be used as an assumption. For example, it is possible to define
a function which input type is an equivalence. As a consequence, we need
a form of context to store the set of program equivalences that are
assumed to be true during a proof.
\begin{def}
An equational context $Ξ ⊆ \cal{P}(Λ × Λ)$ is a finite set of couples
of terms denoting hypothetical equivalences. For convenience, equational
contexts we will represented using lists generated using the following
||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Ξ ::= • \| {Ξ, t ≡ u}$ >> << $t,u ∈ Λ$ >>)
\end{def}

During the construction of a proof, the equational context grows with new
hypotheses and equivalences need to be proved eventually. As mentioned
previously, we rely on a partial decision procedure that is supposed
correct, but remains otherwise unspecified. The implementation of such a
decision procedure is discussed in \chapter("implem").
\begin{def}
Given an equational context $Ξ$ and a substitution $ρ$, we say that $ρ$
//realizes// $Ξ$ and we write $ρ ⊩ Ξ$ if for every $(t,u) ∈ Ξ$ we have
$\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}
\begin{def}
Let $Ξ$ be an equational context and $t ∈ Λ$ and $u ∈ Λ$ be two terms. We
write $Ξ ⊢ t ≡ u$ if our (unspecified by supposed correct) decision
procedure is able to show that for every substitution $ρ$ such that $ρ ⊩ Ξ$
we have $\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}

=<
=> Quantification and membership type

Although equality types can be used to derive simple equational properties,
their use is rather limited without a form of quantification. Indeed, they
only allow the derivation of static equivalences like $\t("(λx x) {}") ≡_{≻}
\t("{}")$, but they cannot be used to show more general properties like
"$\t("(λx x) v") ≡_{≻} \t("v")$ for every value $v$".
(* *)
Terms can contain free variables of several sorts: $λ$-variables (i.e. value
variables), term variables and $μ$-variables (i.e. stack variables). As open
terms may appear in types, and in particular in equality types, it is natural
to allow universal and existential quantification over all three sorts of
variables. We can hence use types like $\f("∀y (λx x) y ≡ y")$ or
$\f("∀x ∀y x ≡ y ⇒ C[x] ≡ C[y]")$.
\begin{rem}
The forms of quantification described here range over all (closed) value,
terms or stacks regardless of their types.
\end{rem}
\begin{rem}
It is not clear whether quantification over stacks has a practical use. We
only include it as it fits well in the framework and has no extra cost.
\end{rem}

Quantifying over all the (closed) values or terms is not always enough.
Indeed, we often need to quantify over the values or the terms of a given
type only. For example if we quantify over a $λ$-variable that is used in
a case analysis, then a runtime error will be produced for values that do
not correspond to matched constructors. This would not happen when
quantifying over value of the appropriate sum type only.

To achieve typed quantification we introduce a membership type constructor
$\f("t ∈ A")$ where $t ∈ Λ$ is a term and $A ∈ \cal{F}$ is a type. The
elements of $\f("t∈A")$ are those of $A$ that are equivalent to $t$. In
particular, $\f("t ∈ A")$ is empty if $t$ does not have type $A$.
Intuitively, $\f("t∈A")$ can be read as the proposition "$t$ has type $A$",
but we will see later that a more appropriate interpretation would be
"$t$ realizes $A$". Using membership, we can use the well-known relativized
quantification scheme to obtain a dependent function type.
$$ Π_{x : A} B ≔ \f("∀x (x∈A ⇒ B)") $$
The dependent function type exactly correspond to typed quantification as
its elements can only be applied to values of type $A$. Other values are
simply filtered out.
(* *)
Note that we can define a dependent pair type using existential
quantification as follows.
$$ Σ_{x : A} B ≔ \f("∃x {l₁ : x∈A ; l₂ : B}") $$
(* *)
We can also define the same kind of type constructors by quantifying over
term variables in the exact same way.
$$
  Π_{a : A} B ≔ \f("∀a (a∈A ⇒ B)")
  \hspace(4.0)
  Σ_{a : A} B ≔ \f("∃a {l₁ : a∈A ; l₂ : B}")
$$
\begin{rem}
Nothing prevents the variable that is quantified over to appear in $A$.
However, it is not clear whether that is useful in practice.
\end{rem}

=<
=> Sorts and higher-order types

Our type system allows universal and existential quantification over
several sorts of objects. There are first order quantifiers ranging over
values, terms and stack, as shown in the previous section. And the system
also provides second order quantification (i.e. quantification over types),
which corresponds to System F polymorphism and type abstraction. All of
these different forms of quantifiers are handled uniformly in the syntax
and in the semantics thanks to a higher-order formulation.

The higher-order features of the system allow us to define (and quantify
over) types with parameters of any sort. For example, we can define a type
parametrized by another type or a term. This leads to a system in which
it is syntactically correct to use a (not fully applied) parametric type,
or even a term, as a type. This does not make sense, and hence we must make
sure that this does not happen. The usual approach to tackle this problem
is to assign a form of type (called sort) to the types themselves. This
will give use the guarantee that our types are "well-formed".
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= κ \| {s→r}$ >> << $κ∈\cal{S}₀$ >>)
\end{def}

The language of sorts only contains constants and an arrow constructor for
functions. Our "sort system" will in fact be very similar to the simply
typed $λ$-calculus. In particular, the syntax of our types will contain a
constructor for building functions (i.e. $λ$-abstraction) and a corresponding
constructor for application.
\begin{def}
We require a countable set $\cal{V}_ο = \{X, Y, Z...\}$ of propositional
variables that does not intersect with $\cal{V}_ι$, $\cal{V}_τ$ and
$\cal{V}_σ$.
\end{def}
\begin{def}
We require a countable set of variables $\cal{V} = \{χ, ξ, φ...\}$ such that
for every atomic sort $s ∈ \cal{S}₀$ we have $\cal{V}_s ⊆ \cal{V}$. Given a
variable $χ∈\cal{V}$, we will sometimes write $χ^s$ to mean that $χ$ is to
be considered as a variable of sort $s$. In particular, variables in
$\cal{V}_s$ with $s ∈ \cal{S}₀$ will always be considered as variables of
sort $s$.
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is built from $\cal{V}$, $Λ_{val}$,
$Λ$ and $Π$ using the following ||bnf|| grammar.
\begin{center}
\linesBefore(2)
$ A,B ::= v \| t \| π \| \f("χ") \| \f("(χ^s ↦ A)") \| \f("A(B)")
  \| \f("A⇒B") \| \f("t∈A") \| \f("t≡u")$

$ \id([]) \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")
  \| \f("∀χ^s A") \| \f("∃χ^s A") $
\end{center}
\end{def}
Our types contain values, terms and stacks, as they will correspond to
types of sort $ι$, $τ$ and $σ$. We then have variables of all sorts,
abstraction to build types with an arrow sort and application. All the
remaining constructors are used to build propositions (i.e. actual
formulas) which will be given sort $ο$. Note that the quantifiers may
range over and produce types of any sort. They are hence very general.
\begin{rem}
The variable constructor in the syntax of types is somewhat redundant for
values, terms and stacks. Indeed, these syntactic entities already provide
variables.
\end{rem}

To track the sort of variables in types we need to introduce a form of
context. It can then be used to define our notion of well-formed type
using a deduction rule system. We will then only consider types that can
be show well-formed in this system.
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, we will represent
sorting contexts using comma-separated lists of sort assignments generated
by the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Σ ::= • \| {Σ, χ : s}$ >>
  << $χ ∈ \cal{V}, s ∈ \cal{S} $ >>)
\end{def}
\begin{def}
A sorting judgment is a triple of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the deduction rules of
\figRef("sortrules").
\end{def}
\Caml(
let r11 =
  << $\unaryR{Σ, x : ι ⊢ \t("t") : τ}{Σ ⊢ \v("λx t") : ι}$ >>
let r12 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \v("C[v]") : ι}$ >>
let r13 =
  << $\unaryR{\{Σ ⊢ \v("vi") : ι\}_{i∈I}}{Σ ⊢ \v("{(li = vi) i∈I}") : ι}$ >>
let r21 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("v") : τ}$ >>
let r22 =
  << $\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \t("u") : τ}{Σ ⊢ \t("t u") : τ}$ >>
let r23 =
  << $\unaryR{Σ, α : σ ⊢ \t("t") : τ}{Σ ⊢ \t("μα t") : τ}$ >>
let r31 =
  << $\binaryR{Σ ⊢ \s("π") : σ}{Σ ⊢ \t("t") : τ}{Σ ⊢ \t("[π]t") : τ}$ >>
let r32 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("v.l") : τ}$ >>
let r33 =
  << $\binaryR{Σ ⊢ v : ι}{\{Σ, x_i : ι ⊢ \t("ti") : τ\}_{i∈I}}{
       Σ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : τ}$ >>
let r41 =
  << $\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("Y(t,v)") : τ}$ >>
let r42 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("U(v)") : τ}$ >>
let r43 =
  << $\binaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \v("w") : ι}{Σ ⊢ \t("δ(v,w)") : τ}$ >>
let r51 =
  << $\axiomR{Σ ⊢ \s("ε") : σ}$ >>
let r52 =
  << $\binaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \s("π") : σ}{Σ ⊢ \s("v · π") : σ}$ >>
let r53 =
  << $\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \s("π") : σ}{Σ ⊢ \s("[t] π") : σ}$ >>
let r61 =
  << $\axiomR{Σ, χ : s ⊢ χ : s}$ >>
let r62 =
  << $\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ ↦ A)") : s → r}$ >>
let r63 =
  << $\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}$ >>
let r71 =
  << $\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f("A ⇒ B") : ο}$ >>
let r72 =
  << $\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}$ >>
let r73 =
  << $\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}$ >>
let r81 =
  << $\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∀χ A") : r}$ >>
let r82 =
  << $\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∃χ A") : r}$ >>
let r83 =
  << $\binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f("t∈A") : ο}$ >>
let r91 =
  << $\binaryR{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f("t≡u") : ο}$ >>

let rs env =
  (* let env = resize_env 3.4 env in *)
  let rs =
    [ [ r11 ; r12 ; r13 ] ; [ r21 ; r22 ; r23 ] ; [ r31 ; r32 ; r33 ]
    ; [ r41 ; r42 ; r43 ] ; [ r51 ; r52 ; r53 ] ; [ r61 ; r62 ; r63 ]
    ; [ r71 ; r72 ; r73 ] ; [ r81 ; r82 ; r83 ] ; [ r91 ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let sortrules () =
  figure_here ~name:"sortrules" ~caption:[tT "Sorting rules."] (dr rs)
)

The main role of the sorting rules is to keep track of the sort of the free
variables. The rules on the first five lines of \figRef("sortrules") simply
traverse the structure of values, terms and stacks to save the sort of the
free variables in the context. Note that the first rule on the sixth line is
also used for value, term and stack variables.

As an example $\f("λx x ⇒ {}")$ is not well-formed as the type at the left
of the arrow does not have sort $ο$ (it has sort $ι$ or $τ$). However,
$\f("(X ↦ [C₀:{} | C₁ : X])([C₂:{} | C₃:{}])")$ is a well-formed type of
sort $ο$, as shown by the following proof tree.
$$
  \proofTree{
    \binary{⊢ \f("(X ↦ [C₀ : {} | C₁ : X])([C₂ : {} | C₃ : {}])") : ο}{
      \unary{⊢ \f("(X ↦ [C₀ : {} | C₁ : X])") : ο → ο}{
        \binary{X : ο ⊢ \f("[C₀ : {} | C₁ : X]") : ο}{
          \axiom{X : ο ⊢ \f("{}") : ο}
        }{
          \axiom{X : ο ⊢ \f("X") : ο}
        }
      }
    }{
      \binary{⊢ \f("([C₂ : {} | C₃ : {}])") : ο}{
        \axiom{⊢ \f("{}") : ο}
      }{
        \axiom{⊢ \f("{}") : ο}
      }
    }
  }
$$

As types contain the $λ$-calculus, we need to consider their reduction and
normalization. First we define the notion of $β$-reduction in a type.
\begin{def}
We call a redex a type of the form $\f("(χ^s ↦ A)(B)")$, and we say that a
type is in normal form if it does not contain any redex. The reduction
relation over types is the smallest relation $({\inj}) ⊆ \cal{F} × \cal{F}$
such that:
\begin{itemize}
\item for every redex $\f("(χ^s ↦ A)(B)")$ we have
      $\f("(χ^s ↦ A)(B)") \inj \f("A[χ≔B]")$ and
\item $({\inj})$ is contextually closed. Reduction hence considers all the
      redexes in a type, and not only the surface ones.
\end{itemize}
\end{def}
\begin{thm}
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be a
sort. If the sorting judgment $Σ ⊢ A : s$ is valid, then the reduction
of $A$ terminates. More formally, there is a type $B$ that is in normal
form such that $A \inj^{∗} B$.
\begin{proof}
Well-known properties of the simply typed $λ$-calculus. (* FIXME ref ? *)
\end{proof}
\end{thm}
In the following sections, we will always consider well-formed types. As a
consequence, we may also assume that a type is in normal form as we can
alway normalize well-formed types according to the previous theorem.
###

###
\Caml(let _ = sortrules ())

=<
=> Typing judgments for values and terms

As our language is call-by-value and has operations generating side-effects,
we need to be careful to achieve type-safety. In particular, some of our
typing rules will not apply to terms, but only to values (as mentioned in
\chapter("intro")). Here, value restriction will be encoded using two forms
of judgments: usual typing judgments ranging over terms (including values),
and a restricted form of judgments ranging over values only.

To be able to assign types to terms containing free $λ$-variables and free
$μ$-variables, we consider two forms of contexts that our typing judgments
will carry.
\begin{def}
A //value context// is a finite map $Γ$ over $\cal{V}_ι$ such that for all
$x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will represent
typing contexts using comma-separated lists of type assignments generated
by the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Γ ::= • \| {Γ, x : A}$ >>
  << $x ∈ \cal{V}_ι, A ∈ \cal{F} $ >>)
\end{def}
\begin{def}
A //stack context// is a finite map $Δ$ over $\cal{V}_σ$ such that
for all $α ∈ dom(Δ)$ we have $Δ(α) ∈ \cal{F}$. For convenience, we will
represent typing contexts using comma-separated lists of type assignments
generated by the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 2 2 << $Δ ::= • \| {Δ, α : A}$ >>
  << $α ∈ \cal{V}_σ, A ∈ \cal{F} $ >>)
\end{def}

The full context of typing judgments will be build using a typing context,
a stack context and an equational context. As these contexts may contain
types and hence free variables, we need to define a notions of
well-formedness for these three kinds of contexts.
\begin{def}
Given a sorting context $Σ$, we say that a typing context $Γ$ is
well-formed and write $Σ ⊢ Γ$ if for all $x ∈ dom(Γ)$ we have
$Σ ⊢ Γ(x) : ο$ and $Σ ⊢ x : ι$.
\end{def}
\begin{def}
Given a sorting context $Σ$, we say that a stack context $Δ$ is well-formed
and write $Σ ⊢ Δ$ if for all $α ∈ dom(Δ)$ we have $Σ ⊢ Δ(α) : ο$ and
$Σ ⊢ α : σ$.
\end{def}
\begin{def}
Given a sorting context $Σ$, we say that an equational context $Ξ$ is
well-formed and write $Σ ⊢ Ξ$ if for all $(t,u) ∈ Σ$ we have
$Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{def}

Using our three forms of contexts, we can now define our actual judgments.
Again, a notion of well-formedness need to be considered as our judgments
contain objects of different sorts, which all need to be well-formed.
\begin{def}
A value judgement is a tuple of a typing context $Γ$, an equational context
$Ξ$, a value $v ∈ Λ_{val}$, a type $A ∈ \cal{F}$ and a stack context $Δ$
that is denoted $Γ; Ξ ⊢_\tval v : A; Δ$.
\end{def}
\begin{def}
A term judgement is a tuple of a typing context $Γ$, an equational context
$Ξ$, a term $t ∈ Λ$, a type $A ∈ \cal{F}$ and a stack context $Δ$ that is
denoted $Γ; Ξ ⊢ t : A; Δ$.
\end{def}
\begin{def}
Let $Σ$ be a sorting context. A value judgment $Γ; Ξ ⊢_\tval v : A; Δ$ is
said to be well-formed under $Σ$ if $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ Δ$, $Σ ⊢ v : ι$
and $Σ ⊢ A : ο$. In this case we write $Σ ⊢ (Γ; Ξ ⊢_\tval v : A; Δ)$
\end{def}
\begin{def}
Let $Σ$ be a sorting context. A term judgment $Γ; Ξ ⊢ t : A; Δ$ is said to
be well-formed under $Σ$ if $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ Δ$, $Σ ⊢ t : τ$ and
$Σ ⊢ A : ο$. In this case we write $Σ ⊢ (Γ; Ξ ⊢ t : A; Δ)$
\end{def}

We can now give the typing rules of our system, which will involved
well-formed term judgments and value judgments. Some of our rules also
rely on our decision procedure for term equivalence. They hence only
apply if the procedure succeeds.
\begin{def}
A value or term judgment is said to be valid if it can be derived using the
typing rules of \figRef("typerules").
\end{def}
The typing rules of our system, and hence typing derivations, only involve
well-formed judgments. In particular, a typing rule can only be applied if
all the involved judgments are well-formed.
\begin{rem}
Note that the $∀_i$ rule cannot apply if the variable $χ$ appears in the
contexts $Γ$, $Ξ$ and $Δ$ nor in $t$. This would prevent the conclusion
judgment to be well-formed.
\end{rem}

As our system is call-by-value and has effect, the $∀_i$ rule needs value
restriction to remain sound. In our formalism, this means that the $∀_i$
rule applies to value judgments. The $∈_i$ rule requires value restriction
as well, as otherise the system cannot be proved sound. As the $∈_i$ rule
will be involved in the derivation of the typing rule for the elimination
of the dependent function type in \section("encodedep"), the latter will
also need value restriction.

(* TODO from here *)

\Caml(
let r1 =
  <<$\axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Ξ ⊢_\tval \t("x") : A; Δ)}$>>

let r2 =
  <<$\unaryRN{↑}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : A; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("v") : A; Δ)}$>>

let r3 =
  <<$\unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Ξ ⊢ \t("t") : B; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢_\tval \v("λx t") : A ⇒ B; Δ)}$>>

let r4 =
  <<$\binaryRN{⇒_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : A ⇒ B; Δ)}{Σ ⊢ (Γ;Ξ ⊢ \t("u") : A; Δ)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t u") : B; Δ)}$>>

let r5 =
  <<$\unaryRN{μ}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
   {Σ ⊢ (Γ;Ξ ⊢ \t("μα t") : A; Δ)}$>>

let r6 =
  <<$\unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
   {Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("[α]t") : B; Δ,α:A)}$>>

let r7 =
  <<$\unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Ξ ⊢_\tval \v("v") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A");Δ)}$>>

let r8 =
  <<$\binaryRN{∀_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∀χ^s A");Δ)}{Σ ⊢ B : s}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]");Δ)}$>>

let r9 =
  <<$\binaryRN{∃_i}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ≔B]");Δ)}{Σ ⊢ B : s}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∃χ^s A");Δ)}$>>

let rA =
  <<$\binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Ξ ⊢ \t("t") : \f("C");Δ)}
   {Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Ξ ⊢ \t("t") : \f("C");Δ)}$>>

let rB =
  <<$\unaryRN{∈_i}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : A;Δ)}
   {Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("v∈A");Δ)}$>>

let rC =
  <<$\unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,x≡t ⊢ \t("t") : C;Δ)}
   {Σ, x:ι ⊢ (Γ,x:\f("t∈A");Ξ ⊢ \t("t") : C;Δ)}$>>

let rD =
  <<$\binaryRN{↾_i}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : A;Δ)}{Ξ ⊢ \t("u₁") ≡ \t("u₂")}
   {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A | u₁≡u₂");Δ)}$>>

let rE =
  <<$\unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,\t("u₁")≡\t("u₂") ⊢ \t("t") : C;Δ)}
   {Σ, x:ι ⊢ (Γ,x:\f("A | u₁≡u₂");Ξ ⊢ \t("t") : C;Δ)}$>>

let rF =
  <<$\unaryRN{×_i}{[Σ ⊢ (Γ;Ξ ⊢_\tval \v("vi") : \f("Ai");Δ)]_{i∈I}}
   {Σ ⊢ (Γ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}");Δ)}$>>

let rG =
  <<$\binaryRN{×_e}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}");Δ)}
   {k∈I}{Σ ⊢ (Γ;Ξ ⊢ \t("v.lk") : A_k;Δ)}$>>

let rH =
  <<$\binaryRN{+_i}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("Ak");Δ)}{k∈I}
   {Σ ⊢ (Γ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]");Δ)}$>>

let rI =
  <<$\binaryRN{+_e}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]");Δ)}
   {[Σ ⊢ (Γ,x_i:A_i;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B;Δ)]_{i∈I}}
   {Σ ⊢ (Γ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B;Δ)}$>>

let rJ =
  <<$\binaryRN{≡_{l,τ,ι}}{Σ ⊢ (Γ;Ξ ⊢ \t("t[x≔v₁]") : A;Δ)}
   {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢ \t("t[x≔v₂]") : A;Δ)}$>>

let rK =
  <<$\binaryRN{≡_{l,τ,τ}}{Σ ⊢ (Γ;Ξ ⊢ \t("t[a≔u₁]") : A;Δ)}
   {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢ \t("t[a≔u₂]") : A;Δ)}$>>

let rL =
  <<$\binaryRN{≡_{r,τ,ι}}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[x≔v₁]");Δ)}
   {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[x≔v₂]");Δ)}$>>

let rM =
  <<$\binaryRN{≡_{r,τ,τ}}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[a≔u₁]");Δ)}
   {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[a≔u₂]");Δ)}$>>

let rN =
  <<$\binaryRN{≡_{l,ι,ι}}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[x≔v₁]") : A;Δ)}
   {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[x≔v₂]") : A;Δ)}$>>

let rO =
  <<$\binaryRN{≡_{l,ι,τ}}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[a≔u₁]") : A;Δ)}
   {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[a≔u₂]") : A;Δ)}$>>

let rP =
  <<$\binaryRN{≡_{r,ι,ι}}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[x≔v₁]");Δ)}
   {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[x≔v₂]");Δ)}$>>

let rQ =
  <<$\binaryRN{≡_{r,ι,τ}}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[a≔u₁]");Δ)}
   {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[a≔u₂]");Δ)}$>>

let rs env =
  let env = resize_env 3.0 env in
  let rs =
    [ [ r1 ; r3 ] ; [ r2 ; r4 ] ; [ r5 ; r6 ] ; [ r7 ; rA ] ; [ r8 ; r9 ]
    ; [ rC ; rD ] ; [ rB ; rE ] ; [ rG ; rH ] ; [ rF ] ; [ rI ] ; [ rJ ; rK ]
    ; [ rL ; rM ] ; [ rN ; rO ] ; [ rP ; rQ ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let _ = figure_here ~name:"typerules" ~caption:[tT "Typing rules."] (dr rs)
)

=<
=> Call-by-value realizability semantics

The abstract machine presented in \chapter("calculus") is part of a
//classical realizability// machinery that will be built upon here.
We aim at obtaining a semantical interpretation of our higher-order
type system. In particular, a proposition (i.e. a type of sort $ο$)
will be interpreted by three sets: a set of values, a set of stacks
and a set of terms. As always in classical realizability, the model
is parametrized by a pole, which serves as an exchange point between
the world of programs and the world of execution contexts, encoded
as stacks.
\begin{def}
A //pole// is a set of processes $\dbot ⊆ Λ×Π$ which is //saturated//
(i.e. closed under backward reduction). More formally, if we have
$q ∈ \dbot$ and $p ≻ q$ then $p ∈ \dbot$.
\end{def}

The notion of //orthogonality// is central in Krivine's classical
realizability. In this framework a type is interpreted (or realized) by
programs computing corresponding values. This interpretation is spread
in a three-layered construction, even though it is fully determined by
the first layer and the choice of the pole. The first layer consists of
a set of values that we will call the //raw semantics//. It gathers all
the syntactic values that should be considered as having the corresponding
type. As an example, if we were to consider the type of natural numbers,
its raw semantics would be the set $\{\hat{n} \| n ∈ \bbN\}$ where
$\hat{n}$ is some encoding of $n$.
(* *)
The second layer, called //falsity value//, is a set containing every
stack that is a candidate for building a valid process using any value
from the raw semantics. The notion of validity depends on the choice of
the pole. The third layer, called //truth value// is a set of terms that
is built by iterating the process once more. The formalism for the two
levels of orthogonality is given in the following definitions.
\begin{def}\label("orthodef1")
For every set $Φ ⊆ Λ_{val}$ we define a set $Φ^⊥ ⊆ Π$ as follows.
$$ Φ^⊥ = \{π∈Π \| ∀v∈Φ \p("v ∗ π") ∈ \dbot\} $$
\end{def}
\begin{def}\label("orthodef2")
For every set $Ψ ⊆ Π$ we define a set $Ψ^⊥ ⊆ Λ$ as follows.
$$ Ψ^⊥ = \{t∈Λ \| ∀π∈Ψ \p("t ∗ π") ∈ \dbot\} $$
\end{def}

We now give several general properties of orthogonality, which hold in
every call-by-value classical realizability model. They will be useful
when proving the soundness of our type system.
\begin{lem}\label("orthosimple")
If $Φ ⊆ Λ_{val}$ is a set of values, then $Φ ⊆ Φ^{⊥⊥}$.
\begin{proof}
We take $v ∈ Φ$ and show $v ∈ Φ^{⊥⊥}$. By definition we need to
show $\p("v∗π") ∈ \dbot$ for all stack $π ∈ Φ^⊥$. This is immediate
by definition of $Φ^⊥$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclstack")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be sets of values. If $Φ ⊆ Ψ$ then
$Ψ^⊥ ⊆ Φ^⊥$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$, take $π ∈ Ψ^⊥$ and show that $π ∈ Φ^⊥$.
By definition, we know that for all $v ∈ Ψ$ we have $\p("v ∗ π") ∈ \dbot$.
Since $Φ ⊆ Ψ$, this is also true for all $v ∈ Φ$, and hence $π ∈ Φ^⊥$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclterm")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be sets of values. If
$Ψ^⊥ ⊆ Φ^⊥$ then $Φ^{⊥⊥} ⊆ Ψ^{⊥⊥}$.
\begin{proof}
Let us suppose that $Ψ^⊥ ⊆ Φ^⊥$, take $t ∈ Φ^{⊥⊥}$ and show that
$t ∈ Ψ^{⊥⊥}$. By definition, we know that for all $π ∈ Φ^⊥$ we have
$\p("t ∗ π") ∈ \dbot$. Since $Ψ^⊥ ⊆ Φ^⊥$, this is also true for all
$π ∈ Ψ^⊥$, and hence $t ∈ Ψ^{⊥⊥}$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoblabla")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be sets of values. If $Φ ⊆ Ψ$ then
$Φ^{⊥⊥} ⊆ Ψ^{⊥⊥}$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$ and apply \lemRef("orthoinclstack") to obtain
$Ψ^⊥ ∈ Φ^⊥$. We can then conclude using \lemRef("orthoinclterm").
\end{proof}
\end{lem}

When choosing a pole, it is important to check that it does not yield a
degenerate model. In particular we need to check that no term is able to
face every stacks. If it were the case, such a term could be use as a
proof of $⊥$.
\begin{def}
A pole $\dbot ⊆ Λ×Π$ is said to be consistent if for every closed term
$t ∈ Λ$ there is a stack $π$ such that $\p("t ∗ π") ∉ \dbot$.
\end{def}

In our realizability model, the well-formed closed types will be
interpreted by the elements of a set defined according to their sort.
Such a set can be seen as the interpretation, in the model, of the sort
themselves.
\begin{def}
To every sort $s ∈ \cal{S}$ we associate a set $⟦s⟧$ defined as follows.
$$
  ⟦ι⟧ = Λ_{val}^{∗}
  \hspace(3.0)
  ⟦τ⟧   = Λ^{∗}
  \hspace(3.0)
  ⟦σ⟧   = Π^{∗}
$$
$$
  ⟦ο⟧   = \cal{P}(Λ_{val}^{∗} / {≡}_≻)
  \hspace(3.0)
  ⟦s→r⟧ = ⟦r⟧^⟦s⟧
$$
\end{def}
As we will only interpret closed types, it is convenient to extend the
syntax of types with the elements of the model. This widely used method
will allow us to consider closed types only in the semantics, and not
couples of open type and a substitution. Of course, an open type can
always be made into a closed types by replacing its free variables by
elements of the interpretation of the corresponding sort.
\begin{def}
We extend the syntax of types with the elements of the model. As a
consequence, we will consider that $⟦s⟧ ⊆ \cal{F}$ for every sort
$⟦s⟧$. Note that this is already true for $s = ι$, $s = τ$ and
$s = σ$. We will often use the letter $Φ$ to denote an element of the
model in the syntax. Our system is also extended with the following
sorting rule.
$$ \unaryR{Φ ∈ ⟦s⟧}{Σ ⊢ Φ : s} $$
\end{def}
\begin{def}
Given a sorting context $Σ$, we call a //valuation// over $Σ$ a finite
map $ρ$ such that for all $χ∈dom(Σ)$ we have $ρ(χ) ∈ ⟦Σ(χ)⟧$. If
$A∈\cal{F}$ is a type and $s∈\cal{S}$ is a sort such that $Σ ⊢ A: s$
then we denote $\f("Aρ")$ the type formed by applying $ρ$ to $A$.
\end{def}
\begin{lem}
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be
a sort such that $Σ ⊢ A : s$. If $ρ$ is a valuation over $Σ$ then
$⊢ \f("Aρ") : s$.
\begin{proof}\label("typeval")
... (* TODO *)
\end{proof}
\end{lem}

We can now give the interpretation of our type constructors in our model.
In particular, the elements of the model such as values, terms or stacks
will be interpreted as themselves.
\begin{def}
To every closed type $A ∈ \cal{F}$ we associate a set $⟦A⟧$ called its
//interpretation//. It is defined inductively on the structure of $A$ as
follows.
\begin{center}
\diagram(
let _ =
  let line s m = [ vs s; <$=$>; m ] in
  array [`East ; `East ; `West]
  [ line "Φ"               <$ Φ $>
  ; line "(χ^s ↦ A)"       <$ Φ ↦ \vs("A[χ≔Φ]") $>
  ; line "A(B)"            <$ ⟦A⟧(⟦B⟧) $>
  ; line "A ⇒ B"           <$ \{\v("λx t") \| ∀v∈\vs("A"),
                                 \t("t[x≔v]") ∈ \ts("B")\} $>
  ; line "t ∈ A"           <$ \{\v("v") ∈ \vs("A") \|
                                 \v("v") ≡_{≻} \t("t")\} $>
  ; line "A | t ≡ u"       <$ \{\v("v") ∈ \vs("A") \|
                                 \t("t") ≡_{≻} \t("u")\} $>
  ; line "{(li : Ai) i∈I}" <$ \{\v("{(li = vi) i∈I}") \| ∀i∈I,
                                 \v("vi")∈\vs("Ai")\} $>
  ; line "[(Ci : Ai) i∈I]" <$ \bigcup_{i∈I} \{\v("Ci[v]") \| v∈\vs("Ai")\} $>
  ; line "∀χ^s A"          <$ \biginter_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "∃χ^s A"          <$ \bigcup_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $> ]
)
\end{center}
\end{def}
\begin{rem}
We have $\vs("A | t ≡ u") = \vs("A")$ if $t ≡_{≻} u$ and
$\vs("A | t ≡ u") = ∅$ otherwise. We also have $\vs("t∈A") = ∅$ if there
is no $v ∈ \vs("A")$ such that $v ≡_{≻} t$.
\end{rem}
\begin{thm}\label("sortsem")
Let $A∈\cal{F}$ be a type and $s∈\cal{S}$ be a sort. If $⊢ A : s$ then
$\vs("A") ∈ ⟦s⟧$.
\begin{proof}
... (* TODO *)
\end{proof}
\end{thm}
\begin{cor}
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be
a sort. If $Σ ⊢ A : s$ and if $ρ$ is a valuation over $Σ$ then
$\vs("Aρ") ∈ ⟦s⟧$.
\begin{proof}
As $Σ ⊢ A : s$ and $ρ$ is a valuation over $Σ$ then we have
$⊢ \f("Aρ") : s$ by \lemRef("typeval"). As a consequence we
can use \thmRef("sortsem").
\end{proof}
\end{cor}

=<
=> Adequacy

(* TODO from here *)
\begin{def}
A valuation over a sorting context $Σ$ is a map $ρ$ such that $ρ(χ) ∈ ⟦Σ(χ)⟧$
for every $χ ∈ dom(Σ)$. In particular, this means that $dom(Σ) ⊆ dom(ρ)$.
\end{def}

(* Adequacy lemma. *)
\begin{thm}
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the typing
judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ (resp. $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$) is derivable
and if $ρ ⊩ Γ;Δ;Ξ$ then $\t("tρ") ∈ |\f("Aρ")|$ (resp.
$\t("vρ") ∈ ⟦\f("Aρ")⟧$).
\begin{proof}
We proceed by induction on the derivation of the judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$
or $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$, and we reason by case on the last used rule.
\begin{itemize}
\item In the case of the ($Ax$) rule, we immediately obtain
      $\t("xρ") = \t("ρ(x)") ∈ ⟦\f("Aρ")⟧$ by hypothesis.
      \begin{center}
        $ \axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)} $
      \end{center}
\item If the last used rule is ($↑$) then we need to show
      $\v("vρ") ∈ |\f("Aρ")|$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence we can conclude using
      \thmRef("orthosimple").
      \begin{center}
        $ \unaryRN{↑}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
           Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)} $
      \end{center}
\item If the last used rule is ($↓$) then we need to show
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ |\f("Aρ")|$, hence we can conclude using
      \thmRef("orthonew").
      \begin{center}
        $ \unaryRN{↓}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)} $
      \end{center}
\item If the last used rule is ($⇒_i$) then we need to show that
      $\t("(λx t)ρ") ∈ ⟦\f("(A ⇒ B)ρ")⟧$. Let us take $v ∈ ⟦\f("Aρ")⟧$ and
      show that $\t("(tρ)[x ≔ v]") ∈ |\f("Bρ")|$. We can then conclude by
      induction hypothesis using the valuation $\subs("ρ[x ≔ v]")$.
      \begin{center}
        $ \unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)} $
      \end{center}
\item If the last used rule is ($⇒_e$) then we need to show
      $\t("(t u)ρ") = \t("tρ uρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("tρ uρ ∗ π") ∈ \dbot$. Since
      $\p("tρ uρ ∗ π") ≻ \p("uρ ∗ [tρ]π")$ and $\dbot$ is saturated, is is
      enough to show $\p("uρ ∗ [tρ]π") ∈ \dbot$. By induction hypothesis,
      we know that $\t("uρ") ∈ |\f("Aρ")|$, hence it only remains to show
      $\s("[tρ]π") ∈ ||\f("Aρ")||$. Let us now take $\v("v") ∈ ⟦\f("Aρ")⟧$
      and show that $\p("v ∗ [tρ]π") ∈ \dbot$. Since
      $\p("v ∗ [tρ]π") ≻ \p("tρ ∗ v·π")$ and $\dbot$ is saturated, it is
      enough to show that $\p("tρ ∗ v·π") ∈  \dbot$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A ⇒ B)ρ")| = |\f("Aρ ⇒ Bρ")|$, hence it only remains
      to show $\s("v·π") ∈ ||\f("Aρ ⇒ Bρ")||$. Let us now take a value
      $\v("λx f") ∈ ⟦\f("Aρ ⇒ Bρ")⟧$ and show that $\p("λx f ∗ v·π") ∈ \dbot$.
      Since $\p("λx f ∗ v·π") ≻ \p("f[x ≔ v] ∗ π")$ and $\dbot$ is saturated,
      it is enough to show that $\p("f[x ≔ v] ∗ π") ∈ \dbot$. Since
      $\s("π") ∈ ||\f("Bρ")||$ it only remains to show that
      $\t("f[x ≔ v]") ∈ |\f("Bρ")|$. This is true by definition of
      $⟦\f("Aρ ⇒ Bρ")⟧$ since $\v("v") ∈ ⟦\f("Aρ")⟧$.
      \begin{center}
        $ \binaryRN{⇒_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)} $
      \end{center}
\item If the last used rule is ($μ$) then we need to show that
      $\t("(μα t)ρ") = \t("μα tρ") ∈ |\f("Aρ")|$. Let us take
      $π ∈ ||\f("Aρ")||$ and show $\p("μα tρ ∗ π") ∈ \dbot$. Since
      $\p("μα tρ ∗ π") ≻ \p("tρ[α ≔ π] ∗ π")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ[α ≔ π] ∗ π") ∈ \dbot$. We can then conclude
      by induction hypothesis using the valuation $\subs("ρ[α ≔ π]")$.
      \begin{center}
        $ \unaryRN{μ}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)} $
      \end{center}
\item If the last used rule is ($[\wc]$) then we need to show
      $\t("([α]t)ρ") = \t("[ρ(α)]tρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("[ρ(α)]tρ ∗ π") ∈ \dbot$. Since
      $\p("[ρ(α)]tρ ∗ π") ≻ \p("tρ ∗ ρ(α)")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ ∗ ρ(α)") ∈ \dbot$. By induction hypothesis,
      we know that $\t("tρ") ∈ \f("Aρ")$, hence we only need to show that
      $\s("ρ(α)") ∈ ||\f("Aρ")||$. This is true by hypothesis since we have
      $α ∈ dom(Σ, α:σ)$ and $Δ(α) = A$.
      \begin{center}
        $ \unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)} $
      \end{center}
\item If the last used rule is ($∀_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(∀χ^s A)ρ")⟧$. By definition we have
      $⟦\f("(∀χ^s A)ρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$,
      hence it is enough to take $\f("B") ∈ ⟦s⟧$ and show
      $\v("vρ") ∈ ⟦\f("Aρ[χ ≔ B]")⟧$. Note that $\v("vρ") = \v("vρ[χ ≔ B]")$
      as $\f("χ")$ cannot appear in $\v("v")$ for the conclusion judgment to
      be well-formed. We conclude by induction hypothesis with the
      valuation $\subs("ρ[χ ≔ B]")$.
      \begin{center}
        $ \unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))} $
      \end{center}
\item If the last used rule is ($∀_e$) then we need to show
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(∀χ^s A)ρ")|$, hence it is enough to show
      $|\f("(∀χ^s A)ρ")| ⊆ |\f("(A[χ ≔ B])ρ")|$, or
      $⟦\f("(∀χ^s A)ρ")⟧ ⊆ ⟦\f("(A[χ ≔ B])ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume that $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("∀χ^s Aρ")⟧ ⊆ ⟦\f("Aρ[χ ≔ Bρ]")⟧$. The
      inclusion follows since
      $⟦\f("∀χ^s Aρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∀_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))} $
      \end{center}
\item If the last used rule is ($∃_i$) then we need to show
      $\t("tρ") ∈ |\f("(∃χ^s A)ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$, hence it is enough to show
      $|\f("(A[χ ≔ B])ρ")| ⊆ |\f("(∃χ^s A)ρ")|$, or
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∃χ^s A)ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. Now,
      the inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_i}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))} $
      \end{center}
\item If the last used rule is ($∃_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("(A[χ ≔ B])ρ")⟧$ provided
      $\v("ρ(x)") ∈ ⟦\f("(∃χ^s A)ρ")⟧$. In other words, we need to show
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∀χ^s A)ρ")⟧$. Up to renaming, we can
      assume $χ ∉ dom(Σ)$, hence our goal rewrites to 
      $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. The inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))}{
          Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))} $
      \end{center}
\item If the last used rule is ($∈_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(v ∈ A)ρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence it is enough to show
      $⟦\f("(v∈A)ρ")⟧ ⊆ ⟦\f("Aρ")⟧$. This is immediate as
      $⟦\f("(v∈A)ρ")⟧ = ⟦\f("vρ∈Aρ")⟧ = \{w∈⟦\f("Aρ")⟧ \st w≡\v("vρ")\}$
      by definition.
      \begin{center}
        $ \unaryRN{∈_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))} $
      \end{center}
\item If the last used rule is ($∈_e$) then we need to show
      $\t("uρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("aρ")⟧$ and that
      $\v("ρ(x)")≡\t("tρ")$, provided that we have
      $\v("xρ") ∈ ⟦\f("(t∈A)ρ")⟧$. By definition
      $⟦\f("(t∈A)ρ")⟧ = ⟦\f("tρ∈Aρ")⟧ = \{v∈⟦\f("Aρ")⟧ \st v≡\t("tρ")\}$,
      and hence $\v("ρ(x)") ∈ ⟦\f("Aρ")⟧$ and $\v("ρ(x)")≡\t("tρ")$.
      \begin{center}
        $ \unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("u") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("u") : C)} $
      \end{center}
\item If the last used rule is ($↾_i$) then we need to show
      $\t("tρ") ∈ |\f("(A | u₁≡u₂)ρ")|$. By hypothesis, we know that
      $\t("u₁ρ") ≡ \t("u₂ρ")$, and hence
      $|\f("(A|u₁≡u₂)ρ")| = |\f("Aρ | u₁ρ ≡ u₂ρ")| = |\f("Aρ")|$. As a
      consequence, we can immediatly conclude by induction hypothesis.
      \begin{center}
        $ \unaryRN{↾_i}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : \f("A | u₁≡u₂"))} $
      \end{center}
\item If the last used rule is ($↾_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To be able to apply the induction hypothesis,
      we need to show that $ρ(x) ∈ ⟦\f("Aρ")⟧$ and $u₁ρ ≡ u₂ρ$ provided that
      $ρ(x) ∈ ⟦\f("(A | u₁ ≡ u₂)ρ")⟧ = ⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧ ≠ ∅$. This
      immediately follows from the definition of $⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧$
      since it is non-empty.
      \begin{center}
        $ \unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,u₁ ≡ u₂ ⊢ \t("t") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("A | u₁ ≡ u₂");Δ;Ξ ⊢ \t("t") : C)} $
      \end{center}
\item If the last used rule is ($×_i$) then we need to show
      $\v("{(li = vi) i∈I}ρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$. By definition it
      is enough to show that $\v("viρ") ∈ ⟦\f("Aiρ")⟧$ for all index $i$ in
      $I$. This exactly corresponds to the induction hypotheses.
      \begin{center}
        $ \unaryRN{×_i}{[Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))} $
      \end{center}
\item If the last used rule is ($×_e$) then we need to show that
      $\t("(v.lk)ρ") ∈ |\f("Akρ")|$. By induction hypothesis we know that
      $\v("vρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$, hence by definition
      $\v("vρ") = \v("{(li = vi) i∈I}")$ and for all index $i$ in $I$ we
      have $\v("vi") ∈ ⟦\f("Aiρ")⟧$. Let us now take $π ∈ ||\f("Akρ")||$ and
      show that $\p("{(li = vi) i∈I}.lk ∗ π") ∈ \dbot$. As $k$ is in $I$, we
      have $\p("{(li = viρ) i∈I}.lk ∗ π") ≻ \p("viρ ∗ π")$, hence it is enough
      to show $\p("vkρ ∗ π") ∈ \dbot$ as $\dbot$ is saturated. Since
      $π ∈ ||\f("Akρ")||$, we only have to show $\v("vkρ") ∈ |\f("Akρ")|$.
      We can hence conclude using \thmRef("orthosimple") since we know that
      $\v("vkρ") ∈ ⟦\f("Akρ")⟧$.
      \begin{center}
        $ \binaryRN{×_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))}{
          k∈I}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)} $
      \end{center}
\item If the last used rule is ($+_i$) then we need to show
      $\t("(Ck[v])ρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$. By definition we only need
      to show $\v("vρ") ∈ ⟦\f("Akρ")⟧$ since the index $k$ is in $I$. This is
      exactly the induction hypothesis.
      \begin{center}
        $ \binaryRN{+_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))}{k∈I}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]"))} $
      \end{center}
\item If the last used rule is ($+_e$) then we need to show
      $\t("[v | (Ci[xi] → ti) i∈I]ρ") ∈ |\f("Bρ")|$. By induction hypothesis
      we know that $\v("vρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$, hence by definition
      $\v("vρ") = \v("Ck[w]")$ for some index $k$ in $I$ and $w ∈ \f("Akρ")$.
      Let us now take a stack $π ∈ ||\f("Bρ")||$ and show that
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ∈ \dbot$. As
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ≻ \p("tkρ[xk≔w] ∗ π")$ and
      $\dbot$ is saturated, it is enough to show
      $\p("tkρ[xk≔w] ∗ π") ∈ \dbot$. Let us now consider the valuation
      $\subs("ρ[xk≔w]")$. Up to renaming, we can assume that $\v("xk")$ does
      not appear free in $\f("B")$, hence $\f("Bρ") = \f("Bρ[xi≔w]")$.
      Consequently we have $π ∈ ||\f("Bρ[xk≔w]")||$, hence it is enough to
      show that $\t("tkρ[xk≔w]") ∈ |\f("Bρ[xk≔w]")|$. We can conclude by
      induction hypothesis using the valuation $\subs("ρ[xk≔w]")$ since
      $\v("vρ[xk≔w]") ≡ \v("Ck[w]")$.
      \begin{center}
        $ \binaryRN{+_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))}{
          [Σ, x_i : ι ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)} $
      \end{center}
\item If the last used rule is ($≡_{l, {val}}$) then we need to show
      $\t("(t[x≔v₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $x ∉ dom(ρ)$, hence $\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$
      and $\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$. By hypothesis we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$, hence \thmRef("extvalue") gives us
      $\t("tρ[x≔v₁ρ]") ≡ \t("tρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[x≔v₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_{l, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_l$) then we need to show
      $\t("(t[a≔u₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $a ∉ dom(ρ)$, hence $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$
      and $\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$. By hypothesis we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$, hence \thmRef("extterm") gives us
      $\t("tρ[a≔u₁ρ]") ≡ \t("tρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[a≔u₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_l}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_{r, {val}}$) then we need to show
      $\t("tρ") ∈ |\f("(A[x≔v₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[x≔v₂])ρ")|$ so we will show
      $|\f("(A[x≔v₁])ρ")| = |\f("(A[x≔v₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[x≔v₁])ρ")⟧ = ⟦\f("(A[x≔v₂])ρ")⟧$.
      Without loss of generality we may assume that $x ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[x≔v₁ρ]")⟧ = ⟦\f("Aρ[x≔v₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformvalue") as we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_{r, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₁]"))} $
      \end{center}
\item If the last used rule is ($≡_r$) then we need to show
      $\t("tρ") ∈ |\f("(A[a≔u₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[a≔u₂])ρ")|$ so we will show
      $|\f("(A[a≔u₁])ρ")| = |\f("(A[a≔u₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[a≔u₁])ρ")⟧ = ⟦\f("(A[a≔u₂])ρ")⟧$.
      Without loss of generality we may assume that $a ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[a≔u₁ρ]")⟧ = ⟦\f("Aρ[a≔u₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformterm") as we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_r}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))} $
      \end{center}
\end{itemize}
\end{proof}
\end{thm}

=<
=> Derived rules for dependent types

\label("encodedep") (* FIXME why do I need to put the label here ???!!!! *)

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{Σ; {Γ, x:A}; Δ; Ξ ⊢ t : B}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : A ⇒ B}
\hspace(1.5)
\binaryRN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t : A ⇒ B}{Σ; Γ; Δ; Ξ ⊢ u : A}{
  Σ; Γ; Δ; Ξ ⊢ t u : B}
$$

(* The weak Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, x:ι_v}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{x ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, x:ι_v}; Γ; Δ; Ξ ⊢_\tval λx t : x∈A ⇒ B}{
   \unaryN{∈}{{Σ, x:ι_v}; {Γ, x:{x∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, x:ι_v}; {Γ, x:A}; Δ; {Ξ, x≡x} ⊢ t : B}{
     \hyp{{Σ, x:ι_v} ; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{x ∉ FV(Γ; Δ; Σ)}}
}
$$
(* The weak Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[x := v] ⇒ B[x := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[x := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[x := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]}
   }
  }
 }
}
$$

(* The Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{a ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, a:ι}; Γ; Δ; Ξ ⊢_\tval λx t : a∈A ⇒ B}{
   \unaryN{∈}{{Σ, a:ι}; {Γ, x:{a∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, a:ι}; {Γ, x:A}; Δ; {Ξ, x≡a} ⊢ t : B}{
     \hyp{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{a ∉ FV(Γ; Δ; Σ)}}
}
$$

(* The Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[a := v] ⇒ B[a := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[a := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[a := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]}
   }
  }
 }
}
$$
(* TODO *)

=<

=<
