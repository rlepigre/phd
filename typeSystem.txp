\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>
)
\Include{Macros}

\Configure_math_macro{\v}{ syntax = string; }
\Configure_math_macro{\t}{ syntax = string; }
\Configure_math_macro{\s}{ syntax = string; }
\Configure_math_macro{\p}{ syntax = string; }
\Configure_math_macro{\f}{ syntax = string; }
\Configure_math_macro{\vs}{ syntax = string; }
\Configure_math_macro{\ss}{ syntax = string; }
\Configure_math_macro{\ts}{ syntax = string; }

\Caml(
(* Figure for sorting rules. *)
let r11 =
  << $\unaryR{Σ, x : ι ⊢ \t{t} : τ}{Σ ⊢ \v{λx t} : ι}$ >>
let r12 =
  << $\unaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \v{C[v]} : ι}$ >>
let r13 =
  << $\unaryR{\{Σ ⊢ \v{vi} : ι\}_{i∈I}}{Σ ⊢ \v{{(li = vi) i∈I}} : ι}$ >>
let r14 =
  << $\axiomR{Σ ⊢ \v{□} : ι}$ >>
let r21 =
  << $\unaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \t{v} : τ}$ >>
let r22 =
  << $\binaryR{Σ ⊢ \t{t} : τ}{Σ ⊢ \t{u} : τ}{Σ ⊢ \t{t u} : τ}$ >>
let r23 =
  << $\unaryR{Σ, α : σ ⊢ \t{t} : τ}{Σ ⊢ \t{μα t} : τ}$ >>
let r31 =
  << $\binaryR{Σ ⊢ \s{π} : σ}{Σ ⊢ \t{t} : τ}{Σ ⊢ \t{[π]t} : τ}$ >>
let r32 =
  << $\unaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \t{v.l} : τ}$ >>
let r33 =
  << $\binaryR{Σ ⊢ v : ι}{\{Σ, x_i : ι ⊢ \t{ti} : τ\}_{i∈I}}{
       Σ ⊢ \t{[v | (Ci[xi] → ti) i∈I]} : τ}$ >>
let r41 =
  << $\binaryR{Σ ⊢ \t{t} : τ}{Σ ⊢ \v{v} : ι}{Σ ⊢ \t{Y(t,v)} : τ}$ >>
let r42 =
  << $\binaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \t{t} : τ}{Σ ⊢ \t{R(v,t)} : τ}$ >>
let r43 =
  << $\binaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \t{t} : τ}{Σ ⊢ \t{F(v,t)} : τ}$ >>
let r44 =
  << $\binaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \v{w} : ι}{Σ ⊢ \t{δ(v,w)} : τ}$ >>
let r51 =
  << $\axiomR{Σ ⊢ \s{ε} : σ}$ >>
let r52 =
  << $\binaryR{Σ ⊢ \v{v} : ι}{Σ ⊢ \s{π} : σ}{Σ ⊢ \s{v · π} : σ}$ >>
let r53 =
  << $\binaryR{Σ ⊢ \t{t} : τ}{Σ ⊢ \s{π} : σ}{Σ ⊢ \s{[t] π} : σ}$ >>
let r61 =
  << $\axiomR{Σ, χ : s ⊢ χ : s}$ >>
let r62 =
  << $\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f{(χ^s ↦ A)} : s → r}$ >>
let r63 =
  << $\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f{A(B)} : r}$ >>
let r71 =
  << $\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f{A ⇒ B} : ο}$ >>
let r72 =
  << $\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f{{(li : Ai) i∈I}} : ο}$ >>
let r73 =
  << $\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f{[(Ci : Ai) i∈I]} : ο}$ >>
let r81 =
  << $\unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f{∀χ^s A} : ο}$ >>
let r82 =
  << $\unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f{∃χ^s A} : ο}$ >>
let r83 =
  << $\binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f{t∈A} : ο}$ >>
let r91 =
  << $\ternaryR{Σ ⊢ A : ο}{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f{A ∧ t≡u} : ο}$ >>

let rs env =
  (* let env = resize_env 3.4 env in *)
  let rs =
    [ [ r11 ; r12 ; r13 ] ; [ r14 ; r21 ; r22 ] ; [ r23 ; r31 ; r32 ]
    ; [ r33 ; r41 ; r42 ] ; [ r43 ; r44 ; r51 ] ; [ r52 ; r53 ; r61 ]
    ; [ r62 ; r63 ; r71 ] ; [ r72 ; r73 ; r81 ] ; [ r82 ; r91 ; r83 ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let sortrules () =
  figure_here ~name:"sortrules" ~caption:[tT "Sorting rules."] (dr rs)

(* Figure for typing rules. *)
let r_ax =
  <$\axiomRN{Ax}{Σ, x:ι \sp Γ, x:A; Ξ ⊢_\tval \t{x} : A}$>

let r_up =
  <$\unaryRN{↑}{Σ \sp Γ;Ξ ⊢_\tval \v{v} : A}
   {Σ \sp Γ;Ξ ⊢ \t{v} : A}$>

let r_arrow_i =
  <$\unaryRN{⇒_i}{Σ, x:ι \sp Γ,x:A;Ξ ⊢ \t{t} : B}
   {Σ \sp Γ;Ξ ⊢_\tval \v{λx t} : A ⇒ B}$>

let r_arrow_e =
  <$\binaryRN{⇒_e}{Σ \sp Γ;Ξ ⊢ \t{t} : A ⇒ B}{Σ \sp Γ;Ξ ⊢ \t{u} : A}
   {Σ \sp Γ;Ξ ⊢ \t{t u} : B}$>

let r_mu =
  <$\unaryRN{μ}{Σ, α:σ \sp Γ,α:A^⊥;Ξ ⊢ \t{t} : A}
   {Σ \sp Γ;Ξ ⊢ \t{μα t} : A}$>

let r_name =
  <$\unaryRN{[\wc]}{Σ, α:σ \sp Γ,α:A;Ξ ⊢ \t{t} : A}
   {Σ, α:σ \sp Γ,α:A;Ξ ⊢ \t{[α]t} : B}$>

let r_forall_i =
  <$\unaryRN{∀_i}{Σ, χ:s \sp Γ;Ξ ⊢_\tval \v{v} : A}
   {Σ \sp Γ;Ξ ⊢_\tval \v{v} : \f{∀χ^s A}}$>

let r_forall_e =
  <$\binaryRN{∀_e}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{∀χ^s A}}{Σ ⊢ B : s}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{A[χ ≔ B]}}$>

let r_exists_i =
  <$\binaryRN{∃_i}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{A[χ≔B]}}{Σ ⊢ B : s}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{∃χ^s A}}$>

let r_exists_e =
  <$\binaryRN{∃_e}{Σ, x:ι \sp Γ,x:\f{A[χ≔B]};Ξ ⊢ \t{t} : \f{C}}
   {Σ ⊢ B : s}{Σ, x:ι \sp Γ,x:\f{∃χ^s A};Ξ ⊢ \t{t} : \f{C}}$>

let r_memb_i =
  <$\unaryRN{∈_i}{Σ \sp Γ;Ξ ⊢_\tval \v{v} : A}
   {Σ \sp Γ;Ξ ⊢_\tval \v{v} : \f{v∈A}}$>

let r_memb_e =
  <$\unaryRN{∈_e}{Σ, x:ι \sp Γ,x:A;Ξ,x≡t ⊢ \t{u} : C}
   {Σ, x:ι \sp Γ,x:\f{t∈A};Ξ ⊢ \t{u} : C}$>

let r_rest_i =
  <$\binaryRN{↾_i}{Σ \sp Γ;Ξ ⊢ \t{t} : A}{Ξ ⊢ \t{u₁} ≡ \t{u₂}}
   {Σ \sp Γ;Ξ ⊢ \t{t} : \f{A ∧ u₁≡u₂}}$>

let r_rest_e =
  <$\unaryRN{↾_e}{Σ, x:ι \sp Γ,x:A;Ξ,\t{u₁}≡\t{u₂} ⊢ \t{t} : C}
   {Σ, x:ι \sp Γ,x:\f{A ∧ u₁≡u₂};Ξ ⊢ \t{t} : C}$>

let r_prod_i =
  <$\unaryRN{×_i}{[Σ \sp Γ;Ξ ⊢_\tval \v{vi} : \f{Ai}]_{i∈I}}
   {Σ \sp Γ;Ξ ⊢_\tval \v{{(li = vi) i∈I}} : \f{{(li : Ai) i∈I}}}$>

let r_prod_e =
  <$\binaryRN{×_e}{Σ \sp Γ;Ξ ⊢_\tval \v{v} : \f{{(li : Ai) i∈I}}}
   {k∈I}{Σ \sp Γ;Ξ ⊢ \t{v.lk} : A_k}$>

let r_sum_i =
  <$\binaryRN{+_i}{Σ \sp Γ;Ξ ⊢_\tval \v{v} : \f{Ak}}{k∈I}
   {Σ \sp Γ;Ξ ⊢_\tval \v{Ck[v]} : \f{[(Ci : Ai) i∈I]}}$>

let r_sum_e =
  <$\binaryRN{+_e}{Σ \sp Γ;Ξ ⊢_\tval \v{v} : \f{[(Ci : Ai) i∈I]}}
   {[Σ, x_i:ι \sp Γ,x_i:A_i;Ξ,v≡\t{Ci[xi]} ⊢ t_i : B]_{i∈I}}
   {Σ \sp Γ;Ξ ⊢ \t{[v | (Ci[xi] → ti) i∈I]} : B}$>

let r_eq_ti =
  <$\binaryRN{≡_{τ,ι}}{Σ \sp Γ[x≔w₁];Ξ ⊢ \t{t[x≔w₁]} : \f{A[x≔w₁]}}
   {Ξ ⊢ \v{w₁} ≡ \v{w₂}}
   {Σ \sp Γ[x≔w₂];Ξ ⊢ \t{t[x≔w₂]} : \f{A[x≔w₂]}}$>

let r_eq_ii =
  <$\binaryRN{≡_{ι,ι}}{Σ \sp Γ[x≔w₁];Ξ ⊢_\tval \v{v[x≔w₁]} : \f{A[x≔w₁]}}
   {Ξ ⊢ \v{w₁} ≡ \v{w₂}}
   {Σ \sp Γ[x≔w₂];Ξ ⊢_\tval \v{v[x≔w₂]} : \f{A[x≔w₂]}}$>

let r_eq_tt =
  <$\binaryRN{≡_{τ,τ}}{Σ \sp Γ[a≔u₁];Ξ ⊢ \t{t[a≔u₁]} : \f{A[a≔u₁]}}
   {Ξ ⊢ \t{u₁} ≡ \t{u₂}}
   {Σ \sp Γ[a≔u₂];Ξ ⊢ \t{t[a≔u₂]} : \f{A[a≔u₂]}}$>

let r_eq_it =
  <$\binaryRN{≡_{ι,τ}}{Σ \sp Γ[a≔u₁];Ξ ⊢_\tval \v{v[a≔u₁]} : \f{A[a≔u₁]}}
   {Ξ ⊢ \t{u₁} ≡ \t{u₂}}
   {Σ \sp Γ[a≔u₂];Ξ ⊢_\tval \v{v[a≔u₂]} : \f{A[a≔u₂]}}$>

let rs env =
  let env = resize_env 3.2 env in
  let rs =
    [ [r_ax;r_arrow_i] ; [r_up;r_arrow_e] ; [r_mu;r_name]
    ; [r_forall_i;r_exists_e] ; [r_forall_e;r_exists_i] ; [r_memb_e;r_rest_i]
    ; [r_memb_i;r_rest_e] ; [r_prod_e;r_sum_i] ; [r_prod_i] ; [r_sum_e]
    ; [r_eq_ii] ; [r_eq_ti] ; [r_eq_it] ; [r_eq_tt] ]
  in
  let rs = List.map (List.map (fun cs -> <<$\id(cs)$>>)) rs in
  List.map (List.map (fun cs ->
    draw_boxes env (boxify_scoped env cs))) rs

let typrules () =
  figure_here ~name:"typerules" ~caption:[tT "Typing rules."] (dr rs)
)

=> Types and realisability semantics \label("typeSystem")

In this chapter, we present a new type system which distinguishing feature
is an embedded notion of program equivalence. It enables the specification
of equational properties over programs, which can then be proved using
equational reasoning. Our types are interpreted using standard classical
realisability techniques, which allows for a semantical justification of
our typing rules.

=> Observational equivalence type

One of the main goals of this thesis is to build a type system that can be
used to reason about programs. To achieve this goal, we need to be able to
specify program behaviours using types. We hence introduce equality types
of the form $\f{t ≡ u}$, where $t$ and $u$ are (possibly untyped) terms.
Note that here, the equivalence symbol is part of the syntax and does not
refer to a specific equivalence relation.
(* *)
An equivalence relation $({≡})$ will however be used for the semantical
interpretation of equality types. We will require that it is extensional
and compatible with $({≡}_{≻})$, but it will remain otherwise unspecified.
In other words, it will be considered as a parameter of our type system
and semantics.

Intuitively, an equality type $\f{t≡u}$ will be interpreted as $⊤$
(i.e. logical truth or the biggest type) if the equivalence $t ≡ u$ holds,
and as $⊥$ (i.e. logical absurdity or the empty type) otherwise. For
example, the type $\f{(λx x) λx x ≡ λx x}$ will be inhabited as we have
$\t{(λx x) λx x} ≡ \t{λx x}$ according to \thmRef("cbvbeta"). However,
the type $\f{λx x ≡ {}}$ will be empty as $\t{λx x} \nequiv \t{{}}$
according to \thmRef("nequivlamreco"). Of course, a compatible equivalence
relation is likely to be undecidable. Indeed, such equivalence relations
are similar to $({≡}_{≻})$, which is itself undecidable.
\begin{thm}
Given $t$, $u ∈ Λ$ it is undecidable whether $t ≡_{≻} u$ or
$t \nequiv_{≻} u$.
\begin{proof}
We are going to encode the halting problem $H_t$ using equivalence. In
our system, $H_t$ can be stated as ${\p{t ∗ ε}} {⇓}_{≻}$ for any closed
term $\t{t} ∈ Λ^{∗}$. Let us consider a closed term $Ω ∈ Λ^{∗}$ such
that ${\p{Ω∗π}} {⇑}_{≻}$ for all $π ∈ Π$. For example, we can take
$Ω = \t{(λx x x) λx x x}$ as $\p{Ω∗π}$ is non-terminating for all $π∈Π$
since $\p{Ω∗π} ≻^3 \p{Ω∗π}$. We will now show that $H_t$
is equivalent to ${\t{[ε]t} \nequiv_{≻} \t{Ω}}$. Let us suppose $H_t$ and
show ${\t{[ε]t} \nequiv_{≻} \t{Ω}}$. We need to find a stack $π ∈ Π$ such
that ${\p{[ε]t ∗ π}} {⇓}_{≻}$ and ${\p{Ω ∗ π}} {⇑}_{≻}$. This is in fact
true for all $π$ as ${\p{Ω ∗ π}} {⇑}_{≻}$ by hypothesis and
${\p{[ε]t ∗ π}} ≻ {\p{t ∗ ε}} {⇓}_{≻}$ since we supposed $H_t$. We now
suppose ${\t{[ε]t} \nequiv_{≻} \t{Ω}}$ and show $H_t$. By definition,
there must be a stack $\s{π₀} ∈ Π$ such that ${\p{[ε]t ∗ π₀}} {⇓}_{≻}$
since ${\p{Ω ∗ π}} {⇑}_{≻}$ for all $π ∈ Π$. Now since we have
${\p{[ε]t ∗ π₀}} ≻ {\p{t ∗ ε}}$ we obtain $H_t$.
\end{proof}
\end{thm}
As a consequence, we cannot hope to decide, in general, whether an
equivalence holds or not. We will hence need to rely on a partial decision
procedure that will only approximate our observational equivalence relation.

In the system, proving a program equivalence amounts to showing that the
corresponding equality type is inhabited. However, an equivalence type
may also be used as an assumption. For example, it is possible to define
a function which input type is an equivalence. As a consequence, we need
a form of context to store the set of program equivalences that are
assumed to be true during a proof.
\begin{def}
An equational context $Ξ ⊆ \cal{P}(Λ × Λ)$ is a finite set of couples
of terms denoting hypothetical equivalences. For convenience, equational
contexts we will represented using lists generated using the following
||bnf|| grammar.
\Caml(let _ = sidenote << $Ξ ::= ∅ \| {Ξ, t ≡ u}$ >> << $t,u ∈ Λ$ >>)
\end{def}

During the construction of a proof, the equational context grows with new
hypotheses and equivalences need to be proved eventually. As mentioned
previously, we rely on a partial decision procedure that is supposed
correct, but remains otherwise unspecified. The implementation of such a
decision procedure is discussed in \chapter("implem"). Although we cannot
hope for completeness, we will argue that our implementation is a good
enough approximation in practice.
\begin{def}
Given an equational context $Ξ$ and a substitution $ρ$, we say that $ρ$
//realises// $Ξ$ and we write $ρ ⊩ Ξ$ if for every $(t,u) ∈ Ξ$ we have
$\t{tρ} ≡ \t{uρ}$.
\end{def}
\begin{def}
Let $Ξ$ be an equational context and $t ∈ Λ$ and $u ∈ Λ$ be two terms. We
write $Ξ ⊢ t ≡ u$ if our (yet unspecified) decision procedure is able to
show that for every substitution $ρ$ such that $ρ ⊩ Ξ$ we have
$\t{tρ} ≡ \t{uρ}$.
\end{def}

=<
=> Quantification and membership type

Although equality types can be used to derive simple equational properties,
their use is rather limited without a form of quantification. Indeed, they
only allow the derivation of static equivalences like $\t{(λx x) {}} ≡
\t{{}}$, but they cannot be used to show more general properties like
"$\t{(λx x) v} ≡ \t{v}$ for every value $v$".
(* *)
Terms can contain free variables of several sorts: $λ$-variables (i.e. value
variables), term variables and $μ$-variables (i.e. stack variables). As open
terms may appear in types, and in particular in equality types, it is natural
to allow universal and existential quantification over all three sorts of
variables. This will enables the specification of properties such as
$\f{∀y (λx x) y ≡ y}$ or $\f{∀x ∀y x ≡ y ⇒ C[x] ≡ C[y]}$ inside the
system.
\begin{rem}
The forms of quantification described here range over all (closed) value,
terms or stacks regardless of their types.
\end{rem}
\begin{rem}
It is not clear whether quantification over stacks has a practical use. We
only include it as it fits well in the framework with no extra cost.
\end{rem}

Quantifying over all the (closed) values or terms is not always enough.
Indeed, we often need to quantify over the values or the terms of a given
type only. For example if we quantify over a $λ$-variable that is used in
a case analysis, then a runtime error will be produced for values that do
not correspond to matched constructors. This would not happen when
quantifying over value of the appropriate sum type only.

To achieve typed quantification we introduce a membership type constructor
$\f{t ∈ A}$ where $t$ is a term and $A$ is a type. The elements of
$\f{t∈A}$ are those of $A$ that are equivalent to $t$. In particular,
$\f{t ∈ A}$ is empty if $t$ does not have type $A$. Intuitively,
$\f{t∈A}$ can be read as the proposition "$t$ has type $A$", but we will
see later that a more appropriate interpretation would be
"$t$ realises $A$". Using membership, we can use the well-known relativised
quantification scheme to obtain a dependent function type.
$$ \f{Π_(x∈A) B} ≔ \f{∀x (x∈A ⇒ B)} $$
The dependent function type exactly correspond to typed quantification as
its elements can only be applied to values of type $A$. Other values are
simply filtered out.
(* *)
Note that we can define a dependent pair type using existential
quantification as follows.
$$ \f{Σ_(x∈A) B} ≔ \f{∃x {l₁ : x∈A ; l₂ : B}} $$
(* *)
We can also define the same kind of type constructors by quantifying over
term variables in the exact same way.
$$
  \f{Π_(a∈A) B} ≔ \f{∀a (a∈A ⇒ B)}
  \hspace(4.0)
  \f{Σ_(a∈A) B} ≔ \f{∃a {l₁ : a∈A ; l₂ : B}}
$$
\begin{rem}
Nothing prevents the variable that is quantified over to appear in $A$.
However, it is not clear whether that is useful in practice.
\end{rem}

=<
=> Sorts and higher-order types

Our type system allows universal and existential quantification over
several sorts of objects. There are first order quantifiers ranging over
values, terms and stack, as shown in the previous section. And the system
also provides second order quantification (i.e. quantification over types),
which corresponds to System F polymorphism and type abstraction. All of
these different forms of quantifiers are handled uniformly in the syntax
and in the semantics thanks to a higher-order formulation.

The higher-order features of the system allow us to define (and quantify
over) types with parameters of any sort. For example, we can define a type
parametrised by another type and a term. This leads to a system in which
it is syntactically correct to use a (not fully applied) parametric type,
or even a term, as a proposition. This does not make sense, and hence we
must make sure that this does not happen. The usual approach to tackle this
problem is to assign a form of type (called sort) to the types themselves.
This will give use the guarantee that our types are "well-formed".
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote << $s,r ::= κ \| {s→r}$ >> << $κ∈\cal{S}₀$ >>)
\end{def}

The language of sorts only contains constants and an arrow constructor for
functions. Our "sort system" will in fact be very similar to the simply
typed $λ$-calculus. In particular, the syntax of our types will contain a
constructor for building functions (i.e. $λ$-abstraction) and a corresponding
constructor for application.
\begin{def}
We require a countable set $\cal{V}_ο = \{X, Y, Z...\}$ of propositional
variables that does not intersect with $\cal{V}_ι$, $\cal{V}_τ$ and
$\cal{V}_σ$.
\end{def}
\begin{def}
We require a countable set of variables $\cal{V} = \{χ, ξ, φ...\}$ such that
for every atomic sort $s ∈ \cal{S}₀$ we have $\cal{V}_s ⊆ \cal{V}$. Given a
variable $χ∈\cal{V}$, we will sometimes write $χ^s$ to mean that $χ$ is to
be considered as a variable of sort $s$. In particular, variables in
$\cal{V}_s$ with $s ∈ \cal{S}₀$ will always be considered as variables of
sort $s$.
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is built from $\cal{V}$, $Λ_ι$,
$Λ$ and $Π$ using the following ||bnf|| grammar.
\begin{center}
\Caml(
let _ = large_bnfs
  [ ( << $(\cal{F})$ >>
    , << $A, B$ >>
    , << $v \| t \| π \| \f{χ^s} \| \f{(χ^s ↦ A)} \| \f{A(B)} \|
          \f{A⇒B} \| \f{t∈A} \| \f{A∧t≡u} \| \f{{(li : Ai) i∈I}}$ >> )
  ; ( []
    , []
    , << $\id([]) \| \f{[(Ci : Ai) i∈I]} \| \f{∀χ^s A} \|
         \f{∃χ^s A}$ >> ) ]

)
\end{center}
\end{def}
Our types contain values, terms and stacks, as they will correspond to
types of sort $ι$, $τ$ and $σ$. We then have variables of all sorts,
abstraction to build types with an arrow sort and application. All the
remaining constructors are used to build propositions (i.e. actual
formulas) which will be given sort $ο$. Note that the quantifiers may
range over types of any sort. They are hence very general.
\begin{rem}
The variable constructor in the syntax of types is somewhat redundant for
values, terms and stacks. Indeed, these syntactic entities already provide
variables.
\end{rem}

To track the sort of variables in types we need to introduce a form of
context. It can then be used to define our notion of well-formed type
using a deduction rule system. We will then only consider types that can
be show well-formed in this system.
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, we will represent
sorting contexts using comma-separated lists of sort assignments generated
by the following ||bnf|| grammar.
\Caml(let _ = sidenote << $Σ ::= ∅ \| {Σ, χ : s}$ >>
  << $χ ∈ \cal{V}, s ∈ \cal{S} $ >>)
\end{def}
\begin{def}
A sorting judgment is a triple of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the deduction rules of
\figRef("sortrules").
\end{def}

The main role of the sorting rules is to keep track of the sort of the free
variables. The rules on the first five lines of \figRef("sortrules") simply
traverse the structure of values, terms and stacks to save the sort of the
free variables in the context. Note that the first rule on the sixth line is
also used for value, term and stack variables.

As an example $\f{λx x ⇒ {}}$ is not well-formed as the type at the left
of the arrow does not have sort $ο$ (it has sort $ι$ or $τ$). However,
$\f{(X ↦ [C₀:{} | C₁ : X])([C₂:{} | C₃:{}])}$ is a well-formed type of
sort $ο$, as shown by the following proof tree.
$$
  \proofTree{
    \binary{⊢ \f{(X ↦ [C₀ : {} | C₁ : X])([C₂ : {} | C₃ : {}])} : ο}{
      \unary{⊢ \f{(X ↦ [C₀ : {} | C₁ : X])} : ο → ο}{
        \binary{X : ο ⊢ \f{[C₀ : {} | C₁ : X]} : ο}{
          \axiom{X : ο ⊢ \f{{}} : ο}
        }{
          \axiom{X : ο ⊢ \f{X} : ο}
        }
      }
    }{
      \binary{⊢ \f{([C₂ : {} | C₃ : {}])} : ο}{
        \axiom{⊢ \f{{}} : ο}
      }{
        \axiom{⊢ \f{{}} : ο}
      }
    }
  }
$$

\Caml(let _ = sortrules ())\linesAfter(1)

As types contain the $λ$-calculus, we need to consider their reduction and
normalisation. First we define the notion of $β$-reduction in a type.
\begin{def}
We call a //redex// a type of the form $\f{(χ^s ↦ A)(B)}$, and we say that
a type is in normal form if it does not contain any redex. The reduction
relation over types is the smallest relation $({\inj}) ⊆ \cal{F} × \cal{F}$
such that:
\begin{itemize}
\item for every redex $\f{(χ^s ↦ A)(B)}$ we have
      $\f{(χ^s ↦ A)(B)} \inj \f{A[χ≔B]}$ and
\item $({\inj})$ is contextually closed (i.e. reduction considers all the
      redexes in a type).
\end{itemize}
We denote $({\inj}^{∗})$ its reflexive and transitive closure.
\end{def}

\begin{thm}
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$
be a sort. If the sorting judgment $Σ ⊢ A : s$ is valid, then there
is a unique type $B∈\cal{F}$ such that $B$ is in normal form,
$A \inj^{∗} B$ and the sorting judgment $Σ ⊢ B : s$ is valid.
\begin{proof}
Our language of types can be seen as an instance of the simply typed
$λ$-calculus extended with countably many constants. For instance, a
type of the form $\f{∀χ^s A}$ can be encoded using a constant ${∀}$
of sort $(s→ο)→ο$. Note that an infinite number of constants is
required to encode product types, sum types, records and pattern
matchings as they can be indexed by any finite subset of $\bbN$. As a
consequence, the theorem follows from well-known properties of the
simply typed $λ$-calculus with the subtyping relation induced by the
axiom $ι ≤ τ$ on base types (see, e.g., \mcite(["Mitchell1996"])).
\end{proof}
\end{thm}
In the following sections, we will always consider well-formed types. As a
consequence, we may also assume that a type is in normal form as we can
alway normalise well-formed types according to the previous theorem.

=<
=> Typing judgments for values and terms

As our language is call-by-value and has operations generating side-effects,
we need to be careful to achieve type-safety. In particular, some of our
typing rules will not apply to terms, but only to values (as mentioned in
\chapter("intro")). Here, value restriction will be encoded using two forms
of judgments: usual typing judgments ranging over terms (including values),
and a restricted form of judgments ranging over values only.

To be able to assign types to terms containing free $λ$-variables and free
$μ$-variables, we need our typing judgments to carry a form of context.
\begin{def}
A //typing context// is a finite map $Γ$ over $\cal{V}_ι ∪ \cal{V}_σ$ such
that $Γ(x) ∈ \cal{F}$ for all $x ∈ dom(Γ) ∩ \cal{V}_ι$ and $Γ(α) ∈ \cal{F}$
for all $α ∈ dom(Γ) ∩ \cal{V}_σ$. For convenience, we will represent typing
contexts using comma-separated lists of type assignments generated by the
following ||bnf|| grammar. Note that variables can only be mapped once in
a context, the order in which they appear is thus irrelevant.
\Caml(let _ = sidenote << $Γ ::= ∅ \| {Γ, x : A} \| {Γ, α : A^⊥}$ >>
  << $x ∈ \cal{V}_ι, α ∈ \cal{V}_τ, A ∈ \cal{F} $ >>)
\end{def}

The full context of typing judgments will be built using a typing context
and an equational context. As these contexts may contain types and hence
free variables, we need to define a notions of well-formedness for these
two forms of contexts.
\begin{def}
Given a sorting context $Σ$, we say that a typing context $Γ$ is well-formed
and write $Σ ⊢ Γ$ if for all $x ∈ dom(Γ) ∩ \cal{V}_ι$ we have $Σ ⊢ Γ(x) : ο$
and $Σ ⊢ x : ι$, and for all $α ∈ dom(Δ) ∩ \cal{V}_σ$ we have $Σ ⊢ Γ(α) : ο$
and $Σ ⊢ α : σ$.
\end{def}
\begin{def}
Given a sorting context $Σ$, we say that an equational context $Ξ$ is
well-formed and write $Σ ⊢ Ξ$ if for all $(t,u) ∈ Σ$ we have
$Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{def}

Using our three forms of contexts, we can now define our actual judgments.
Again, a notion of well-formedness need to be considered as our judgments
contain objects of different sorts, which all need to be well-formed.
\begin{def}
A value judgement is a tuple of a typing context $Γ$, an equational
context $Ξ$, a value $v ∈ Λ_ι$ and a type $A ∈ \cal{F}$ that is
denoted $Γ; Ξ ⊢_\tval v : A$. We say that such a judgment is well-formed
under the sorting context $Σ$, and we write $Σ \sp Γ; Ξ ⊢_\tval v : A$,
if and only if we have $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ v : ι$ and $Σ ⊢ A : ο$.
\end{def}
\begin{def}
A term judgement is a tuple of a typing context $Γ$, an equational
context $Ξ$, a term $t ∈ Λ$ and a type $A ∈ \cal{F}$ that is denoted
$Γ; Ξ ⊢ t : A; Δ$. We say that such a judgment is well-formed under
the sorting context $Σ$, and we write $Σ \sp Γ; Ξ ⊢ t : A$, if and
only if we have $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ t : τ$ and $Σ ⊢ A : ο$.
\end{def}

We can now give the typing rules of our system, which will involve
both value and term judgments. Moreover, some of our rules have a
premise of the form $Ξ ⊢ t ≡ u$. They can only be applied if our
(yet unspecified) equivalence decision procedure is successful in
proving that $t$ is equivalent to $u$ in the equational context
$Ξ$ (see the first section of this chapter).
\begin{def}
A value or term judgment is said to be valid if it can be derived using the
typing rules of \figRef("typerules").
\end{def}
The typing rules of our system, and hence our typing derivations, only
involve well-formed judgments. In particular, a typing rule can only be
applied if all the involved judgments are well-formed.
\begin{rem}
Note that the $∀_i$ rule cannot apply if the variable $χ$ appears in the
contexts $Γ$ and $Ξ$ nor in $t$. This would prevent the conclusion
judgment to be well-formed.
\end{rem}

As our system is call-by-value and has effect, the $∀_i$ rule needs value
restriction to remain sound. In our formalism, this means that the $∀_i$
rule applies to value judgments. The $∈_i$ rule requires value restriction
as well, as otherwise the system cannot be proved sound. As the $∈_i$ rule
will be involved in the derivation of the typing rule for the elimination
of the dependent function type at the begining of \chapter("semValRest"),
the latter will also need value restriction.

=<
=> Call-by-value realisability semantics

The abstract machine presented in \chapter("calculus") is part of a
//classical realisability// machinery that will be built upon here.
We aim at obtaining a semantical interpretation of our higher-order
type system. In particular, a proposition (i.e. a type of sort $ο$)
will be interpreted by three sets: a set of values, a set of stacks
and a set of terms. As always in classical realisability, the model
is parametrised by a pole, which serves as an exchange point between
the world of programs and the world of execution contexts, encoded
as stacks.
\begin{def}
Given a reduction relation $R ⊆ (Λ×Π) × (Λ×Π)$, a //pole// is a set
of processes $\dbot ⊆ Λ×Π$ which is //$R$-saturated// (i.e. closed
under backward reduction). More formally, if we have $q ∈ \dbot$ and
$p R q$ then $p ∈ \dbot$.
\end{def}
It is important to note that in the remaining of this chapter, we
will consider, if not otherwise specified, a fixed (but arbitrary)
pole $\dbot$.

The notion of //orthogonality// is central in Krivine's classical
realisability. In this framework a type is interpreted (or realised) by
programs computing corresponding values. This interpretation is spread
in a three-layered construction, even though it is fully determined by
the first layer and the choice of the pole. The first layer consists of
a set of values that we will call the //raw semantics//. It gathers all
the syntactic values that should be considered as having the corresponding
type. As an example, if we were to consider the type of natural numbers,
its raw semantics would be the set $\{\hat{n} \| n ∈ \bbN\}$ where
$\hat{n}$ is some encoding of $n$.
(* *)
The second layer, called //falsity value//, is a set containing every
closed stack that is a candidate for building a valid process using any
value from the raw semantics. The notion of validity depends on the
choice of the pole. The third layer, called //truth value// is a set of
closed terms that is built by iterating the process once more. The
formalism for the two levels of orthogonality is given in the following
definitions. Recall that $Λ_ι^{∗}$, $Λ^{∗}$ and $Π^{∗}$ denote the set
of closed values, closed terms and closed stacks respectively.
\begin{def}\label("orthodef1")
For every set $Φ ⊆ Λ_ι^{∗}$ we define a set $Φ^⊥ ⊆ Π^{∗}$ as follows.
$$ Φ^⊥ = \{π∈Π^{∗} \| ∀v∈Φ, \p{v ∗ π} ∈ \dbot\} $$
\end{def}
\begin{def}\label("orthodef2")
For every set $Ψ ⊆ Π^{∗}$ we define a set $Ψ^⊥ ⊆ Λ^{∗}$ as follows.
$$ Ψ^⊥ = \{t∈Λ^{∗} \| ∀π∈Ψ, \p{t ∗ π} ∈ \dbot\} $$
\end{def}
\Caml(let _ = typrules ()) (* NOTE can be moved *)
\begin{rem}
In the usual presentation of Krivine's classical realisability, the
interpretation of types can contain open values, terms and stacks.
Here, we need to restrict ourselves to closed objects for our model
to be compatible with our notion of equivalence.
\end{rem}

We now give several general properties of orthogonality, which hold in
every call-by-value classical realisability model. They will be useful
when proving the soundness of our type system.
\begin{lem}\label("orthosimple")
If $Φ ⊆ Λ_ι^{∗}$ is a set of values, then $Φ ⊆ Φ^{⊥⊥}$.
\begin{proof}
We take $v ∈ Φ$ and show $v ∈ Φ^{⊥⊥}$. By definition we need to
show $\p{v∗π} ∈ \dbot$ for all stack $π ∈ Φ^⊥$. This is immediate
by definition of $Φ^⊥$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclstack")
Let $Φ$, $Ψ ⊆ Λ_ι^{∗}$ be sets of closed values. If $Φ ⊆ Ψ$ then
$Ψ^⊥ ⊆ Φ^⊥$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$, take $π ∈ Ψ^⊥$ and show that $π ∈ Φ^⊥$.
By definition, we know that for all $v ∈ Ψ$ we have $\p{v ∗ π} ∈ \dbot$.
Since $Φ ⊆ Ψ$, this is also true for all $v ∈ Φ$, and hence $π ∈ Φ^⊥$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclterm")
Let $Φ$, $Ψ ⊆ Λ_ι^{∗}$ be sets of closed values. If $Ψ^⊥ ⊆ Φ^⊥$ then
$Φ^{⊥⊥} ⊆ Ψ^{⊥⊥}$.
\begin{proof}
Let us suppose that $Ψ^⊥ ⊆ Φ^⊥$, take $t ∈ Φ^{⊥⊥}$ and show that
$t ∈ Ψ^{⊥⊥}$. By definition, we know that for all $π ∈ Φ^⊥$ we have
$\p{t ∗ π} ∈ \dbot$. Since $Ψ^⊥ ⊆ Φ^⊥$, this is also true for all
$π ∈ Ψ^⊥$, and hence $t ∈ Ψ^{⊥⊥}$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoincl")
Let $Φ$, $Ψ ⊆ Λ_ι^{∗}$ be sets of closed values. If $Φ ⊆ Ψ$ then
$Φ^{⊥⊥} ⊆ Ψ^{⊥⊥}$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$ and apply \lemRef("orthoinclstack") to obtain
$Ψ^⊥ ∈ Φ^⊥$. We can then conclude using \lemRef("orthoinclterm").
\end{proof}
\end{lem}

When choosing a pole, it is important to check that it does not yield a
degenerate model. In particular we need to check that no term is able to
face every stacks. If it were the case, such a term could be used as a
proof of $⊥$.
\begin{def}
A pole $\dbot ⊆ Λ×Π$ is said to be consistent if for every closed term
$t ∈ Λ$ there is a stack $π$ such that $\p{t ∗ π} ∉ \dbot$.
\end{def}

In this thesis, another property will be required of our poles. As we
are in the presence of an equivalence relation over terms, we will need
our poles to be closed under this relation in some sense. This will
allow us to derive the same properties for equivalent terms, and handle
them uniformly.
\begin{def}
Given an equivalence relation $R ⊆ Λ×Λ$, a pole $\dbot ⊆ Λ×Π$ is said to
be $R$-extensional if for every closed terms $t$, $u ∈ Λ^{∗}$ such that
$t R u$, and for every stack $π ∈ Π$, we have $\p{t∗π} ∈ \dbot$ if and
only if $\p{u∗π} ∈ \dbot$.
\end{def}
From now on, and until the end of this chapter, we will only consider
poles that are both $≡$-extensional and $R$-saturated for some reduction
relation $R ⊆ (Λ×Π)×(Λ×Π)$ such that $({≻}) ⊆ R$. This information will
be kept implicit most of the time. Note that $R$, much like $({≡})$ is
a parameter of our type system and realisability semantics.
\begin{thm}\label("poleext")
Let $Φ ⊆ Λ_ι^{∗}$ be a set of closed values and $t$, $u ∈ Λ^{∗}$ be two
closed terms. With an $≡$-extensional pole, if $t ∈ Φ^{⊥⊥}$ and $t ≡ u$
then $u ∈ Φ^{⊥⊥}$.
\begin{proof}
By definition we need to take $π ∈ Φ^⊥$ and show that $\p{u∗π} ∈ \dbot$.
Since $t ∈ Φ^{⊥⊥}$ we have $\p{t∗π} ∈ \dbot$ and hence we can conclude
using the $≡$-extensionality of our pole since we have $t ≡ u$.
\end{proof}
\end{thm}

In our realisability model, the well-formed closed types will be
interpreted by the elements of a set defined according to their sort.
Such a set can be seen as the interpretation, in the model, of the sort
themselves.
\begin{def}
To every sort $s ∈ \cal{S}$ we associate a set $⟦s⟧$ defined as follows.
\Caml(
let _ = tabular_layout 0.8 2.0
  [ [ <<$⟦ι⟧ = Λ_ι^{∗}$>>
    ; <<$⟦τ⟧ = Λ^{∗}$>>
    ; <<$⟦σ⟧ = Π^{∗}$>> ]
  ; [ <<$⟦ο⟧ = \{P ∈ \cal{P}(Λ_ι^{∗} / {≡}) \| \v{□} ∈ P\}$>>
    ; <<$⟦s→r⟧ = ⟦r⟧^⟦s⟧$>> ] ]
)
\end{def}
Note that a type of sort $ο$ will be interpreted by a set of closed
values containing the special value $\v{□}$. It is also required
for this set to be closed under the equivalence relation $({≡})$.
This means that for all $Φ ∈ ⟦ο⟧$ and for all closed values $v$,
$ w ∈Λ_ι^{∗}$ such that $v ∈ Φ$ and $v ≡ w$ we also have $w ∈ Φ$.
\begin{rem}
The presence of the value $\v{□}$ in the interpretation of types
of sort $ο$ is not important for the current chapter, nor for
\chapter("semValRest"). It will however play a crucial role in
\chapter("subtyping"), where the semantical interpretation of
propositions will be required to be non-empty.
\end{rem}

The semantical interpretation of types usually relies on a substitution
(or interpretation function) to interpret free variables. Here, we will
use another common method consisting in extending the syntax of types
with the elements of the model. We will thus substitute free variables
with such elements of the model, which will allow us to interpret closed
types only. Of course, an open type can always be made into a closed
types by replacing its free variables by elements of the interpretation
of the corresponding sorts.
\begin{def}
We extend the syntax of types with the elements of the model. As a
consequence, we will consider that $⟦s⟧ ⊆ \cal{F}$ for every sort
$⟦s⟧$. Note that this is already true for $s = ι$, $s = τ$ and
$s = σ$. We will often use the letter $Φ$ to denote an element of the
model in the syntax. Our system is also extended with the following
sorting rule.
$$ \unaryR{Φ ∈ ⟦s⟧}{Σ ⊢ Φ : s} $$
\end{def}
\begin{def}
Given a sorting context $Σ$, we call a //valuation// over $Σ$ a finite
map $ρ$ such that for all $χ∈dom(Σ)$ we have $ρ(χ) ∈ ⟦Σ(χ)⟧$. If
$A∈\cal{F}$ is a type and $s∈\cal{S}$ is a sort such that $Σ ⊢ A: s$
then we denote $\f{Aρ}$ the type formed by applying $ρ$ to $A$.
\end{def}
\begin{lem}\label("typevalaux")
Let $Σ₁$ and $Σ₂$ be two sorting contexts such that $dom(Σ₁) ∩ dom(Σ₂) = ∅$.
Let $A∈\cal{F}$ be a type and $s∈\cal{S}$ be a sort such that $Σ₁,Σ₂ ⊢ A:s$.
If $ρ$ is a valuation over $Σ₁$ such that $dom(ρ) ∩ dom(Σ₂) = ∅$ then
$Σ₂ ⊢ \f{Aρ} : s$.
\begin{proof}
Simple induction on the derivation of $Σ₁, Σ₂ ⊢ A : s$ by replacing the
variables of $Σ₁$ by their value in $ρ$. During the induction $Σ₂$ will
grow when going through the rules that extend the context. The proof for
the other rules can be handled immediately by induction hypothesis. The
only interesting case is the axiom
$$\axiomR{Σ₁, Σ₂ ⊢ χ : s}$$
for which there are two cases. Either $χ∈dom(Σ₂)$ and the derivation
remains an axiom, or $χ∈dom(Σ₁)$. In this second case we have $χ∈dom(ρ)$
and thus $χρ = ρ(χ) ∈ ⟦s⟧$. As a consequence the derivation becomes
the following.
$$ \unaryR{ρ(χ) ∈ ⟦s⟧}{Σ₂ ⊢ ρ(χ) : s} $$
\end{proof}
\end{lem}
\begin{lem}\label("typeval")
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be
a sort such that we have $Σ ⊢ A : s$. If $ρ$ is a valuation over $Σ$ then
$⊢ \f{Aρ} : s$.
\begin{proof}
Direct consequence of \lemRef("typevalaux") by taking $Σ₁ = Σ$ and
$Σ₂ = ∅$.
\end{proof}
\end{lem}

We can now give the interpretation of our type constructors in our model.
In particular, the elements of the model such as values, terms or stacks
will be interpreted as themselves.
\begin{def}\label("typesem")
To every closed type $A ∈ \cal{F}$ we associate a set $⟦A⟧$ called its
//interpretation//. It is defined inductively on the structure of $A$ as
follows.
\begin{center}
\diagram(
let _ =
  let line s m = [ vs s; <$=$>; m ] in
  array [`East ; `East ; `West]
  [ line "Φ"               <$ Φ $>
  ; line "(χ^s ↦ A)"       <$ Φ ↦ \vs{A[χ≔Φ]} $>
  ; line "A(B)"            <$ ⟦A⟧(⟦B⟧) $>
  ; line "A ⇒ B"           <$ \{\v{λx t} \| ∀v∈\vs{A},
                                 \t{t[x≔v]} ∈ \ts{B}\} ∪ \{\v{□}\} $>
  ; line "t ∈ A"           <$ \{\v{v} ∈ \vs{A} \|
                                 \v{v} ≡ \t{t}\} ∪ \{\v{□}\} $>
  ; line "A ∧ t ≡ u"       <$ \{\v{v} ∈ \vs{A} \|
                                 \t{t} ≡ \t{u}\} ∪ \{\v{□}\} $>
  ; line "{(li : Ai) i∈I}" <$ \{\v{{(li = vi) i∈I}} \| ∀i∈I,
                                 \v{vi}∈\vs{Ai}\} ∪ \{\v{□}\} $>
  ; line "[(Ci : Ai) i∈I]" <$ \bigcup_{i∈I} \{\v{Ci[v]} \| v∈\vs{Ai}\}
                                 ∪ \{\v{□}\} $>
  ; line "∀χ^s A"          <$ \biginter_{Φ∈⟦s⟧} \vs{A[χ≔Φ]} $>
  ; line "∃χ^s A"          <$ \bigcup_{Φ∈⟦s⟧} \vs{A[χ≔Φ]} $> ]
)
\end{center}
\end{def}
\begin{rem}
We have $\vs{A ∧ t ≡ u} = \vs{A}$ if $t ≡ u$ and $\vs{A ∧ t≡u} = \{\v{□}\}$
otherwise. We also have $\vs{t∈A} = \{\v{□}\}$ if there is no $v ∈ \vs{A}$
such that $v ≡ t$.
\end{rem}
\begin{thm}\label("sortsem")
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be
a sort. If we have a derivation of $Σ ⊢ A : s$ and if $ρ$ is a valuation
over $Σ$ then $\vs{Aρ} ∈ ⟦s⟧$.
\begin{proof}
The proof is done by induction on the derivation of $Σ ⊢ A : s$. We reason
by case on the last rules used in the deduction tree. In the case of the
rule
$$ \unaryR{Φ ∈ ⟦s⟧}{Σ ⊢ Φ : s} $$
the proof is trivial. For the first eighteen rules of \figRef("sortrules"),
the proof is immediate using the induction hypothesis. The remaining cases
are treated bellow. Note that we recall the corresponding rules after the
proof of each case.
\begin{itemize}
\item In the case of the arrow type, we need to show $\vs{(A⇒B)ρ} ∈ ⟦ο⟧$.
  By induction hypothesis, we know $\vs{Aρ} ∈ ⟦ο⟧$ and $\vs{Bρ} ∈ ⟦ο⟧$,
  which give us $\vs{Aρ} ⊆ Λ_ι^{∗}$ and $\ts{Bρ} ⊆ Λ^{∗}$. Consequently,
  $\vs{Aρ⇒Bρ}$ is well-defined and $\vs{Aρ⇒Bρ} ⊆ Λ_ι^{∗}$. By definition,
  we also have $\v{□} ∈ \vs{Aρ⇒Bρ}$ so it only remains to show that
  $\vs{Aρ⇒Bρ}$ is closed under $({≡})$. According to \theorem("canonbox")
  we know that the only value that is equal to $\v{□}$ is itself. As a
  consequence, we only have to consider values that are equivalent to
  a $λ$-abstraction of $\vs{Aρ⇒Bρ}$. Let us take $\v{λx t} ∈ \vs{Aρ⇒Bρ}$
  and a value $w ∈ Λ_ι^{∗}$ such that $\v{λx t} ≡ \v{w}$. According to
  \thmRef("canonlambda") we have $w = \v{λx u}$ for some $u ∈ Λ$ (up to
  renaming of variable $x$) and $t ≡ u$. To prove $\v{λx u} ∈ \vs{Aρ⇒Bρ}$
  we take $v ∈ \vs{Aρ}$ and show $\t{u[x≔v]} ∈ \ts{Bρ}$. Since $\v{λxt} ∈
  \vs{Aρ⇒Bρ}$ we know that we have $\t{t[x≔v]} ∈ \ts{Bρ}$. We can thus
  conclude with \thmRef("poleext") as $({≡})$ is congruence.

  \linesBefore(1) (* FIXME hack *)
  \begin{center}
    $ \binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f{A ⇒ B} : ο} $
  \end{center}

\item In the case of the product type, we need to show that $Φ =
  \vs{{(li:Ai)i∈I}ρ} ∈ ⟦ο⟧$. For all $i∈I$, the induction hypothesis tells
  us that $\vs{Aiρ} ∈ ⟦ο⟧$, which implies $\vs{Aiρ} ⊆ Λ_ι^{∗}$. As a
  consequence, we obtain $Φ ⊆ Λ_ι^{∗}$. We also know that $\v{□} ∈ Φ$ so
  it only remains to show that $Φ$ is closed under $({≡})$. According to
  \theorem("canonbox") we know that the only value that is equal to $\v{□}$
  is itself. As a consequence, we only have to consider values that are
  records. Let us take $\v{{(li=vi)i∈I}} ∈ Φ$ and a value $w ∈ Λ_ι^{∗}$ such
  that $\v{{(li=vi)i∈I}} ≡ w$ and show that $w ∈ Φ$. According to
  \thmRef("canonrecord"), $w$ must be of the form $\v{{(li=wi)i∈I}}$ with
  $\v{vi} ≡ \v{wi}$ for all $i∈I$. We can thus conclude since we know that
  $\vs{Aiρ}$ is closed under $({≡})$.

  \begin{center}
    $ \unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f{{(li : Ai) i∈I}} : ο} $
  \end{center}

\item In the case of the sum type, we can use the same reasoning as for
  the product type to obtain that $Φ = \vs{[(Ci:Ai)i∈I]ρ} ⊆ Λ_ι^{∗}$. By
  definition, we also have $\v{□} ∈ Φ$ so we only have to show that $Φ$
  is closed under $({≡})$. As it is defined as a union, it is enough to
  show that all of its components are themselves closed under $({≡})$.
  In particular, it is the case for $\{\v{□}\}$ according to
  \theorem("canonbox"). Let us now take $i∈I$ and show that
  $\{\v{Ci[v]} \| v ∈ \vs{Aiρ}\}$ is closed under $({≡})$. This is an
  immediate consequence of \thmRef("canoncons") since $\vs{Aiρ}$ is
  closed under $({≡})$.

  \begin{center}
    $ \unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f{[(Ci : Ai) i∈I]} : ο} $
  \end{center}

\item In the case of the universal type, we need to show that $\vs{(∀χ A)ρ}
  ∈ ⟦ο⟧$. As we are free to rename $χ$ we may assume that $χ ∉ dom(ρ)$ and
  hence our goal rewrites $\vs{∀χ Aρ} = \bigcap_{Φ∈⟦s⟧} \vs{Aρ[χ≔Φ]} ∈ ⟦ο⟧$.
  By induction hypothesis, we know that for all $Φ ∈ ⟦s⟧$ we have
  $\vs{Aρ[χ≔Φ]} ∈ ⟦ο⟧$. We can thus conclude since an arbitrary intersection
  of elements of $⟦ο⟧$ is trivially an element of $⟦ο⟧$.

  \begin{center}
    $ \unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f{∀χ A} : ο} $
  \end{center}

\item In the case of the existential type, we can use a similar reasoning
  as for the universal type. We only need to remark that an arbitrary union
  of elements of $⟦ο⟧$ is trivially an element of $⟦ο⟧$.

  \begin{center}
    $ \unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f{∃χ A} : ο} $
  \end{center}

\item In the case of the membership type, we need to show $\vs{tρ∈Aρ} ∈ ⟦ο⟧$.
  By induction hypothesis, we know $\vs{tρ} = \t{tρ} ∈ ⟦τ⟧ = Λ^{∗}$ and
  $\vs{Aρ} ∈ ⟦ο⟧$. As a consequence, the set $\vs{tρ∈Aρ} = \{\v{v} ∈ \vs{Aρ}
  \| \v{v} ≡ \t{tρ}\} ∪ \{\v{□}\}$ is well-defined and we have $\vs{tρ∈Aρ} ⊆
  Λ_ι^{∗}$. It remains to show that $\vs{tρ∈Aρ}$ is closed under $({≡})$ but
  this follows immediately by construction and using \theorem("canonbox").

  \begin{center}
    $ \binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f{t∈A} : ο} $
  \end{center}

\item In the case of the restriction type, we need to show $\vs{Aρ∧tρ≡uρ} ∈
  ⟦ο⟧$. Using the first induction hypothesis, we know that $\vs{Aρ} ∈ ⟦ο⟧$.
  Now, using the second and third induction hypotheses we also know that
  $\vs{tρ}=\t{tρ} ∈ ⟦τ⟧ = Λ^{∗}$ and that $\vs{uρ}=\t{uρ} ∈ ⟦τ⟧ = Λ^{∗}$.
  Consequently, the equivalence $t ≡ u$ is well-defined, and thus
  $\vs{Aρ∧tρ≡uρ}$ is either equal to $\vs{Aρ}$ (which contains $\v{□}$
  already), in which case we can conclude immediately, or to $\{\v{□}\}$.
  In this second case we obtain $\{\v{□}\} ∈ ⟦ο⟧$ using \theorem("canonbox").

  \begin{center}
    $ \ternaryR{Σ ⊢ A : ο}{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f{A∧t≡u} : ο} $
  \end{center}
\end{itemize}
\end{proof}
\end{thm}

To conclude this section, we provide two lemmas that will allow us to
show that the interpretation of a propositions is compatible with the
equivalence relation $({≡})$. More precisely, we will show that
substituting a value (resp. a term) with an equivalent value (resp.
term) in a proposition does not change its semantical interpretation.
\begin{lem}\label("vexttyp")
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type, $x ∈ \cal{V}_ι$ be a
$λ$-variable and $v₁$, $v₂ ∈ Λ_ι$ be values such that $Σ, x : ι ⊢ A : ο$,
$Σ ⊢ v₁ : ι$ and $Σ ⊢ v₂ : ι$. If $ρ$ is a valuation over $Σ$ and if
$v₁ρ ≡ v₂ρ$ then we have $\vs{Aρ[x≔v₁ρ]} = \vs{Aρ[x≔v₂ρ]}$.
\begin{proof}
According to \thmRef("sortsem"), we have $⟦v₁ρ⟧ = v₁ρ ∈ ⟦ι⟧$ and
$⟦v₂ρ⟧ = v₂ρ ∈ ⟦ι⟧$ since we have $Σ ⊢ v₁ : ι$ and $Σ ⊢ v₂ : ι$. 
As a consequence, $\subs("ρ[x≔v₁ρ]")$ and $\subs("ρ[x≔v₂ρ]")$ are
both valuations over the sorting context $Σ, x : ι$, and thus we
obtain $\vs{Aρ[x≔v₁ρ]} ∈ ⟦ο⟧$ and $\vs{Aρ[x≔v₂ρ]} ∈ ⟦ο⟧$ using
\thmRef("sortsem") once again. We will now show, by induction on
the derivation of $Σ, x : ι ⊢ A : ο$, that
$\vs{Aρ[x≔v₁ρ]} = \vs{Aρ[x≔v₂ρ]}$. The only interesting cases
(that are not immediate by induction hypothesis) are membership and
restriction. In the case of membership
$$\binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f{t∈A} : ο}$$
we need to show that $\vs{(t∈A)ρ[x≔v₁ρ]} = \vs{(t∈A)ρ[x≔v₂ρ]}$.
By definition, we need to show
$\{\v{v} ∈ \vs{Aρ[x≔v₁ρ]} \| \v{v} ≡ \t{tρ[x≔v₁ρ]}\} =
 \{\v{v} ∈ \vs{Aρ[x≔v₂ρ]} \| \v{v} ≡ \t{tρ[x≔v₂ρ]}\}$.
As we know that $\vs{Aρ[x≔v₁ρ]} = \vs{Aρ[x≔v₂ρ]}$ by
induction hypothesis, we only need to show that
$\t{tρ[x≔v₁ρ]} ≡ \t{tρ[x≔v₂ρ]}$. This follows from the fact that
$({≡})$ is a congruence since we have $v₁ρ ≡ v₂ρ$. In the case of
restriction
$$\ternaryR{Σ ⊢ A : ο}{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f{A∧t≡u} : ο}$$
we need to show that $\vs{(A∧t≡u)ρ[x≔v₁ρ]} = \vs{(A∧t≡u)ρ[x≔v₂ρ]}$.
By definition, we need to show that
$\t{tρ[x≔v₁ρ]} ≡ \t{uρ[x≔v₁ρ]}$ if and only if
$\t{tρ[x≔v₂ρ]} ≡ \t{uρ[x≔v₂ρ]}$ since
$\vs{Aρ[x≔v₁ρ]} = \vs{Aρ[x≔v₂ρ]}$
by induction hypothesis. We can then conclude since we have
$\t{tρ[x≔v₁ρ]} ≡ \t{tρ[x≔v₂ρ]}$ and
$\t{uρ[x≔v₁ρ]} ≡ \t{uρ[x≔v₂ρ]}$ using again the fact that $({≡})$
is a congruence.
\end{proof}
\end{lem}
\begin{lem}\label("texttyp")
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type, $a ∈ \cal{V}_τ$ be a
term variable and $u₁$, $u₂ ∈ Λ_ι$ be terms such that $Σ, a : τ ⊢ A : ο$,
$Σ ⊢ u₁ : τ$ and $Σ ⊢ u₂ : τ$. If $ρ$ is a valuation over $Σ$ and if
$u₁ρ ≡ u₂ρ$ then $\vs{Aρ[a≔u₁ρ]} = \vs{Aρ[a≔u₂ρ]}$.
\begin{proof}
The proof is very similar to that of \lemma("vexttyp").
\end{proof}
\end{lem}

=<
=> Adequacy

Now that the interpretation of our types in our model has been specified,
we need to show that our typing rules actually agree with the semantics.
Intuitively, we need to check that whenever our type system can be used to
prove that a term $t$ has type $A$, then $t$ is indeed in the term level
interpretation of $A$. This will be summarised in the following theorem,
but we first need the following definition.
\begin{def}
Let $Σ$ be a sorting context, $ρ$ be a valuation over $Σ$ and $Γ$ be a
typing context such that $Σ ⊢ Γ$ is derivable. We say that $ρ$ realises
$Γ$ and we write $ρ ⊩ Γ$ if for every $x ∈ dom(Γ) ∩ \cal{V}_ι$ we have
$ρ(x) ∈ ⟦(Γ(x))ρ⟧$ and for every $α ∈ dom(Γ) ∩ \cal{V}_σ$ we have
$ρ(α) ∈ ⟦(Γ(x))ρ⟧^\bot$.
\end{def}
\begin{thm}\label("adequacy")
Let $Σ$ be a sorting context, $Γ$ be a typing context, $Ξ$ be an equational
context and $A ∈ \cal{F}$ be a type. Let $ρ$ be a valuation over $Σ$ such
that $ρ ⊩ Γ$ and $ρ ⊩ Ξ$.
\begin{itemize}
\item If $t$ is a term such that $Σ \sp Γ ; Ξ ⊢ t:A$ is derivable, then
  $\t{tρ} ∈ \ts{Aρ}$.
\item If $v$ is a value such that $Σ \sp Γ ; Ξ ⊢_\tval v:A$ is derivable,
  then $\v{vρ} ∈ \vs{Aρ}$.
\end{itemize}
\begin{proof}
We proceed by induction on the derivation of the judgment
$Σ \sp Γ ; Ξ ⊢_\tval v : A$ or $Σ \sp Γ ; Ξ ⊢ t : A$, and
we reason by case on the last used rule. Note that the
deduction rules are recalled bellow the proof of the
corresponding case.
\begin{itemize}
\item In the case of ($Ax$), we immediately have $\v{xρ} = \v{ρ(x)} ∈
  \vs{Aρ}$ since $ρ ⊩ Γ, x:A$.

  \begin{center}
    $ \id(r_ax) $
  \end{center}

\item If the last used rule is ($↑$) then we need to show $\v{vρ} ∈ \ts{Aρ}$.
  By induction hypothesis we know $\v{vρ} ∈ \vs{Aρ}$, hence we can conclude
  using \lemma("orthosimple").

  \begin{center}
    $ \id(r_up) $
  \end{center}

\item If the last used rule is ($⇒_i$) then we need to show that $\t{(λx t)ρ}
  ∈ \vs{(A ⇒ B)ρ}$. As we are free to rename $x$, we can assume that
  $\t{(λx t)ρ} = \t{λx tρ}$ and thus our goal rewrites as $\t{λx tρ} ∈
  \vs{Aρ ⇒ Bρ}$. By definition, we need to take a value $v ∈ \vs{Aρ}$ and
  show that we have $\t{(tρ)[x ≔ v]} ∈ \ts{Bρ}$. We can conclude by induction
  hypothesis using the valuation $\subs("ρ[x ≔ v]")$.

  \begin{center}
    $ \id(r_arrow_i) $
  \end{center}

\item If the last used rule is ($⇒_e$) then we need to show $\t{(t u)ρ} =
  \t{tρ uρ} ∈ \ts{Bρ}$. Let us take $π ∈ \ss{Bρ}$ and show $\p{tρ uρ ∗ π}
  ∈ \dbot$. Since $\p{tρ uρ ∗ π} ≻ \p{uρ ∗ [tρ]π}$ and $\dbot$ is saturated,
  it is enough to show $\p{uρ ∗ [tρ]π} ∈ \dbot$. As $\t{uρ} ∈ \ts{Aρ}$ by
  induction hypothesis, it only remains to show $\s{[tρ]π} ∈ \ss{Aρ}$. Let
  us take $\v{v} ∈ \vs{Aρ}$ and show that $\p{v ∗ [tρ]π} ∈ \dbot$. Since
  $\p{v ∗ [tρ]π} ≻ \p{tρ ∗ v·π}$ and $\dbot$ is saturated, it is enough to
  show $\p{tρ ∗ v·π} ∈  \dbot$. By induction hypothesis $\t{tρ} ∈
  \ts{Aρ⇒Bρ}$, hence it only remains to show that we have $\s{v·π} ∈
  \ss{Aρ ⇒ Bρ}$. Let us now take a value $\v{w} ∈ \vs{Aρ⇒Bρ}$ and show
  $\p{w ∗ v·π} ∈ \dbot$. If $w = \v{□}$ then we have $\p{□ ∗ v·π} ≻
  \p{□ ∗ π}$ and it is enough to show $\p{□ ∗ π} ∈ \dbot$ as $\dbot$ is
  saturated. Since $π ∈ \ss{Bρ}$ we only have to show that $\v{□} ∈ \vs{Bρ}$
  which is immediate since $\vs{Bρ} ∈ ⟦ο⟧$. If $w = \v{λx f}$ then we have
  $\p{λx f ∗ v·π} ≻ \p{f[x ≔ v] ∗ π}$ and as $\dbot$ is saturated, it is
  enough to show $\p{f[x ≔ v] ∗ π} ∈ \dbot$. Since $\s{π} ∈ \ss{Bρ}$ it
  only remains to show $\t{f[x ≔ v]} ∈ \ts{Bρ}$, but this is true by
  definition of $\vs{Aρ ⇒ Bρ}$ since $\v{v} ∈ \vs{Aρ}$.

  \begin{center}
    $ \id(r_arrow_e) $
  \end{center}

\item If the last used rule is ($μ$) then we need to show that $\t{(μα t)ρ}
  ∈ \ts{Aρ}$. As we are free to rename $α$, we can assume that $\t{(μα t)ρ}
  = \t{μα tρ}$ and thus our goal rewrites as $\t{μα tρ} ∈ \ts{Aρ}$. Let us
  now take a stack $π ∈ \ss{Aρ}$ and show $\p{μα tρ ∗ π} ∈ \dbot$. Since
  $\p{μα tρ ∗ π} ≻ \p{tρ[α ≔ π] ∗ π}$ and $\dbot$ is saturated, it is enough
  to show that we have $\p{tρ[α ≔ π] ∗ π} ∈ \dbot$. We can then conclude by
  induction hypothesis with the valuation $\subs("ρ[α ≔ π]")$.

  \begin{center}
    $ \id(r_mu) $
  \end{center}

\item If the last used rule is ($[\wc]$) then we need to show $\t{([α]t)ρ}
  = \t{[ρ(α)]tρ} ∈ \ts{Bρ}$. Let us take $π ∈ \ss{Bρ}$ and show
  $\p{[ρ(α)]tρ ∗ π} ∈ \dbot$. Since $\p{[ρ(α)]tρ ∗ π} ≻ \p{tρ ∗ ρ(α)}$ and
  $\dbot$ is saturated, it is enough to show $\p{tρ ∗ ρ(α)} ∈ \dbot$. By
  induction hypothesis, we know that $\t{tρ} ∈ \ts{Aρ}$, hence we only need
  to show that $\s{ρ(α)}∈\ss{Aρ}$. This is immediate as we have $ρ ⊩ Δ,α:A$.

  \begin{center}
    $ \id(r_name) $
  \end{center}

\item If the last used rule is ($∀_i$) then we need to show $\v{vρ} ∈
  \vs{(∀χ^s A)ρ}$. As we are free to rename $χ$, this amounts to showing
  $\v{vρ} ∈ \vs{∀χ^s Aρ} = \bigcap_{\f{B}∈⟦s⟧} \vs{Aρ[χ ≔ B]}$. Hence it is
  enough to take $\f{B} ∈ ⟦s⟧$ and show $\v{vρ} ∈ \vs{Aρ[χ ≔ B]}$. Note that
  $\v{vρ} = \v{vρ[χ ≔ B]}$ as $\f{χ}$ cannot appear in $\v{v}$ as otherwise
  the conclusion judgment would not be well-formed. We can thus conclude by
  induction hypothesis using the valuation $\subs("ρ[χ ≔ B]")$.

  \begin{center}
    $ \id(r_forall_i) $
  \end{center}

\item If the last used rule is ($∀_e$) then we need to show
  $\t{tρ} ∈ \ts{(A[χ ≔ B])ρ}$. By induction hypothesis we have
  $\t{tρ} ∈ \ts{(∀χ^s A)ρ}$, and as a consequence we need to show that
  $\ts{(∀χ^s A)ρ} ⊆ \ts{(A[χ ≔ B])ρ}$. According to \lemRef("orthoincl"),
  it is enough to show
  $\vs{(∀χ^s A)ρ} ⊆ \vs{(A[χ ≔ B])ρ} = \vs{Aρ[χ ≔ Bρ]}$. As we are free to
  rename $χ$, our goal rewrites as $\vs{∀χ^s Aρ} ⊆ \vs{Aρ[χ ≔ Bρ]}$. Since
  $\vs{∀χ^s Aρ} = \bigcap_{\f{Φ}∈⟦s⟧} \vs{Aρ[χ ≔ Φ]}$ and $\f{Bρ} ∈ ⟦s⟧$ we
  can conclude the proof.

  \begin{center}
    $ \id(r_forall_e) $
  \end{center}

\item If the last used rule is ($∃_i$) then we need to show
  $\t{tρ} ∈ \ts{(∃χ^s A)ρ}$. By induction hypothesis we have
  $\t{tρ} ∈ \ts{(A[χ ≔ B])ρ}$, and as a consequence we need to show
  that $\ts{(A[χ ≔ B])ρ} ⊆ \ts{(∃χ^s A)ρ}$. According to
  \lemRef("orthoincl"), it is enough to show
  $\vs{(A[χ ≔ B])ρ} = \vs{Aρ[χ ≔ Bρ]} ⊆ \vs{(∃χ^s A)ρ}$.
  As we are free to rename $χ$, our goal rewrites as
  $\vs{Aρ[χ ≔ Bρ]} ⊆ \vs{∃χ^s Aρ}$.
  Since $\vs{∃χ^s Aρ} = \bigcup_{\f{Φ}∈⟦s⟧} \vs{Aρ[χ ≔ Φ]}$ and
  $\f{Bρ} ∈ ⟦s⟧$ we can conclude the proof.

  \begin{center}
    $ \id(r_exists_i) $
  \end{center}

\item If the last used rule is ($∃_e$) then we need to show
  $\t{tρ} ∈ \ts{Cρ}$. To apply the induction hypothesis,
  we need to check that $\v{ρ(x)} ∈ \vs{(A[χ ≔ B])ρ}$ provided
  $\v{ρ(x)} ∈ \vs{(∃χ^s A)ρ}$. In other words, we need to show
  $\vs{(A[χ ≔ B])ρ} = \vs{Aρ[χ ≔ Bρ]} ⊆ \vs{(∀χ^s A)ρ}$. As
  we are free to rename $χ$, our goal rewrites as
  $\vs{Aρ[χ ≔ Bρ]} ⊆ \vs{∃χ^s Aρ}$. The inclusion follows since
  $\vs{∃χ^s Aρ} = \bigcup_{\f{Φ}∈⟦s⟧} \vs{Aρ[χ ≔ Φ]}$ and
  $\f{Bρ} ∈ ⟦s⟧$.

  \begin{center}
    $ \id(r_exists_e) $
  \end{center}

\item If the last used rule is ($∈_e$) then we need to show $\t{uρ} ∈
  \ts{Cρ}$. To apply the induction hypothesis, we need to check that
  $\v{ρ(x)} ∈ \vs{Aρ}$ and that $\v{ρ(x)} ≡ \t{tρ}$, provided that we have
  $\v{xρ} ∈ \vs{(t∈A)ρ}$. By definition $\vs{(t∈A)ρ} = \vs{tρ∈Aρ} =
  \{v∈\vs{Aρ} \st v ≡ \t{tρ}\}$ so we indeed have $\v{ρ(x)} ∈ \vs{Aρ}$ and
  $\v{ρ(x)} ≡ \t{tρ}$.

  \begin{center}
    $ \id(r_memb_e) $
  \end{center}

\item In the case of ($∈_i$) we need to show that
  $\v{vρ} ∈ \vs{(v ∈ A)ρ} = \{w ∈ \vs{Aρ} \| w ≡ vρ\}$. By
  induction hypothesis we have $\v{vρ} ∈ \vs{Aρ}$ so we only
  need to show that $\t{vρ} ≡ \t{vρ}$, which follows from
  the reflexivity of $({≡})$.

  \begin{center}
    $ \id(r_memb_i) $
  \end{center}

\item If the last used rule is ($↾_i$) then we need to show
  $\t{tρ} ∈ \ts{(A ∧ u₁≡u₂)ρ}$. Using the right premise
  we know that $\t{u₁ρ} ≡ \t{u₂ρ}$, and hence
  $\vs{Aρ ∧ u₁ρ ≡ u₂ρ} = \vs{Aρ}$ by definition. Consequently
  we have $\ts{Aρ ∧ u₁ρ ≡ u₂ρ} = \ts{Aρ}$ by
  \lemRef("orthoincl"), and hence we can conclude since
  $\t{tρ} ∈ \ts{Aρ}$ by induction hypothesis.

  \begin{center}
    $ \id(r_rest_i) $
  \end{center}

\item If the last used rule is ($↾_e$) then we need to show
  $\t{tρ} ∈ \ts{Cρ}$. To be able to apply the induction hypothesis,
  we only have to show $ρ(x) ∈ \vs{Aρ}$ and $u₁ρ ≡ u₂ρ$ under the
  assumption that $ρ(x) ∈ \vs{Aρ ∧ u₁ρ ≡ u₂ρ} ≠ ∅$. This immediately
  follows from the definition of $\vs{Aρ ∧ u₁ρ ≡ u₂ρ}$ since it
  contains $ρ(x)$.

  \begin{center}
    $ \id(r_rest_e) $
  \end{center}

\item If the last used rule is ($×_i$) then we need to show
  $\v{{(li = vi) i∈I}ρ} ∈ \vs{{(li : Ai) i∈I}ρ}$. By definition it
  is enough to show that $\v{viρ} ∈ \vs{Aiρ}$ for all index $i$ in
  $I$. This exactly corresponds to the induction hypotheses.

  \begin{center}
    $ \id(r_prod_i) $
  \end{center}

\item If the last used rule is ($×_e$) then we need to show that
  $\t{(v.lk)ρ} = \t{vρ.lk} ∈ \ts{Akρ}$. Let us take $π ∈ \ss{Akρ}$ and
  show that $\p{vρ.lk ∗ π} ∈ \dbot$. By induction hypothesis we know that
  $\v{vρ} ∈ \vs{{(li : Ai) i∈I}ρ}$. If $\v{vρ} = \v{□}$ then we have
  $\p{□.lk ∗ π} ≻ \p{□ ∗ π}$ and thus it is enough to show $\v{□} ∈
  \vs{Akρ}$ as $\dbot$ is saturated and $π ∈ \ss{Akρ}$. This is immediate
  since $\vs{Akρ} ∈ ⟦ο⟧$. If $\v{vρ} = \v{{(li = vi) i∈I}}$ then we have
  $\p{{(li = viρ) i∈I}.lk ∗ π} ≻ \p{vkρ ∗ π}$ and it is enough to show
  $\p{vkρ ∗ π} ∈ \dbot$ as $\dbot$ is saturated. Since $π ∈ \ss{Akρ}$ we
  only have to show that $\v{vkρ} ∈ \ts{Akρ}$. We can hence conclude using
  \lemma("orthosimple") as we have $\v{vkρ} ∈ \vs{Akρ}$ by definition.

  \begin{center}
    $ \id(r_prod_e) $
  \end{center}

\item If the last used rule is ($+_i$) then we need to show
  $\t{(Ck[v])ρ} ∈ \vs{[(Ci : Ai) i∈I]ρ}$. By definition,
  it is enough to show that $\v{vρ} ∈ \vs{Akρ}$ since
  $\t{(Ck[v])ρ} = \v{Ck[vρ]}$ and $k ∈ I$. This is
  exactly the induction hypothesis.

  \begin{center}
    $ \id(r_sum_i) $
  \end{center}

\item If the last used rule is ($+_e$) then we need to show
  $\t{[v | (Ci[xi] → ti) i∈I]ρ} ∈ \ts{Bρ}$. Let us take $π ∈ \ss{Bρ}$ and
  show that $\p{vρ.lk ∗ π} ∈ \dbot$. By induction hypothesis, we know that
  $\v{vρ} ∈ \vs{[(Ci : Ai) i∈I]ρ}$. If $\v{vρ} = \v{□}$ then we have
  $\p{[□ | (Ci[xi] → tiρ) i∈I] ∗ π} ≻ \p{□ ∗ π}$ and thus it is enough to
  show that $\v{□} ∈ \vs{Bρ}$ as $\dbot$ is saturated and $π ∈ \ss{Bρ}$.
  This is immediate since $\vs{Bρ} ∈ ⟦ο⟧$. If $\v{vρ} = \v{Ck[w]}$ for
  some $k∈I$ then, by definition, we have
  $\p{[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π} ≻ \p{tkρ[xk≔w] ∗ π}$
  and thus it is enough to show that $\p{tkρ[xk≔w] ∗ π} ∈ \dbot$ as
  $\dbot$ is saturated. Since $π ∈ \ss{Bρ}$ we only have to show that
  $\t{tkρ[xk≔w]} ∈ \ts{Bρ}$. Note that neither $\f{B}$, $\f{Ak}$ nor $\v{v}$
  may contain the variable $\v{xk}$ as otherwise some judgment would not
  be well-formed. As a consequence, we have $\vs{Bρ[xk≔w]} = \vs{Bρ}$,
  $\vs{Akρ[xk≔w]} = \vs{Akρ}$ and $\v{vρ[xk≔w]} = \v{vρ}$. To be able to
  conclude using the induction hypothesis, we need to show that the
  valuation $\subs("ρ[xk≔w]")$ realises $Γ,x_k:A_k;Ξ,v≡\t{Ck[xk]}$. As we
  know that $ρ$ realises $Γ, Ξ$, we only have to show that 
  $\v{ρ(xk)} ∈ \vs{Akρ[xk≔w]} = \vs{Akρ}$, which is true by induction
  hypothesis, and that $\v{vρ[xk≔w]} = \v{vρ} ≡ \t{Ck[w]} = \t{Ck[ρ(xk)]}$,
  which is true by hypothesis.
 
  \begin{center}
    $ \id(r_sum_e) $
  \end{center}

\item If the last used rule is ($≡_{ι,ι}$) then we need to show
  $\t{(v[x≔w₂])ρ} ∈ \vs{(A[x≔w₂])ρ}$. As we are free to rename
  $x$ we may assume that it does not appear in $dom(ρ)$, and our
  goal rewrites as $\t{vρ[x≔w₂ρ]} ∈ \vs{Aρ[x≔w₂ρ]}$. According
  to our second premise we have $\t{w₁ρ} ≡ \t{w₂ρ}$ and
  thus we get $\vs{Aρ[x≔w₂ρ]} = \vs{Aρ[x≔w₁ρ]}$ using
  \lemma("vexttyp") and $\t{vρ[x≔w₂ρ]} ≡ \t{vρ[x≔w₁ρ]}$ using
  the fact that $({≡})$ is a congruence. Now, since we know that
  $\vs{Aρ[x≔w₁ρ]}$ is closed under $({≡})$, it only remains to
  show that we have $\t{vρ[x≔w₁ρ]} ∈ \vs{Aρ[x≔w₁ρ]}$. To be able
  to conclude by induction hypothesis, we need to
  show that $ρ ⊩ Γ[x≔w₁]$. As we know that $ρ ⊩ Γ[x≔w₂]$ we only
  need to show that for every type $B$ appearing in $Γ$ we have
  $\vs{(B[x≔w₁])ρ} = \vs{(B[x≔w₂])ρ}$. As we are again free to
  rename $x$, this rewrites as $\vs{Bρ[x≔w₁ρ]} = \vs{Bρ[x≔w₂ρ]}$.
  We can then conclude the proof using \lemma("vexttyp") once more.

  \begin{center}
    $ \id(r_eq_ii) $
  \end{center}

\item If the last used rule is ($≡_{τ,ι}$) then the proof is similar to the
  previous case, using the fact that $Φ₁ = Φ₂$ implies $Φ₁^{⊥⊥} = Φ₂^{⊥⊥}$
  (i.e. \lemma("orthoincl")).

  \begin{center}
    $ \id(r_eq_ti) $
  \end{center}

\item If the last used rule is ($≡_{ι,τ}$) then the proof is the same as
  for the ($≡_{ι,ι}$) case, using \lemma("texttyp") instead of
  \lemma("vexttyp").

  \begin{center}
    $ \id(r_eq_it) $
  \end{center}

\item If the last used rule is ($≡_{τ,τ}$) then the proof is the same as
  for the ($≡_{τ,ι}$) case, using again \lemma("texttyp") instead of
  \lemma("vexttyp").

  \begin{center}
    $ \id(r_eq_tt) $
  \end{center}
  \linesAfter(1) (* FIXME hack *)
\end{itemize}
\end{proof}
\end{thm}

Thanks to adequacy (\thmRef("adequacy")), it is possible to prove properties
of our language and type system by choosing appropriate poles. For instance,
we can easily check that closed, typed terms normalise using a pole containing
only processes reducing to a final state. Note that we need to fix the
parameters of the system. Until the end of this section, we will consider
$({≡})$ to be $({≡}_{≻})$ and $R$ to be $({≻})$.
\begin{thm}\label("basicnorm")
Every closed, typed term normalises. More precisely, for every term $t∈Λ^{∗}$
such that $⊢ t : A$ is derivable in the system, there is $v∈Λ_ι^{∗}$ such that
$\p{t∗π} ≻^{∗} \p{v∗ε}$.
\begin{proof}
We consider the pole $\dbot=\{p ∈ Λ∗Π \| ∃v∈Λ_ι, p ≻^{∗} \p{v∗ε}\}$ which is
trivially saturated. We will first check that it is also $≡_{≻}$-extensional.
Let us suppose that $t ≡_{≻} u$ and that $\p{t∗π} ∈ \dbot$. By definition of
$\dbot$, there must be a value $v$ such that $\p{t∗π} ≻^{∗} \p{v∗ε}$, and
thus we have ${\p{t∗π}} {⇓}_{≻}$. Since $t ≡_{≻} u$ we can deduce
${\p{u∗π}} {⇓}_{≻}$, and thus there must be a value $w$ such that
$\p{u∗π} ≻ \p{w∗ε}$. This exactly means that $\p{u∗π} ∈ \dbot$.

We can now apply \thmRef("adequacy") with the pole $\dbot$ and the empty
substitution $ρ_{id}$ to obtain $\t{t} ∈ \ts{A}$. By definition, this means
that $\p{t ∗ ξ} ∈ \dbot$ for every stack $ξ ∈ \ss{A}$. In particular, we
have $\p{t ∗ ε} ∈ \dbot$ as we trivially have $ε ∈ \ss{A}$. This exactly
means that there is a value $v∈Λ_ι$ such that $\p{t∗ε} ≻^{∗} \p{v∗ε}$. It
remains to show that $v$ is closed, but this is trivial as none of our
reduction rules can introduce a free variable.
\end{proof}
\end{thm}

Using a similar technique, it is possible to show a stronger safety property
if we restrict ourselves to terms having a //pure// type (i.e. a type that
does not contain arrows). Indeed, when a closed term $t$ has type $A$ and $A$
is pure, we can show that $t$ reduces to a value that is contained in the
semantical interpretation of $A$.
\begin{thm}\label("basicsafety")
For every closed term $t ∈ Λ_ι^{∗}$ such that $⊢ t : A$ for a pure type $A$,
there is a value $v ∈ \vs{A}$ such that $\p{t∗ε} ≻^{∗} \p{v∗ε}$.
\begin{proof}
\todo(None) (* TODO *)
\end{proof}
\end{thm}
Note that the value $\v{□}$ cannot appear during reduction. It is easy to
see that none of our reduction rules can introduce it.

Finally, we are going to show that our type system is consistent as a logic.
In other words, we will show that there is no closed term of type $⊥$.
\begin{thm}\label("basicconsistency")
There is no closed term $t ∈ Λ^{∗}$ that does not contain $\v{□}$ and such
that $⊢ t : ⊥$ is derivable.
\begin{proof}
Let us assume that there a term $t ∈ Λ^{∗}$ that $⊢ t : ⊥$. As $⊥$ is a pure
type we can apply \theorem("basicsafety") to obtain a value $v ∈ ⟦⊥⟧$ such
that $\p{t∗ε} ≻^{∗} \p{v∗ε}$. However, we have $⟦⊥⟧=\vs{∀χ^ο χ}=\{\v{□}\}$
so it must be that $\v{v} = \v{□}$. This is a contradiction since we know
that the process $\p{t∗ε}$ does not contain $\v{□}$, and thus $\p{v∗ε}$
cannot contain $\v{□}$ either.
\end{proof}
\end{thm}

=<

=> Typing stacks

In our system, the typing rule for the named terms of the \lmcalc is
limited to stack variables. As a consequence, terms can only contain
terms of the form $\t{[π]t}$ when $π$ is a stack variable.
\begin{center}
  $ \id(r_name) $
\end{center}
It is however possible to generalise this typing rule to accept more
stacks, provided that they can be typed in some sense.
\begin{def}
A stack judgement is a tuple of a typing context $Γ$, an equational
context $Ξ$, a stack $π ∈ Π$ and a type $A ∈ \cal{F}$ that is denoted
$Γ; Ξ ⊢ π : A^⊥$. We say that such a judgment is well-formed under
the sorting context $Σ$, and we write $Σ \sp Γ; Ξ ⊢ π : A^⊥$, if and
only if we have $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ π : σ$ and $Σ ⊢ A : ο$.
\end{def}

\Caml(
let r_name' =
  <$\binaryRN{[\wc]}{Σ \sp Γ;Ξ ⊢ \t{t} : A}
   {Σ \sp Γ;Ξ ⊢ \s{π} : A^⊥}
   {Σ \sp Γ;Ξ ⊢ \t{[π]t} : B}$>

let r_ax' =
  <$\axiomRN{Ax^⊥}{Σ, α:σ \sp Γ, α:A^⊥; Ξ ⊢ \s{α} : A^⊥}$>

let r_push =
  <$\binaryRN{\wc·\wc}{Σ \sp Γ;Ξ ⊢_\tval \v{v} : A}
   {Σ \sp Γ;Ξ ⊢ \s{π} : \f{B}^⊥}
   {Σ \sp Γ;Ξ ⊢ \s{v·π} : \f{A⇒B}^⊥}$>

let r_fram =
  <$\binaryRN{[\wc]\wc}{Σ \sp Γ;Ξ ⊢ \t{t} : \f{A⇒B}}
   {Σ \sp Γ;Ξ ⊢ \s{π} : \f{B}^⊥}
   {Σ \sp Γ;Ξ ⊢ \s{[t]π} : \f{A}^⊥}$>
)

Using a stack judgment, the typing rule for named terms can replaced
by the following, provided that we have enough rules for typing stacks.
\begin{center}
  $ \id(r_name') $
\end{center}
To recover our previous typing rule for named terms, we need at least
a rule for handling stack variables. This typing rule is very similar
to the axiom rule ($Ax$), as it refers to the context.
\begin{center}
  $ \id(r_ax') $
\end{center}
Using ($Ax^⊥$), the old ($[\wc]$) rule can be derived as follows.
$$
\proofTree{
  \binaryN{[\wc]}{Σ, α:σ \sp Γ, α:A ; Ξ ⊢ \t{[α] t} : B}{
    \hyp{Σ, α:σ \sp Γ, α:A^⊥ ; Ξ ⊢ \t{t} : A}
  }{
    \axiomN{Ax^⊥}{Σ, α:σ \sp Γ, α:A^⊥ ; Ξ ⊢ \s{α} : A^⊥}
  }
}
$$

In addition to the ($Ax^⊥$) rule, we provide two rules for stacked
formed by pushing a value on a stack, or stack frames. Note that it
is also possible to give a typing rule for the empty stack. We will
not use it here as it requires all the processes of the form
$\p{v∗ε}$ to be in the pole.
\begin{center}
  $ \id(r_push) $

  $ \id(r_fram) $
\end{center}

Semantically, we will interpret stack judgments in a similar way as
value and term judgments. The new adequacy lemma will then involve the
three forms of judgments.
\begin{lem}\label("push")
Let $A$, $B∈\cal{F}$ be two closed types such that $⊢ A : ο$ and $⊢ B : ο$.
If $v ∈ \vs{A}$ and $π ∈ \ss{B}$ then $\s{v·π} ∈ \ss{A⇒B}$.
\begin{proof}
Let us take a value $w ∈ \vs{A⇒B}$ and show that $\p{w ∗ v·π} ∈ \dbot$. If
$w = \v{□}$ then we have $\p{□ ∗ v·π} ≻ \p{□ ∗ π}$ and thus it is enough to
show that $\p{□ ∗ π} ∈ \dbot$ since $\dbot$ is saturated. This is immediate
since $π ∈ \ss{B}$ and $\v{□} ∈ \vs{B}$ since $\vs{B} ∈ ⟦ο⟧$ according to
\theorem("sortsem"). If $w = \v{λx t}$ then we have $\p{λx t ∗ v·π} ≻
\p{t[x≔v] ∗ π}$ and thus it is enough to show that $\p{t[x≔v] ∗ π} ∈ \dbot$
since $\dbot$ is saturated. As $π ∈ \ss{B}$ this amounts to showing that
$\t{t[x≔v]} ∈ \ts{B}$, but this follows by definition of $\vs{A⇒B}$ as
$v ∈ \vs{A}$.
\end{proof}
\end{lem}
\begin{thm}\label("stack_adequacy")
Let $Σ$ be a sorting context, $Γ$ be a typing context, $Ξ$ be an equational
context and $A ∈ \cal{F}$ be a type. Let $ρ$ be a valuation over $Σ$ such
that $ρ ⊩ Γ$ and $ρ ⊩ Ξ$.
\begin{itemize}
\item If $Σ \sp Γ ; Ξ ⊢ t:A$ is derivable, then $\t{tρ} ∈ \ts{Aρ}$.
\item If $Σ \sp Γ ; Ξ ⊢ π:A^⊥$ is derivable, then $\s{πρ} ∈ \ss{Aρ}$.
\item If $Σ \sp Γ ; Ξ ⊢_\tval v:A$ is derivable, then $\v{vρ} ∈ \vs{Aρ}$.
\end{itemize}
\begin{proof}
As for \thmRef("adequacy"), the proof is done by induction of the derivation
of the typing judgments. For all the rules of \figRef("typerules") but
($[\wc]$) the proof is exactly the same as for \thmRef("adequacy"). Four
new cases are displayed bellow.
\begin{itemize}
\item If the last used rule is ($[\wc]$) then we need to show
  $\t{([π]t)ρ} = \t{[πρ]tρ} ∈ \ts{Bρ}$. Let us take
  $ξ ∈ \ss{Bρ}$ and show $\p{[πρ]tρ ∗ π} ∈ \dbot$. Since
  $\p{[πρ]tρ ∗ π} ≻ \p{tρ ∗ πρ}$ and $\dbot$ is saturated, it
  is enough to show $\p{tρ ∗ πρ} ∈ \dbot$. This is immediate
  since, by induction hypothesis, we have $\t{tρ} ∈ \ts{Aρ}$
  and $\s{πρ} ∈ \ss{Aρ}$.

  \begin{center}
    $ \id(r_name') $
  \end{center}

\item If the last used rule is ($Ax^⊥$) then we immediately get
  $\s{αρ} = \s{ρ(α)} ∈ \ss{Aρ}$ since we know that we have $ρ ⊩ Γ, α:A^⊥$.

  \begin{center}
    $ \id(r_ax') $
  \end{center}

\item If the last used rule is ($\wc·\wc$) then we need to show
  $\s{vρ·πρ} ∈ \ss{Aρ⇒Bρ}$. This follows from \lemRef("push")
  since we have $vρ ∈ \vs{Aρ}$ and $\s{πρ} ∈ \ss{Bρ}$ by
  induction hypothesis.

  \begin{center}
    $ \id(r_push) $
  \end{center}

\item If the last used rule is ($[\wc]\wc$) then we need to show
  $\s{[tρ]πρ} ∈ \ss{Aρ}$. Let us take $v ∈ \vs{Aρ}$ and
  show $\p{v ∗ [tρ]πρ} ∈ \dbot$. Since we know that
  $\p{v ∗ [tρ]πρ} ≻ \p{tρ ∗ v·πρ}$ and $\dbot$ is saturated,
  it is enough to show $\p{tρ ∗ v·πρ} ∈ \dbot$. By induction
  hypothesis, we have $\t{tρ} ∈ \ts{Aρ⇒Bρ}$ so it is enough
  to show $\s{v·πρ} ∈ \ss{Aρ⇒Bρ}$. This follows from
  \lemRef("push") since $v ∈ \vs{Aρ}$ and $\s{πρ} ∈ \ss{Bρ}$
  by induction hypothesis.

  \begin{center}
    $ \id(r_fram) $
  \end{center}
  \linesAfter(1) (* FIXME hack *)
\end{itemize}
\end{proof}
\end{thm}
Of course, \theorems(["basicnorm";"basicsafety";"basicconsistency"]) can
still be proved in the extended system with exactly the same proof, but
with the extended adequacy lemma.

=<

=<
