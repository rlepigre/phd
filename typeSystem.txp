\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^\bot $>
  let ts a = <$ ⟦\f(a)⟧^{\bot\bot} $>
)
\Include{Macros}

=> Higher-order type system and semantics \label("typeSystem")

In this chapter, we present a new type system which distinguishing feature
is an embedded notion of program equivalence. It enables the specification
of equational properties over programs, which can then be proved using
equational reasoning. Our types are interpreted using standard classical
realisability techniques, which allows for a semantical justification of
our typing rules.

=> Observational equivalence type

To be able to specify program properties, we extend our type system with
equality types of the form $t ≡ u$, where $t$ and $u$ are (possibly untyped)
terms. Equality types are then interpreted as $⊤ = \f("∃X X")$ if the denoted
equivalence is true and as $⊥ = \f("∀X X")$ otherwise. For example, the type
$\f("(λx x) λx x ≡ (λx x)")$ will be inhabited if and only if the identity
function applied to itself is equivalent to the identity function.

mechanism will rely on an untyped notion of equivalence over programs. It
will be used to identify programs with the same computational behaviour and
will enable equational reasoning.

(* TODO *)

=<
=> Realisers as individuals

... (* TODO *)

=<
=> Extensionality and substitutivity

... (* TODO *)

=<
=> Proofs and unreachability

... (* TODO *)

=<
=> Membership and typed quantification

\pagesBefore(1)
(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{Σ; {Γ, x:A}; Δ; Ξ ⊢ t : B}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : A ⇒ B}
\hspace(1.5)
\binaryRN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t : A ⇒ B}{Σ; Γ; Δ; Ξ ⊢ u : A}{
  Σ; Γ; Δ; Ξ ⊢ t u : B}
$$

(* The weak Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, x:ι_v}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{x ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, x:ι_v}; Γ; Δ; Ξ ⊢_\tval λx t : x∈A ⇒ B}{
   \unaryN{∈}{{Σ, x:ι_v}; {Γ, x:{x∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, x:ι_v}; {Γ, x:A}; Δ; {Ξ, x≡x} ⊢ t : B}{
     \hyp{{Σ, x:ι_v} ; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{x ∉ FV(Γ; Δ; Σ)}}
}
$$
(* The weak Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[x := v] ⇒ B[x := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[x := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[x := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]}
   }
  }
 }
}
$$

(* The Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{a ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, a:ι}; Γ; Δ; Ξ ⊢_\tval λx t : a∈A ⇒ B}{
   \unaryN{∈}{{Σ, a:ι}; {Γ, x:{a∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, a:ι}; {Γ, x:A}; Δ; {Ξ, x≡a} ⊢ t : B}{
     \hyp{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{a ∉ FV(Γ; Δ; Σ)}}
}
$$

(* The Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[a := v] ⇒ B[a := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[a := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[a := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]}
   }
  }
 }
}
$$
\pagesAfter(1)

(* TODO *)

=<
=> Extended type system

(* Ax rule *)
$$
\axiomRN{Ax}{
  Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)
}
$$

(* Coercion rules. *)
$$
\unaryRN{↑}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}
$$

$$
\unaryRN{↓}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}
$$

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)
}
$$

(* ⇒_e rule *)
$$
\binaryRN{⇒_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)
}
$$

(* μ rule *)
$$
\unaryRN{μ}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)
}
$$

(* ∗ rule *)
$$
\unaryRN{[\wc]}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)
}
$$

(* ∀i rule *)
$$
\unaryRN{∀_i}{
  Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))
}
$$

(* ∀e rule *)
$$
\binaryRN{∀_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))
}
$$

(* ∃i rule *)
$$
\binaryRN{∃_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))
}
$$

(* ∃e rule *)
$$
\binaryRN{∃_e}{
  Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))
}{
  Σ ⊢ B : s
}{
  Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))
}
$$

(* ∈i rule *)
$$
\unaryRN{∈_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))
}
$$

(* ∈e rule *)
$$
\unaryRN{∈_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ↾i rule *)
$$
\unaryRN{↾_i}{
  Σ ⊢ (Γ;Δ;Ξ,t≡u ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A | t≡u"))
}
$$

(* ↾e rule *)
$$
\unaryRN{↾_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,t≡u ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("A | t≡u");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ×i *)
$$
\unaryRN{×_i}{
  [Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))
}
$$

(* ×e *)
$$
\binaryRN{×_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)
}
$$

(* +i *)
$$
\binaryRN{+_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ci[v]") : \f("[(Ci : Ai) i∈I]"))
}
$$

(* +e *)
$$
\binaryRN{+_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))
}{
  [Σ ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)
}
$$

(* ≡ *)
$$
\unaryRN{≡_{l, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔v]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔w]") : A)
}
$$

$$
\unaryRN{≡_{l}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)
}
$$

$$
\unaryRN{≡_{r, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔v]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔w]"))
}
$$

$$
\unaryRN{≡_{r}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))
}
$$

=<

=> Adequacy

We will now give the formal definition of our new type system.
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= {s→r} \| ξ$ >> << $ξ∈\cal{S}₀$ >>)
\end{def}
\begin{def}
Given a typing context $Γ$, a continuation context $Δ$ and an equational
context $Ξ$ we consider two different forms of typing judgments:
\begin{itemize}
\item value judgments $Γ;Ξ;Δ ⊢_\tval v : A$ meaning that the value $v$ has
      type $A$ and
\item general term judgments $Γ;Ξ;Δ ⊢ t : A$ meaning that the term $t$ has
      type $A$ in the context $Γ;Δ;Ξ$.
\end{itemize}
\end{def}
\begin{def}
Given a sorting context $Σ$ we say that $Γ;Δ;Ξ ⊢ t:A$ is a valid term
judgment and we write $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ when
\begin{itemize}
\item $dom(Γ) ⊆ dom(Σ)$ and hence for all $x ∈ dom(Γ)$ we have $Σ(x) = ι$,
\item $dom(Δ) ⊆ dom(Σ)$ and hence for all $α ∈ dom(Δ)$ we have $Σ(α) = σ$,
\item $Σ ⊢ t : τ$ and $Σ ⊢ A : ο$,
\item $FV_ι(t) ⊆ dom(Γ)$, $FV_σ(t) ⊆ dom(Δ)$ and $FV_τ(t) = ∅$,
\item for all $x ∈ dom(Γ)$ we have $Σ ⊢ Γ(x) : ο$,
\item for all $α ∈ dom(Δ)$ we have $Σ ⊢ Δ(α) : ο$,
\item for all $(t ≡ u) ∈ Σ$ we have $Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{itemize}
\end{def}

\begin{def}
A valuation over a sorting context $Σ$ is a map $ρ$ such that $ρ(χ) ∈ ⟦Σ(χ)⟧$
for every $χ ∈ dom(Σ)$. In particular, this means that $dom(Σ) ⊆ dom(ρ)$.
\end{def}

(* Adequacy lemma. *)
\begin{thm}
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the typing
judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ (resp. $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$) is derivable
and if $ρ ⊩ Γ;Δ;Ξ$ then $\t("tρ") ∈ |\f("Aρ")|$ (resp.
$\t("vρ") ∈ ⟦\f("Aρ")⟧$).
\begin{proof}
We proceed by induction on the derivation of the judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$
or $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$, and we reason by case on the last used rule.
\begin{itemize}
\item In the case of the ($Ax$) rule, we immediately obtain
      $\t("xρ") = \t("ρ(x)") ∈ ⟦\f("Aρ")⟧$ by hypothesis.
      \begin{center}
        $ \axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)} $
      \end{center}
\item If the last used rule is ($↑$) then we need to show
      $\v("vρ") ∈ |\f("Aρ")|$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence we can conclude using
      \thmRef("orthosimple").
      \begin{center}
        $ \unaryRN{↑}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
           Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)} $
      \end{center}
\item If the last used rule is ($↓$) then we need to show
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ |\f("Aρ")|$, hence we can conclude using
      \thmRef("orthonew").
      \begin{center}
        $ \unaryRN{↓}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)} $
      \end{center}
\item If the last used rule is ($⇒_i$) then we need to show that
      $\t("(λx t)ρ") ∈ ⟦\f("(A ⇒ B)ρ")⟧$. Let us take $v ∈ ⟦\f("Aρ")⟧$ and
      show that $\t("(tρ)[x ≔ v]") ∈ |\f("Bρ")|$. We can then conclude by
      induction hypothesis using the valuation $\subs("ρ[x ≔ v]")$.
      \begin{center}
        $ \unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)} $
      \end{center}
\item If the last used rule is ($⇒_e$) then we need to show
      $\t("(t u)ρ") = \t("tρ uρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("tρ uρ ∗ π") ∈ \dbot$. Since
      $\p("tρ uρ ∗ π") ≻ \p("uρ ∗ [tρ]π")$ and $\dbot$ is saturated, is is
      enough to show $\p("uρ ∗ [tρ]π") ∈ \dbot$. By induction hypothesis,
      we know that $\t("uρ") ∈ |\f("Aρ")|$, hence it only remains to show
      $\s("[tρ]π") ∈ ||\f("Aρ")||$. Let us now take $\v("v") ∈ ⟦\f("Aρ")⟧$
      and show that $\p("v ∗ [tρ]π") ∈ \dbot$. Since
      $\p("v ∗ [tρ]π") ≻ \p("tρ ∗ v·π")$ and $\dbot$ is saturated, it is
      enough to show that $\p("tρ ∗ v·π") ∈  \dbot$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A ⇒ B)ρ")| = |\f("Aρ ⇒ Bρ")|$, hence it only remains
      to show $\s("v·π") ∈ ||\f("Aρ ⇒ Bρ")||$. Let us now take a value
      $\v("λx f") ∈ ⟦\f("Aρ ⇒ Bρ")⟧$ and show that $\p("λx f ∗ v·π") ∈ \dbot$.
      Since $\p("λx f ∗ v·π") ≻ \p("f[x ≔ v] ∗ π")$ and $\dbot$ is saturated,
      it is enough to show that $\p("f[x ≔ v] ∗ π") ∈ \dbot$. Since
      $\s("π") ∈ ||\f("Bρ")||$ it only remains to show that
      $\t("f[x ≔ v]") ∈ |\f("Bρ")|$. This is true by definition of
      $⟦\f("Aρ ⇒ Bρ")⟧$ since $\v("v") ∈ ⟦\f("Aρ")⟧$.
      \begin{center}
        $ \binaryRN{⇒_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)} $
      \end{center}
\item If the last used rule is ($μ$) then we need to show that
      $\t("(μα t)ρ") = \t("μα tρ") ∈ |\f("Aρ")|$. Let us take
      $π ∈ ||\f("Aρ")||$ and show $\p("μα tρ ∗ π") ∈ \dbot$. Since
      $\p("μα tρ ∗ π") ≻ \p("tρ[α ≔ π] ∗ π")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ[α ≔ π] ∗ π") ∈ \dbot$. We can then conclude
      by induction hypothesis using the valuation $\subs("ρ[α ≔ π]")$.
      \begin{center}
        $ \unaryRN{μ}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)} $
      \end{center}
\item If the last used rule is ($[\wc]$) then we need to show
      $\t("([α]t)ρ") = \t("[ρ(α)]tρ") ∈ |\f("Bρ")|$. Let us take
      $π ∈ ||\f("Bρ")||$ and show $\p("[ρ(α)]tρ ∗ π") ∈ \dbot$. Since
      $\p("[ρ(α)]tρ ∗ π") ≻ \p("tρ ∗ ρ(α)")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ ∗ ρ(α)") ∈ \dbot$. By induction hypothesis,
      we know that $\t("tρ") ∈ \f("Aρ")$, hence we only need to show that
      $\s("ρ(α)") ∈ ||\f("Aρ")||$. This is true by hypothesis since we have
      $α ∈ dom(Σ, α:σ)$ and $Δ(α) = A$.
      \begin{center}
        $ \unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)}{
          Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)} $
      \end{center}
\item If the last used rule is ($∀_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(∀χ^s A)ρ")⟧$. By definition we have
      $⟦\f("(∀χ^s A)ρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$,
      hence it is enough to take $\f("B") ∈ ⟦s⟧$ and show
      $\v("vρ") ∈ ⟦\f("Aρ[χ ≔ B]")⟧$. Note that $\v("vρ") = \v("vρ[χ ≔ B]")$
      as $\f("χ")$ cannot appear in $\v("v")$ for the conclusion judgment to
      be well-formed. We conclude by induction hypothesis with the
      valuation $\subs("ρ[χ ≔ B]")$.
      \begin{center}
        $ \unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))} $
      \end{center}
\item If the last used rule is ($∀_e$) then we need to show
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(∀χ^s A)ρ")|$, hence it is enough to show
      $|\f("(∀χ^s A)ρ")| ⊆ |\f("(A[χ ≔ B])ρ")|$, or
      $⟦\f("(∀χ^s A)ρ")⟧ ⊆ ⟦\f("(A[χ ≔ B])ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume that $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("∀χ^s Aρ")⟧ ⊆ ⟦\f("Aρ[χ ≔ Bρ]")⟧$. The
      inclusion follows since
      $⟦\f("∀χ^s Aρ")⟧ = \bigcap_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∀_e}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))} $
      \end{center}
\item If the last used rule is ($∃_i$) then we need to show
      $\t("tρ") ∈ |\f("(∃χ^s A)ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[χ ≔ B])ρ")|$, hence it is enough to show
      $|\f("(A[χ ≔ B])ρ")| ⊆ |\f("(∃χ^s A)ρ")|$, or
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∃χ^s A)ρ")⟧$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume $χ ∉ dom(Σ)$,
      hence our goal rewrites to $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. Now,
      the inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_i}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))}{
          Σ ⊢ B : s}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))} $
      \end{center}
\item If the last used rule is ($∃_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("(A[χ ≔ B])ρ")⟧$ provided
      $\v("ρ(x)") ∈ ⟦\f("(∃χ^s A)ρ")⟧$. In other words, we need to show
      $⟦\f("(A[χ ≔ B])ρ")⟧ ⊆ ⟦\f("(∀χ^s A)ρ")⟧$. Up to renaming, we can
      assume $χ ∉ dom(Σ)$, hence our goal rewrites to 
      $⟦\f("Aρ[χ ≔ Bρ]")⟧ ⊆ ⟦\f("∃χ^s Aρ")⟧$. The inclusion follows since
      $⟦\f("∃χ^s Aρ")⟧ = \bigcup_{\f("B")∈⟦s⟧} ⟦\f("Aρ[χ ≔ B]")⟧$ and
      $\f("Bρ") ∈ ⟦s⟧$.
      \begin{center}
        $ \binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))}{
          Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))} $
      \end{center}
\item If the last used rule is ($∈_i$) then we need to show
      $\v("vρ") ∈ ⟦\f("(v ∈ A)ρ")⟧$. By induction hypothesis we know
      $\v("vρ") ∈ ⟦\f("Aρ")⟧$, hence it is enough to show
      $⟦\f("(v∈A)ρ")⟧ ⊆ ⟦\f("Aρ")⟧$. This is immediate as
      $⟦\f("(v∈A)ρ")⟧ = ⟦\f("vρ∈Aρ")⟧ = \{w∈⟦\f("Aρ")⟧ \st w≡\v("vρ")\}$
      by definition.
      \begin{center}
        $ \unaryRN{∈_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))} $
      \end{center}
\item If the last used rule is ($∈_e$) then we need to show
      $\t("uρ") ∈ |\f("Cρ")|$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ ⟦\f("aρ")⟧$ and that
      $\v("ρ(x)")≡\t("tρ")$, provided that we have
      $\v("xρ") ∈ ⟦\f("(t∈A)ρ")⟧$. By definition
      $⟦\f("(t∈A)ρ")⟧ = ⟦\f("tρ∈Aρ")⟧ = \{v∈⟦\f("Aρ")⟧ \st v≡\t("tρ")\}$,
      and hence $\v("ρ(x)") ∈ ⟦\f("Aρ")⟧$ and $\v("ρ(x)")≡\t("tρ")$.
      \begin{center}
        $ \unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("u") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("u") : C)} $
      \end{center}
\item If the last used rule is ($↾_i$) then we need to show
      $\t("tρ") ∈ |\f("(A | u₁≡u₂)ρ")|$. By hypothesis, we know that
      $\t("u₁ρ") ≡ \t("u₂ρ")$, and hence
      $|\f("(A|u₁≡u₂)ρ")| = |\f("Aρ | u₁ρ ≡ u₂ρ")| = |\f("Aρ")|$. As a
      consequence, we can immediatly conclude by induction hypothesis.
      \begin{center}
        $ \unaryRN{↾_i}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t") : \f("A | u₁≡u₂"))} $
      \end{center}
\item If the last used rule is ($↾_e$) then we need to show
      $\t("tρ") ∈ |\f("Cρ")|$. To be able to apply the induction hypothesis,
      we need to show that $ρ(x) ∈ ⟦\f("Aρ")⟧$ and $u₁ρ ≡ u₂ρ$ provided that
      $ρ(x) ∈ ⟦\f("(A | u₁ ≡ u₂)ρ")⟧ = ⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧ ≠ ∅$. This
      immediately follows from the definition of $⟦\f("Aρ | u₁ρ ≡ u₂ρ")⟧$
      since it is non-empty.
      \begin{center}
        $ \unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,u₁ ≡ u₂ ⊢ \t("t") : C)}{
          Σ, x:ι ⊢ (Γ,x:\f("A | u₁ ≡ u₂");Δ;Ξ ⊢ \t("t") : C)} $
      \end{center}
\item If the last used rule is ($×_i$) then we need to show
      $\v("{(li = vi) i∈I}ρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$. By definition it
      is enough to show that $\v("viρ") ∈ ⟦\f("Aiρ")⟧$ for all index $i$ in
      $I$. This exactly corresponds to the induction hypotheses.
      \begin{center}
        $ \unaryRN{×_i}{[Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))} $
      \end{center}
\item If the last used rule is ($×_e$) then we need to show that
      $\t("(v.lk)ρ") ∈ |\f("Akρ")|$. By induction hypothesis we know that
      $\v("vρ") ∈ ⟦\f("{(li : Ai) i∈I}ρ")⟧$, hence by definition
      $\v("vρ") = \v("{(li = vi) i∈I}")$ and for all index $i$ in $I$ we
      have $\v("vi") ∈ ⟦\f("Aiρ")⟧$. Let us now take $π ∈ ||\f("Akρ")||$ and
      show that $\p("{(li = vi) i∈I}.lk ∗ π") ∈ \dbot$. As $k$ is in $I$, we
      have $\p("{(li = viρ) i∈I}.lk ∗ π") ≻ \p("viρ ∗ π")$, hence it is enough
      to show $\p("vkρ ∗ π") ∈ \dbot$ as $\dbot$ is saturated. Since
      $π ∈ ||\f("Akρ")||$, we only have to show $\v("vkρ") ∈ |\f("Akρ")|$.
      We can hence conclude using \thmRef("orthosimple") since we know that
      $\v("vkρ") ∈ ⟦\f("Akρ")⟧$.
      \begin{center}
        $ \binaryRN{×_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))}{
          k∈I}{Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)} $
      \end{center}
\item If the last used rule is ($+_i$) then we need to show
      $\t("(Ck[v])ρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$. By definition we only need
      to show $\v("vρ") ∈ ⟦\f("Akρ")⟧$ since the index $k$ is in $I$. This is
      exactly the induction hypothesis.
      \begin{center}
        $ \binaryRN{+_i}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))}{k∈I}{
          Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]"))} $
      \end{center}
\item If the last used rule is ($+_e$) then we need to show
      $\t("[v | (Ci[xi] → ti) i∈I]ρ") ∈ |\f("Bρ")|$. By induction hypothesis
      we know that $\v("vρ") ∈ ⟦\f("[(Ci : Ai) i∈I]ρ")⟧$, hence by definition
      $\v("vρ") = \v("Ck[w]")$ for some index $k$ in $I$ and $w ∈ \f("Akρ")$.
      Let us now take a stack $π ∈ ||\f("Bρ")||$ and show that
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ∈ \dbot$. As
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ≻ \p("tkρ[xk≔w] ∗ π")$ and
      $\dbot$ is saturated, it is enough to show
      $\p("tkρ[xk≔w] ∗ π") ∈ \dbot$. Let us now consider the valuation
      $\subs("ρ[xk≔w]")$. Up to renaming, we can assume that $\v("xk")$ does
      not appear free in $\f("B")$, hence $\f("Bρ") = \f("Bρ[xi≔w]")$.
      Consequently we have $π ∈ ||\f("Bρ[xk≔w]")||$, hence it is enough to
      show that $\t("tkρ[xk≔w]") ∈ |\f("Bρ[xk≔w]")|$. We can conclude by
      induction hypothesis using the valuation $\subs("ρ[xk≔w]")$ since
      $\v("vρ[xk≔w]") ≡ \v("Ck[w]")$.
      \begin{center}
        $ \binaryRN{+_e}{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))}{
          [Σ, x_i : ι ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}}{
          Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)} $
      \end{center}
\item If the last used rule is ($≡_{l, {val}}$) then we need to show
      $\t("(t[x≔v₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $x ∉ dom(ρ)$, hence $\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$
      and $\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$. By hypothesis we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$, hence \thmRef("extvalue") gives us
      $\t("tρ[x≔v₁ρ]") ≡ \t("tρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[x≔v₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_{l, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ \t("t[x≔v₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_l$) then we need to show
      $\t("(t[a≔u₁])ρ") ∈ |\f("Aρ")|$. Without loss of generality we may
      assume that $a ∉ dom(ρ)$, hence $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$
      and $\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$. By hypothesis we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$, hence \thmRef("extterm") gives us
      $\t("tρ[a≔u₁ρ]") ≡ \t("tρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("eqpreserve") since we have $\t("tρ[a≔u₂ρ]") ∈ |\f("Aρ")|$
      by induction hypothesis.
      \begin{center}
        $ \unaryRN{≡_l}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)} $
      \end{center}
\item If the last used rule is ($≡_{r, {val}}$) then we need to show
      $\t("tρ") ∈ |\f("(A[x≔v₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[x≔v₂])ρ")|$ so we will show
      $|\f("(A[x≔v₁])ρ")| = |\f("(A[x≔v₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[x≔v₁])ρ")⟧ = ⟦\f("(A[x≔v₂])ρ")⟧$.
      Without loss of generality we may assume that $x ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[x≔v₁ρ]")⟧ = ⟦\f("Aρ[x≔v₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformvalue") as we have
      $\v("v₁ρ") ≡ \v("v₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_{r, {val}}}{Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,v₁≡v₂ ⊢ t : \f("A[x≔v₁]"))} $
      \end{center}
\item If the last used rule is ($≡_r$) then we need to show
      $\t("tρ") ∈ |\f("(A[a≔u₁])ρ")|$. By induction hypothesis
      $\t("tρ") ∈ |\f("(A[a≔u₂])ρ")|$ so we will show
      $|\f("(A[a≔u₁])ρ")| = |\f("(A[a≔u₂])ρ")|$. By \lemRef("orthoprop"),
      it is enough to show $⟦\f("(A[a≔u₁])ρ")⟧ = ⟦\f("(A[a≔u₂])ρ")⟧$.
      Without loss of generality we may assume that $a ∉ dom(ρ)$, hence it
      only remains to show that $⟦\f("Aρ[a≔u₁ρ]")⟧ = ⟦\f("Aρ[a≔u₂ρ]")⟧$.
      This is a direct consequence of \thmRef("extformterm") as we have
      $\t("u₁ρ") ≡ \t("u₂ρ")$ by hypothesis.
      \begin{center}
        $ \unaryRN{≡_r}{Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))}{
          Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))} $
      \end{center}
\end{itemize}
\end{proof}
\end{thm}

=<

=> Simple types

In order to prevent undesired computational behaviours such as runtime
errors, functional programming languages rely on syntactic checks. We
will first consider a small type system with only three type constructors:
functions, products (in the form of records) and sums (in the form of
variants).
\begin{def}
The set of all types $\cal{F}$ is built using the following ||bnf|| grammar.
$$ A,B ::= \f("A ⇒ B") \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")$$
\end{def}
\begin{rem}
To lighten the notations, we will consider the function type to be right
associative. That is, we will always read a type of the form
$\f("A ⇒ B ⇒ C")$ as $\f("A ⇒ (B ⇒ C)")$.
\end{rem}
Through the Curry-Howard isomorphism, it is possible to see our type system
as a logic. In particular, a type can be read as a formula in which the
arrow type corresponds to logical implication. Similarly, product and sum
types can be interpreted as logical conjunction and disjunction.

To be able to assign a type to terms containing free variables, we need to
use typing contexts. A typing context will map variables to their assumed
type. Logically, a context will simply correspond to a set of hypothesis.
That is, a set of formulas that are assumed to be true.
\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ such that for all
$λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent contexts using lists generated using the following ||bnf|| grammar.
$$ Γ ::= • \| {Γ, x : A} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgement is a triple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$ and
a context $Γ$ that is denoted $Γ ⊢ t : A$. A judgment is said to be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$ and if $FV_ι(t) ∪ FV_μ(t) = ∅$.
To lighten the notations we will write $⊢ t : A$ instead of $Γ ⊢ t : A$ when
$Γ = •$.
\end{def}
\begin{rem}
Our first type system will only be able to work with terms not containing
$μ$-variables or term variables. The mechanism for handling such variables
will be introduced in later sections.
\end{rem}
\begin{rem}
In the following, we will only consider well-formed judgements. This
information will be kept implicit most of the time.
\end{rem}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B")}{Γ ⊢ u : A}{Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]")}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
\end{def}
\begin{rem}
The derivability of a judgement $⊢ t : A$ is equivalent to the provability
of the logical formula corresponding to $A$ in intuitionistic propositional
logic. As $t$ alone sufices to recover the derivation (only one rule can be
applied for every term constructor), we may think of it as a proof of $A$.
Consequently, we associate a computational behavious to a proof. For example,
a term $t$ of type $\f("A ⇒ B")$ will correspond to a procedure turning a
proof of the formula $A$ into a proof of the formula $B$.
\end{rem}

Let us now consider a few examples of typing derivations. First, we can show
that the term $t = \t("λf λx λy f {l₁ = x; l₂ = y;}")$ has type
$\f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")$ for any given types $A$, $B$
and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx λy f {l₁ = x; l₂ = y;}")
     : \f("({l₁ : A; l₂ : B;} ⇒ C) ⇒ A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C") ⊢ \t("λx λy f {l₁ = x; l₂ = y;}")
     : \f("A ⇒ B ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A ⊢ \t("λy f {l₁ = x; l₂ = y;}")
     : \f("B ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("f {l₁ = x; l₂ = y;}") : C
   }{
     \axiomN{Ax}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ f
         : \f("{l₁ : A; l₂ : B;} ⇒ C")
     }
   }{
     \binaryN{×_i}{
       f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ \t("{l₁ = x; l₂ = y;}")
         : \f("{l₁ : A; l₂ : B;}")
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ x : A
       }
     }{
       \axiomN{Ax}{
         f : \f("{l₁ : A; l₂ : B;} ⇒ C"), x:A, y:B ⊢ y : B
       }
     }
   }
  }}}}
$$
\end{env}
Similarly, we can show that the term $u = \t("λf λx f x.l₁ x.l₂")$ is also
typable. It can be given the type $\f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")$
for any given types $A$, $B$ and $C$.
\begin{env}(scale 0.52)
$$
\proofTree{
 \unaryN{⇒_i}{
   ⊢ \t("λf λx f x.l₁ x.l₂") : \f("(A ⇒ B ⇒ C) ⇒ {l₁ : A; l₂ : B;} ⇒ C")
 }{
 \unaryN{⇒_i}{
   f : \f("A ⇒ B ⇒ C") ⊢ \t("λx f x.l₁ x.l₂") : \f("{l₁ : A; l₂ : B;} ⇒ C")
 }{
   \binaryN{⇒_e}{
     f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁ x.l₂") : C
   }{
     \binaryN{⇒_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("f x.l₁")
         : \f("B ⇒ C")
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ f
           : \f("A ⇒ B ⇒ C")
       }
     }{
       \unaryN{×_e}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₁") : A
       }{
         \axiomN{Ax}{
           f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
             : \f("{l₁ : A; l₂ : B;}")
         }
       }
     }
   }{
     \unaryN{×_e}{
       f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ \t("x.l₂") : B
     }{
       \axiomN{Ax}{
         f : \f("A ⇒ B ⇒ C"), x : \f("{l₁ : A; l₂ : B;}") ⊢ x
           : \f("{l₁ : A; l₂ : B;}")
       }
     }
   }
  }}}
$$
\end{env}
The terms $t$ and $u$ correspond respectively to the curryfication operation
and its inverse. The former turns a function taking as input a couple into
a function of two arguments, and the latter turns a function of two arguments
into a function taking as input a couple. Logically, these terms correspond
to both sides of a proof of the following theorem of intuitionistic
propositional logic.
$$ (A \land B → C) ↔ (A → B → C) $$

In the next two sections, we will present two rather orthogonal extensions
of our small type system. The former will provide a mechanism for handling
terms of the \lmcalc, which will allow us to type more terms of our language
and will enable classical reasoning.
(* *)
The second extension will be System F polymorphism, and it will allow
universal quantification over a type. Our system will then correspond
to predicate logic.

=<

=> First extension: \lmcalc and classical logic

We are now going to extend our type system with a mechanism for typing terms
of the \lmcalc, and not only terms of the $λ$-calculus. The \lmcalc provides
control structures, which have been shown to give a computational
interpretation to classical logic by Timothy Griffin \cite("Griffin1990"). As
a consequence, the obtained system will not be limited to intuitionistically
provable formulas anymore.

\begin{def}
A continuation context is a finite map $Δ$ over $\cal{V}_μ$ such that for all
$μ$-variable $α ∈ dom(Δ)$ we have $Δ(α) ∈ \cal{F}$. As for typing contexts,
we will represent continuation contexts using lists generated by the
following ||bnf|| grammar.
$$ Δ ::= • \| {Γ, α : A} $$
We will implicitly consider that variables can only be mapped once in a
continutation context, and that their order is not relevant.
\end{def}

\begin{def}
A typing judgement is a tuple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$, a
typing context $Γ$ and a continuation context $Δ$ that is denoted
$Γ ⊢ t : A; Δ$. A judgment is said to be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) ⊆ dom(Δ)$ and if $FV_ι(t) = ∅$. To lighten the
notations we will write $⊢ t : A; Δ$ (resp. $Γ ⊢ t : A$) instead of
$Γ ⊢ t : A; Δ$ when $Γ = •$ (resp. $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A; Δ}
  \hspace(1.6)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B; Δ}{Γ ⊢ \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(1.6)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B"); Δ}{Γ ⊢ u : A; Δ}{Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i; Δ]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}"); Δ}{Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j; Δ}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"); Δ}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
\end{def}

As an example, the following type derivation shows that the term
$\t("λf μα f λx [α]x")$ can be given a type corresponding to Peirce's Law.
This formula is not intuitionistically provable, and thus this type cannot
be inhabited by a term of the $λ$-calculus.
\begin{env}(scale 0.92)
$$
  \proofTree{
    \unaryN{⇒_i}{
      ⊢ \t("λf μα f λx [α]x") : \f("((A ⇒ B) ⇒ A) ⇒ A")
    }{
      \unaryN{μ}{
        f:\f("(A ⇒ B) ⇒ A") ⊢ \t("μα f λx [α]x") : A
      }{
        \binaryN{⇒_e}{
          f:\f("(A ⇒ B) ⇒ A") ⊢ \t("f λx [α]x") : A; α:A
        }{
          \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A") ⊢ f : \f("(A ⇒ B) ⇒ A"); α:A}
        }{
          \unaryN{⇒_i}{
            f:\f("(A ⇒ B) ⇒ A") ⊢ \t("λx [α]x") : \f("A ⇒ B"); α:A
          }{
            \unaryN{[{-}]}{
              f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ \t("[α]x") : A; α : A
            }{
              \axiomN{Ax}{f:\f("(A ⇒ B) ⇒ A"), x:A ⊢ x : A; α:A}
            }
          }
        }
      }
    }
  }
$$
\end{env}

=<

=> Second extension: polymorphism and universal quantification

We will now define a second extension of our type system, which will provide
us with more expressive types. Let us consider the term $\t("λx λy x")$,
which can be given type $\f("X ⇒ Y ⇒ X")$ given two types $X$ and $Y$.
$$
\proofTree{
  \unaryN{⇒_i}{⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
  \unaryN{⇒_i}{x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
    \axiomN{Ax}{x : X, y : Y ⊢ x : X}
  }}
}
$$
The term $\t("λx λy x")$ really corresponds to a function taking as input
two arguments, and returning the first one directly. Note that we do not need
to say anything about the nature of the arguments this function may accepts.
In fact, this function can be applied to arguments of any two types. This
information is not conveyed by the type $\f("X ⇒ Y ⇒ X")$, as it only
specifies that the function takes arguments of two particular types $X$ and
$Y$, and returns an element of type $X$.

To solve this expressivity problem, we extend our type system with a new
type constructor for universal quantification, or polymorphism. We will then
be able to use types like $\f("∀X ∀Y X ⇒ Y ⇒ X")$. The obtained system is
called System F, it was introduced by Jean-Yves Girard and John Reynolds
independently \mcite(["Girard1972";"Reynolds1974"]).

\begin{def}
The set of all types (or formulas) $\cal{F}$ is now built from a countable
set of type variables $\cal{V}_ο = \{X, Y, Z...\}$ using the following
||bnf|| grammar.
\Caml(
let _ = sidenote
  << $ A,B ::= \f("X") \| \f("A ⇒ B") \| \f("∀X A") \|
    \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]") $ >>
  << $ X ∈ \cal{V}_ο $ >>
)
We denote $FV_ο(A)$ the set of free type variables contained in $A$. Given
a typing context $Γ$ we will write $FV_ο(Γ)$ the set of free type variables
contained in the types of $Γ$.
\end{def}
\begin{rem}
To lighten the notations, we will consider that universal quantification
binds stronger than the function type. As a consequence, we will read
$\f("∀X ∀Y X ⇒ Y ⇒ X")$ as $\f("∀X (∀Y (X ⇒ (Y ⇒ X)))")$.
\end{rem}

As types can now contain free variables, our typing judgments will carry
a list of type variables with the invariant that only these type variables
can appera free in the judgement.
\begin{def}
A type variable context is a finite set of type variables denoted $Σ$. For
convenience, we will represent type variable contexts using lists generated
using the following ||bnf|| grammar.
\Caml(let _ = sidenote << $ Σ ::= • \| {Σ, X} $ >> << $ X ∈ \cal{V}_ο $ >>)
However, we need to keep in mind that type variables can only appear once
in a type variable context, and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgment is a quadruple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$,
a typing context $Γ$ and a type variable context $Γ$ that is denoted
$Σ; Γ ⊢ t : A$. A judgment is sait do be //well-formed// if
$FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) = ∅$, $FV_ι(t) = ∅$, $FV_ο(A) ⊆ Σ$ and
$FV_ο(Γ) ⊆ Σ$. To lighten the notations we will write $Γ ⊢ t : A$ (resp.
$Σ ⊢ t : A$, resp. $⊢ t : A$) instead of $Σ; Γ ⊢ t : A$ when $Γ = •$ (resp.
$Δ = •$, resp. $Γ = •$ and $Δ = •$).
\end{def}

\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system. Note that a rule only
applies if all the involved judgments are well-formed.
$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢ x : A}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B}{Σ; Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(4.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B")}{Σ; Γ ⊢ u : A}{Σ; Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢ v_i : A_i]_{i∈I}}{
    Σ; Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ; Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Σ; Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢ v : A_j)}{
    Σ ⊢ (Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]"))}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
$$
  \unaryRN{{∀}_i}{Σ, X; Γ ⊢ t : A}{Σ; Γ ⊢ t : \f("∀X A")}
  \hspace(4.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A")}{Σ; Γ ⊢ t : \f("A[X≔B]")}
$$
\end{def}
\begin{rem}
The condition on the well-formedness of all the judgments imply that the
$∀_i$ rule may only apply when $X ∉ FV_ο(Γ)$. If it were not the case then
the conclusion judgments of the rule could not be well-formed.
\end{rem}

As an example, the proof that $\t("λx λy x")$ has type $\f("∀X ∀Y X ⇒ Y ⇒ X")$
can be derived as follows in the system. Note that this type is fully
specified, in the sense that we did not say anything like
"for all given types".
$$
  \proofTree{
    \unaryN{∀_i}{⊢ \t("λx λy x") : \f("∀X ∀Y X ⇒ Y ⇒ X")}{
    \unaryN{∀_i}{X ⊢ \t("λx λy x") : \f("∀Y X ⇒ Y ⇒ X")}{
      \unaryN{⇒_i}{X, Y ⊢ \t("λx λy x") : \f("X ⇒ Y ⇒ X")}{
        \unaryN{⇒_i}{X, Y; x : X ⊢ \t("λy x") : \f("Y ⇒ X")}{
          \axiomN{Ax}{X, Y; x : X, y : Y ⊢ x : X}
  }}}}}
$$

It would seem that polymophism and classical logic are two rather orthogonal
extensions of the simple system. However, we will see in the next section that
they actually interact in a very subtle way. Indeed, the naive approach breaks
the type safety and the consistency of the system. More generally, the
problem is related to call-by-value evaluation and side-effects. Historicaly,
it was first identified in the context of ||ml||.

=<

=> A brief history of ||ml|| and value restriction

A soundness issue related to side-effects and call-by-value evaluation
arose in the seventies with the advent of ML. The problem stems from a
bad interaction between side-effects and Hindley-Milner polymorphism. It was
first formulated in terms of references \citen("Wright1995")("Section 2").
To extend ||ml|| with reference, the naive approach consist in providing the
following three primitive polymorphic procedures (in ||OCaml|| syntax).
### OCaml
  val ref  : 'a -> 'a ref
  val (:=) : 'a ref -> 'a -> unit
  val (!)  : 'a ref -> 'a
###
However, this leads to trouble when working with references of a polymorphic
type. The problem is demonstrated by the following example, which is accepted
by the naive extension of the type system.
### OCaml
  let l = ref [] in
  l := [true]; (List.hd !l) + 1
###
On the first line, variable ##l## is given the polymorphic type
##'a list ref##, which can be unified both with ##bool list ref## and
and ##int list ref## on the second line. This is an obvious violation of
type safety, which is the purpose of a type system.

To solve the problem, many alternative type systems were designed (e.g.
\mcite(["Tofte1990"; "Damas1982"; "Leroy1991"; "Leroy1993"])). However, they
all introduced a complexity that contrasted with the elegance and simplicity
of ||ml|| systems (see \citen("Wright1995")("Section 2") and
\citen("Garrigue2004")("Section 2") for a detailed account).
(* *)
A simple and elegant solution was finally found by Andrew Wright in the
nineties. He suggested restricting generalization (i.e. introduction of
polymorphism) to syntactic values \mcite(["Wright1994";"Wright1995"]).

In ||ml||, generalization usually happens in expressions of the form
##let x = u in t##, called let-bindings. The type-checking of such an
expression proceeds by infering the type of the term ##u##, which may
contain unification variables. The type of ##u## is then generalized by
introducing universal quantification over the unification variables.
Finally, the term ##t## is type-checked under the assumption that ##x##
has the most general type of ##u##. With value restriction, the
generalization of the type of ##u## only happens if ##u## is a
syntactic value. Consequently, the example above is rejected since
##ref []## is not a value, and hence its infered type ##'_a list ref##
is only weakly polymorphic. Thus, it cannot be unified with both
##bool list ref## and ##nat list ref##.

In this thesis, we consider control structures, which have been shown to
give a computational interpretation to classical logic by Timothy Griffin
\cite("Griffin1990"). One way of extending ||ml|| with control structures
is to introduce the following two primitive polymorphic procedures.
### OCaml
  val callcc : ('a cont -> 'a) -> 'a
  val throw  : 'a cont -> 'a -> 'b
###
The function ##callcc## corresponds to the control operator //call/cc//,
which was first introduced in the //Scheme// programming language. When
called, this function saves the current continuation (i.e. the current
state of the programs environment) and feeds it to the function it is
given as an argument. The continuation can be restored in the body of
this function using the ##throw## function.

In 1991, Robert Harper and Mark Lillibridge found a complex program
breaking the type safety of ||ml|| with //call/cc// \cite("Harper1991").
### OCaml
  let c = callcc
    (fun k -> ((fun x -> x), (fun f -> throw k (f, (fun _ -> ())))))
  in print_string ((fst c) "Hello world!"); (snd c) (fun x -> x+2)
###
Intuitively, this program saves the continuation and then builds a couple
##c## containing two functions. The first one is simply the identity
function. The second one takes a function ##f## as argument, uses
##throw## to restore the previously saved continuation and replaces the
two functions by ##f## and a constant function returning the only value
of type ##unit##. Consequently, the first element of the couple ##c## can
be used as the identity function as long as the second element of ##c##
has not been used. If the second element of ##c## is called with a
function ##g##, then ##g## becomes the first element of ##c## and the
computation restarts. This leads to a crash since the function
##fun x -> x+2## is applied to a value of type ##string##.

The infered type for ##c## is ##('_a -> '_a) * (('_a -> '_a) -> unit)##
prior to generalization. This means that without value restriction, the
last line of the example is type-checked in a context where ##c## has
the polymorphic type ##('a -> 'a) * (('a -> 'a) -> unit)##. As a
consequence, the type ##'a -> 'a## can be unified with
##string -> string## and ##int -> int##. As with references, value
restriction solves the inconsistency and yields a sound type system. 
Indeed, ##'_a -> '_a## cannot be unified with ##string -> string## and
with ##int -> int## at the same time.

It is relatively easy to translate the counter example of Robert Harper
and Mark Lillibridge into our language. Indeed, a term of the form
##callcc (fun k -> t)## will be translated into $\t("μα t")$ where $t$
is the translation of ##t## in which every subterm of the form
##throw k u## has replaced by $\t("[α]u")$.
In the context of the \lmcalc, the soundness issue arises when evaluating
$\t("t μα u")$ when $\t("μα u")$ has a polymorphic type. Such a situation
cannot happen with value restriction since $\t("μα u")$ is not a value.

=<

=> Encoding value restriction

As mentioned in the previous section, the languages of the ||ml|| family
need a restriction on polymorphism to remain type-safe. With the value
restriction, the typing rule for ||ml|| polymorphism becomes the following.
$$ \ternaryR{Γ ⊢ v : B}{Γ, x : ∀X₁,...,X_n B ⊢ t : A}{v value}
    {Γ ⊢ let x = v in t : A} $$
When the value that is bound by a let-binding is not a value its type is
not generalized and the following rule applies.
$$ \binaryR{Γ ⊢ u : B}{Γ, x : B ⊢ t : A}{Γ ⊢ let x = u in t : A} $$

In slightly more expressive type systems like System F, the value
restriction appears in the typing rule for the introduction of the
universal quantifier. The ususal typing rule
$$ \binaryRN{∀_i}{Σ,X;Γ ⊢ t:A}{X ∉ FV(Γ)}{Σ; Γ ⊢ t : ∀X A} $$
cannot be proved safe (in a call-by-value system with side-effects) if
$t$ is not a syntactic value. This will also be the case in our system
when we bring together polymorphism and the \lmcalc.

\begin{def}
A value judgement (resp. term judgment) is a tuple of a value $v ∈ Λ_{val}$
(resp. a term $t ∈ Λ$), a type $A ∈ \cal{F}$, a typing context $Γ$, a
continuation context $Δ$ and a type variable context $Σ$ that is denoted
$Σ; Γ ⊢_\tval v : A; Δ$ (resp. $Σ; Γ ⊢ t : A; Δ$). A judgment is sait do be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$, $FV_μ(t) ⊆ dom(Δ)$, $FV_ι(t) = ∅$,
$FV_ο(A) ⊆ Σ$, $FV_ο(Γ) ⊆ Σ$ and $FV_ο(Δ) ⊆ Σ$. To lighten the notations,
we will sometimes ommit empty contexts.
\end{def}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system. Note that a rule only
applies if all the involved judgments are well-formed.
$$
  \axiomRN{Ax}{Σ; Γ, x : A ⊢_\tval x : A; Δ}
  \hspace(4.0)
  \unaryRN{↑}{Σ;Γ ⊢_\tval v : A; Δ}{Σ;Γ ⊢ v : A; Δ}
$$
$$
  \unaryRN{{→}_i}{Σ; Γ, x : A ⊢ t : B; Δ}{
    Σ; Γ ⊢_\tval \t("λx t") : \f("A ⇒ B"); Δ}
  \hspace(4.0)
  \binaryRN{{→}_e}{Σ; Γ ⊢ t : \f("A ⇒ B"); Δ}{Σ; Γ ⊢ u : A; Δ}{
    Σ; Γ ⊢ \t("t u") : B; Δ}
$$
$$
  \unaryRN{μ}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("μα t") : A; Δ}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ ⊢ t : A; α : A, Δ}{Γ ⊢ \t("[α]t") : B; α : A, Δ}
$$
$$
  \unaryRN{×_i}{[Σ; Γ ⊢_\tval v_i : A_i; Δ]_{i∈I}}{
    Σ; Γ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"); Δ
  }
  \hspace(4.0)
  \unaryRN{×_e}{Σ;Γ ⊢_\tval v : \f("{(li : Ai) i∈I}"); Δ}{
    Σ;Γ ⊢ \t("v.lj") : A_j; Δ}
$$
$$
  \unaryRN{+_i}{Σ ⊢ (Γ ⊢_\tval v : A_j; Δ)}{
    Σ ⊢ (Γ ⊢_\tval \v("Cj[v]") : \f("[(Ci : Ai) i∈I]")); Δ}
$$
$$
  \binaryRN{+_e}{Σ; Γ ⊢_\tval v : \f("[(Ci : Ai) i∈I]"); Δ}{
    [Σ; Γ, x_i : A_i ⊢ t_i : B; Δ]_{i∈I}
  }{
    Σ; Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B; Δ
  }
$$
$$
  \unaryRN{{∀}_i}{Σ, X; Γ ⊢_\tval v : A; Δ}{Σ; Γ ⊢_\tval v : \f("∀X A"); Δ}
  \hspace(4.0)
  \unaryRN{{∀}_e}{Σ; Γ ⊢ t : \f("∀X A"); Δ}{Σ; Γ ⊢ t : \f("A[X≔B]"); Δ}
$$
\end{def}
Here again, the $∀_i$ rule does not apply if $X ∈ FV_ο(Γ)$ or $X ∈ FV_ο(Δ)$.
\begin{rem}
The $↑$ rule is essential for building proofs. It arises naturally as values
are terms, and hence a value judgement subsumes the corresponding term
judgment.
\end{rem}

As an example, we can derive again the type of $\t("λf μα f λx [α]x")$ as
follows. Its type still corresponds to Peirce's Law, but we are now able to
polymorphism.
\begin{env}(scale 0.86)
$$
  \proofTree{
    \unaryN{∀_i}{⊢ \t("λf μα f λx [α]x") : \f("∀X ∀Y ((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{∀_i}{X ⊢ \t("λf μα f λx [α]x") : \f("∀Y ((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{⇒_i}{X,Y ⊢ \t("λf μα f λx [α]x") : \f("((X ⇒ Y) ⇒ X) ⇒ X")}{
    \unaryN{μ}{X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("μα f λx [α]x") : X}{
      \binaryN{⇒_e}{
        X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("f λx [α]x") : X; α:X
      }{
        \axiomN{Ax}{X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ f : \f("(X ⇒ Y) ⇒ X"); α:X}
      }{
        \unaryN{⇒_i}{
          X,Y; f:\f("(X ⇒ Y) ⇒ X") ⊢ \t("λx [α]x") : \f("X ⇒ Y"); α:X
        }{
          \unaryN{[{-}]}{
            X,Y; f:\f("(X ⇒ Y) ⇒ X"), x:X ⊢ \t("[α]x") : X; α : X
          }{
            \axiomN{Ax}{X,Y; f:\f("(X ⇒ Y) ⇒ X"), x:X ⊢ x : X; α:X}
          }
        }
      }
  }}}}}
$$
\end{env}

=<

=> Higher-order type system

In this section, we present the higher-order type system that will serve as
a base for the work presented in this thesis. Although the following extends
definitions given in the previous sections, we choose not to avoid
repetitions so that this section remains completely self-contained.

We here consider a type system that is very similar to the type system of
the functional languages of the ||ml|| family (e.g. SML or OCaml). It will
provide a product type for records, a sum type for polymorphic variants,
polymorphism and higher-order quantification, least and greatest fixpoints.
The higher-order features of the system will allow us to define types using
functions taking as arguments types or other functions. This leads to a
system in which it is syntactically correct to use a type function as a
type, although it does not make sense. To solve this problem, the usual
approach is to assign a form of type (called sort) to the types themselves.
\begin{def}
The set $\cal{S}$ of all the sorts is generated using the following ||bnf||
grammar, where $ο$ denotes the sort of propositions.
$$ s,r ::= ο \| {s→r} $$
\end{def}
\begin{def}
The set of types (or formulas) is built from a countable set of
variables $\cal{V} = \{χ... X, Y, Z ...\}$ containing the set of
propositional variables $\cal{V}_ο = \{X, Y, Z...\}$. It is generated
using the following ||bnf|| grammar.
$$
  A,B ::= \f("χ") \| \f("(χ^s ↦ A)") \| \f("A(B)") \| \f("A ⇒ B") \|
          \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]") \mbr 
          \| \f("∀χ^s A") \| \f("∃χ^s A") \| \f("μX A") \| \f("νX A")
$$
\end{def}
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, sorting contexts are
represented using comma-separated lists of sort assignments of the form
$χ : s$. variable of $\cal{V}$ are mapped at most onces in a sorting context,
and their order is irrelevant.
\end{def}

\begin{def}
A sorting judgment is a triple of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the following deduction rules.
$$
\axiomR{Σ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ ↦ A)") : s → r}
\hspace(3.0)
\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}
$$
$$
\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f("A ⇒ B") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}
$$
$$
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∀χ A") : r}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∃χ A") : r}
\hspace(3.0)
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("μX A") : ο}
$$
$$
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("νX A") : ο}
$$
\end{def}

\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ and $\cal{V}_μ$ such
that for all $λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$ and for all
$μ$-variable $α ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent typing contexts using comma-separated lists of mappings generated
of the form $x : A$ or $α : A^⊥$. Note that variables can only be mapped once
in a typing context, and that their order is irrelevant.
\end{def}
\begin{def}
A typing context $Γ$ is said to be valid under a sorting context $Σ$ if for
all mapping $x:A$ or $α:A^⊥$ in $Γ$ the judgment $Σ ⊢ Γ(x) : ο$ is valid. If
$Γ$ is valid under $Σ$ then we write $Σ ⊢ Γ$.
\end{def}

(* Typing rules. *)
$$
  \axiomRN{Ax}{Γ, x : A ⊢_\tval x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢_\tval λx t: A ⇒ B}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : A ⇒ B}{Γ ⊢ u : A}{Γ ⊢ (t) u : B}
$$
$$
  \unaryRN{↑}{Γ ⊢_\tval v : A}{Γ ⊢ v : A}
  \hspace(4.0)
  \unaryRN{μ}{Γ, α : ¬A ⊢ t : A}{Γ ⊢ μα t : A}
  \hspace(4.0)
  \unaryRN{[{-}]}{Γ, α : ¬A ⊢ t : A}{Γ, α : ¬A  ⊢ [α] t : B}
$$
$$
  \binaryRN{∀_i}{Γ, X_n ⊢_\tval v : A}{X_n ∉ FV(Γ)}{Γ ⊢_\tval v : ∀X_n A}
  \hspace(4.0)
  \unaryRN{∀_e}{Γ ⊢ t : ∀X_n A}{Γ ⊢ t : A[X_n := P_n]}
$$
$$
  \unaryRN{∃_i}{Γ ⊢ t : A[X_n := P_n]}{Γ ⊢ t : ∃X_n A}
  \hspace(4.0)
  \binaryRN{∃_e}{Γ, X_n, x : A ⊢ t : B}{X_n ∉ FV(Γ,B)}{Γ, x : ∃X_n A ⊢ t : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢_\tval v_i : A_i]_{1≤i≤n}}{
    Γ ⊢_\tval \{l_i = v_i\}_{1≤i≤n} : \{l_i : A_i\}_{1≤i≤n}
  }
  \hspace(4.0)
  \unaryRN{×_e}{Γ ⊢_\tval v : \{l_i : A_i\}_{1≤i≤n}}{Γ ⊢ v{.}l_i : A_i}
$$
$$
  \unaryRN{+_i}{Γ ⊢_\tval v : A_i}{Γ ⊢ C_i[v] : [C_i : A_i]_{1≤i≤n}}
  \hspace(1.0)
  \binaryRN{+_e}{Γ ⊢_\tval v : [C_i : A_i]_{1≤i≤n}}{
    [Γ, x_i : A_i ⊢ t_i : B]_{1≤i≤n}
  }{
    Γ ⊢ case_v [C_i[x_i] → t_i]_{1≤i≤n} : B
  }
$$


(* Sorting rules. *)
$$
\binaryR{Δ ⊢ A : ο}{Δ ⊢ B : ο}{Δ ⊢ A ⇒ B : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ \{l_i : A_i\}_{i∈I} : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ [C_i : A_i]_{i∈I} : ο}
$$
$$
\axiomR{Δ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ E : r}{Δ ⊢ (χ^s ↦ E) : s → r}
\hspace(3.0)
\binaryR{Δ ⊢ E : s → r}{Δ ⊢ F : s}{Δ ⊢ E(F) : r}
$$
$$
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∀χ^s A : ο}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∃χ^s A : ο}
$$
$$
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ μX A : ο}
\hspace(3.0)
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ νX A : ο}
$$
(* TODO *)



=<

=> Call-by-value realisability model

The abstract machine presented in \chapter("calculus") is part of a
//classical realizability// machinery that will be built upon here.
We aim at obtaining a semantical interpretation of our higher-order
type system. As always in classical realizability, the model is
parametrized by a pole, which serves as an exchange point between
the world of programs and the world of execution contexts, which are
represented as stacks.
\begin{def}
A //pole// is a set of processes $\dbot ⊆ Λ×Π$ which is //saturated//
(i.e. closed under backward reduction). More formally, if we have
$q ∈ \dbot$ and $p ≻ q$ then $p ∈ \dbot$.
\end{def}

The notion of //orthogonality// is central in Krivine's classical
realizability. In this framework a type is interpreted (or realized) by
programs computing corresponding values. This interpretation is spread
in a three-layered construction, even though it is fully determined by
the first layer and the choice of the pole. The first layer consists of
a set of values that we will call the //raw semantics//. It gathers all
the syntactic values that should be considered as having the corresponding
type. As an example, if we were to consider the type of natural numbers,
its raw semantics would be the set $\{\hat{n} \| n ∈ \bbN\}$ where
$\hat{n}$ is some encoding of $n$.
(* *)
The second layer, called //falsity value//, is a set containing every
stack that is a candidate for building a valid process using any value
from the raw semantics. The notion of validity depends on the choice of
the pole. The third layer, called //truth value// is a set of terms that
is built by iterating the process once more. The formalism for the two
levels of orthogonality is given in the following definition.
\begin{def}\label("orthodef")
For every set $Φ ⊆ Λ_{val}$ we define a set $Φ^\bot ⊆ Π$ and a set
$Φ^{\bot\bot} ⊆ Λ$ as follows.
$$
  Φ^\bot = \{π∈Π \| ∀v∈Φ \p("v ∗ π") ∈ \dbot\}
  \hspace(3.0)
  Φ^{\bot\bot} = \{t∈Λ \| ∀π∈Φ^\bot \p("t ∗ π") ∈ \dbot\}
$$
\end{def}

We now give two general properties of orthogonality that are true in
every classical realizability model. They will be useful when proving
the soundness of our type system.
\begin{lem}\label("orthosimple")
If $Φ ⊆ Λ_{val}$ is a set of values, then $Φ ⊆ Φ^{\bot\bot}$.
\begin{proof}
We take $v ∈ Φ$ and show $v ∈ Φ^{\bot\bot}$. By definition we need to
show $\p("v∗π") ∈ \dbot$ for all stack $π ∈ Φ^\bot$. This is immediate
by definition of $Φ^\bot$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclstack")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If $Φ ⊆ Ψ$ then
$Ψ^\bot ⊆ Φ^\bot$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$, take $π ∈ Ψ^\bot$ and show that $π ∈ Φ^\bot$.
By definition, we know that for all $v ∈ Ψ$ we have $\p("v ∗ π") ∈ \dbot$.
Since $Φ ⊆ Ψ$, this is also true for all $v ∈ Φ$, and hence $π ∈ Φ^\bot$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclterm")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If
$Ψ^\bot ⊆ Φ^\bot$ then $Φ^{\bot\bot} ⊆ Ψ^{\bot\bot}$.
\begin{proof}
Let us suppose that $Ψ^⊥ ⊆ Φ^⊥$, take $t ∈ Φ^{⊥⊥}$ and show that
$t ∈ Ψ^{⊥⊥}$. By definition, we know that for all $π ∈ Φ^⊥$ we have
$\p("t ∗ π") ∈ \dbot$. Since $Ψ^⊥ ⊆ Φ^⊥$, this is also true for all
$π ∈ Ψ^⊥$, and hence $t ∈ Ψ^{⊥⊥}$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoblabla")
Let $Φ ⊆ Λ_{val}$ and $Ψ ⊆ Λ_{val}$ be two sets of values. If $Φ ⊆ Ψ$ then
$Φ^{\bot\bot} ⊆ Ψ^{\bot\bot}$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$ and apply \lemRef("orthoinclstack") to obtain
$Ψ^⊥ ∈ Φ^⊥$. We can then conclude using \lemRef("orthoinclterm").
\end{proof}
\end{lem}

When choosing a pole, it is important to check that it does not yield a
degenerate model. In particular we need to check that no term is able to
face every stacks. If it were the case, such a term could be use as a
proof of $⊥$.
\begin{def}
A pole $\dbot ⊆ Λ×Π$ is said to be consistent if for every closed term
$t ∈ Λ$ there is a stack $π$ such that $\p("t ∗ π") ∉ \dbot$.
\end{def}


(*
Here, for the sake of simplicity and brevity, we are only going to use the
$$ \dbot = \{p \in \Lambda\times\Pi \;|\; p \converge_\red \} $$
which is clearly saturated. Note that this particular pole is also closed
under the reduction relation $(\red)$, even though this is not a general
property. In particular $\dbot$ contains all final processes.

The construction involving the terms of the form $\delta_{v,x}$ and
$(\equiv)$ in the previous section is now going to gain meaning. The
following theorem, which is our central result, does not hold in every
classical realizability model. Obtaining a proof required us to internalize
observational equivalence, which introduces a non-computable reduction
rule.
\begin{theorem}\label{biortho}
If $\Phi \subseteq \Lambda_v$ is a set of values closed under $(\equiv)$, then
$\Phi^{\bot\bot} \cap \Lambda_v = \Phi$.
\end{theorem}
\begin{proof}
The direction $\Phi \subseteq \Phi^{\bot\bot} \cap \Lambda_v$ is
straight-forward using lemma \ref{orthosimple}. We are going to
show that $\Phi^{\bot\bot} \cap \Lambda_v \subseteq \Phi$, which amounts to
showing that for every value $v \in \Phi^{\bot\bot}$ we have $v \in \Phi$.
We are going to show the contrapositive, so let us assume $v \not\in \Phi$ and
show $v \not\in \Phi^{\bot\bot}$. We need to find a stack $\pi_0$ such that
$v \ast \pi_0 \not\in \dbot$ and for every value $w \in \Phi$,
$w \ast \pi_0 \in \dbot$. We take $\pi_0 = [\lambda x\;\delta_{x,v}]\;\alpha$
and show that is is suitable. By definition of the reduction relation
$v \ast \pi_0$ reduces to $\delta_{v,v} \ast \alpha$ which is not in $\dbot$
(it is stuck as $v \equiv v$ by reflexivity). Let us now take $w \in \Phi$.
Again by definition, $w \ast \pi_0$ reduces to $\delta_{w,v} \ast \alpha$,
but this time we have $w \not\equiv v$ since $\Phi$ was supposed to be closed
under $(\equiv)$ and $v \not\in \Phi$. Hence $w \ast \pi_0$ reduces to
${w \ast \alpha} \in \dbot$.
\end{proof}
\medskip

It is important to check that the pole we chose does not yield a degenerate
model. In particular we check that no term is able to face every stacks. If
it were the case, such a term could be use as a proof of $\bot$.
\begin{theorem}\label{poleconsist}
The pole $\dbot$ is consistent, which means that for every closed term $t$
there is a stack $\pi$ such that $t \ast \pi \not\in \dbot$.
\end{theorem}
\begin{proof}
Let $t$ be a closed term and $\alpha$ be a stack constant. If we do not have
$t \ast \alpha \converge_\red$ then we can directly take $\pi = \alpha$.
Otherwise we know that $t \ast \alpha \reds v \ast \alpha$ for some value
$v$. Since $t$ is closed $\alpha$ is the only available stack variable. We now
show that $\pi = [\lambda x\;\{\}]\{\}.\beta$ is suitable. We denote $\sigma$
the substitution $[\alpha := \pi]$. Using a trivial extension of lemma
\ref{redcompatall} to the $(\red)$ relation we obtain $t \ast \pi = (t \ast
\alpha)\sigma \reds (v \ast \alpha)\sigma = v\sigma \ast \pi$. We hence have
$t \ast \pi \reds v\sigma \ast [\lambda x\;\{\}]\{\}.\beta \red^2 \{\} \ast
\{\}.\beta \not\in \dbot$.
\end{proof}
\medskip

\subsection{Formulas and their semantics}

In this paper we limit ourselves to second-order logic, even though the system
can easily be extended to higher-order. For every natural number $n$ we
require a countable set ${\mathcal{V}}_n = \{{X}_n, {Y}_n, {Z}_n ...\}$ of
$n$-ary predicate variables.
\begin{definition}
The syntax of formulas is given by the following grammar.
\begin{align*} 
A,B
  \bnfeq &{X}_n(t_1, ..., t_n)
  \bnfor A \Rightarrow B
  \bnfor \forall a\; A
  \bnfor \exists a\; A
  \bnfor \forall X_n\; A
  \bnfor \exists X_n\; A
\\
  \bnfor &\{l_i : A_i\}_{i \in I}
  \bnfor [C_i : A_i]_{i \in I}
  \bnfor t \in A
  \bnfor A \restriction t \equiv u
\end{align*}
\end{definition}
Terms appear in several places in formulas, in particular, they form the
individuals of the logic. They can be quantified over and are used as
arguments for predicate variables. Besides the ML-like formers for sums and
products (i.e. records and variants) we add a membership predicate and a
restriction
operation. The membership predicate $t \in A$ is used to express the fact that
the term $t$ has type $A$. It provides a way to encode the dependent product
type using universal quantification and the arrow type. In this sense, it is
inspired and related to Krivine's relativization of quantifiers.
$$ \Pi_{a:A}\;B \quad:=\quad \forall a (a \in A \Rightarrow B) $$
The restriction operator can be thought of as a kind of conjunction with no
algorithmic content. The formula $A \restriction t \equiv u$ is to be
interpreted in the same way as $A$ if the equivalence $t \equiv u$ holds, and
as $\bot$ otherwise\footnote{We use the standard second-order encoding:
$\bot = \forall X_0\; X_0$ and $\top = \exists X_0\; X_0$.}. In particular,
we will define the following types:
$$
A \restriction t \not\equiv u := A \restriction t \equiv u \Rightarrow \bot
\quad\quad
t \equiv u := \top \restriction t \equiv u
\quad\quad
t \not\equiv u := \top \restriction t \not\equiv u
$$

To handle free variables in formulas we will need to generalize the
notion of substitution to allow the substitution of predicate variables.
\begin{definition}
A substitution is a finite map $\sigma$ ranging over $\lambda$-variables,
$\mu$-variables, term and predicate variables such that:
\begin{itemize}
  \item if $x \in dom(\sigma)$ then $\sigma(x) \in \Lambda_v$,
  \item if $\alpha \in dom(\sigma)$ then $\sigma(\alpha) \in \Pi$,
  \item if $a \in dom(\sigma)$ then $\sigma(a) \in \Lambda$,
  \item if $X_n \in dom(\sigma)$ then
    $\sigma(X_n) \in {\Lambda^n \to \mathcal{P}({{\Lambda}_v}/\!\!\equiv)}$.
\end{itemize}
\end{definition}
\begin{remark}
A predicate variable of arity $n$ will be substituted by a $n$-ary predicate.
Semantically, such predicate will correspond to some total (set-theoretic)
function building a subset of $\Lambda_v/\!\!\equiv$ from $n$ terms. In the
syntax, the binding of the arguments of a predicate variables will happen
implicitly during its substitution.
\end{remark}
\begin{definition}
Given a formula $A$ we denote $FV(A)$ the set of its free variables. Given a
substitution $\sigma$ such that $FV(A) \subseteq dom(\sigma)$ we write
$A[\sigma]$ the closed formula built by applying $\sigma$ to $A$.
\end{definition}

In the semantics we will interpret closed formulas by sets of values closed
under the equivalence relation $(\equiv)$.
\begin{definition}
Given a formula $A$ and a substitution $\sigma$ such that $A[\sigma]$ is
closed, we define the \emph{raw semantics}
$\llbracket A \rrbracket_\sigma \subseteq \Lambda_v/\!\!\equiv$ of $A$ under
the substitution $\sigma$ as follows.
\begin{align*}
\llbracket X_n(t_1, ..., t_n) \rrbracket_\sigma =&\;
  \sigma(X_n)(t_1\sigma, ..., t_n\sigma)\\
\llbracket A \Rightarrow B \rrbracket_\sigma =&\;
  \{\lambda x\; t \;\;|\;\; \forall v \in \llbracket A \rrbracket_\sigma,
  t[x := v] \in \llbracket B \rrbracket_\sigma^{\bot\bot} \} \\
\llbracket \forall a\; A \rrbracket_\sigma =&\;
  \cap_{t \in \Lambda^\ast}{\llbracket A \rrbracket_{\sigma[a := t]}}\\
\llbracket \exists a\; A \rrbracket_\sigma =&\;
  \cup_{t \in \Lambda^\ast}{\llbracket A \rrbracket_{\sigma[a := t]}}\\
\llbracket \forall X_n\; A \rrbracket_\sigma =&\;
  \cap_{P \in \Lambda^n \to \mathcal{P}(\Lambda_v / \equiv)}
  {\llbracket A \rrbracket_{\sigma[X_n := P]}}\\
\llbracket \exists X_n\; A \rrbracket_\sigma =&\;
  \cup_{P \in \Lambda^n \to \mathcal{P}(\Lambda_v / \equiv)}
  {\llbracket A \rrbracket_{\sigma[X_n := P]}}\\
\llbracket \{l_i : A_i\}_{i \in I} \rrbracket_\sigma =&\;
  \{\{l_i = v_i\}_{i \in I} \;\;|\;\; {\forall i \in I}\;\; v_i \in
  \llbracket A_i \rrbracket_\sigma\}\\
\llbracket [C_i : A_i]_{i \in I} \rrbracket_\sigma =&\;
  \cup_{i \in I}\{C_i[v] \;\;|\;\; v \in \llbracket A_i \rrbracket_\sigma\}\\
\llbracket t \in A \rrbracket_\sigma =&\;
  \{v \in \llbracket A \rrbracket_\sigma \;\;|\;\; t\sigma \equiv v\}\\
\llbracket A \restriction t \equiv u \rrbracket_\sigma =&\;
  \left\{ 
    \begin{array}{l l}
      \llbracket A \rrbracket_\sigma & \text{if $t\sigma \equiv u\sigma$}\\
      \emptyset & \text{otherwise}
     \end{array} \right.
\end{align*}
\end{definition}

In the model, programs will realize closed formulas in two different ways
according to their syntactic class. The interpretation of values will be
given in terms of raw semantics, and the interpretation of terms in general
will be given in terms of truth values.
\begin{definition}
Let $A$ be a formula and $\sigma$ a substitution such that $A[\sigma]$ is closed.
We say that:
\begin{itemize}
\item $v \in \Lambda_v$ realizes $A[\sigma]$ if
  $v \in \llbracket A \rrbracket_\sigma$,
\item $t \in \Lambda$ realizes $A[\sigma]$ if
  $t \in \llbracket A \rrbracket_\sigma^{\bot\bot}$.
\end{itemize}
\end{definition}

\subsection{Contexts and typing rules}

Before giving the typing rules of our system we need to define contexts and
judgements. As explained in the introduction, several typing rules require a
value restriction in our context. This is reflected in typing rule by the
presence of two forms of judgements.

\begin{definition}
A context is an ordered list of hypotheses. In particular, it contains type
declarations for $\lambda$-variables and $\mu$-variables, and declaration of
term variables and predicate variables. In our case, a context also contains
term equivalences and inequivalences. A context is built using the following
grammar.
\begin{align*}
\Gamma, \Delta \bnfeq &\bullet
  \bnfor \Gamma, x : A
  \bnfor \Gamma, \alpha : \lnot A
  \bnfor \Gamma, a : Term
\\
  \bnfor &\Gamma, X_n : Pred_n
  \bnfor \Gamma, t \equiv u
  \bnfor \Gamma, t \not\equiv u
\end{align*}
A context $\Gamma$ is said to be valid if it is possible to derive
$\Gamma\;\text{Valid}$ using the rules of figure \ref{valid_context}. In
the following, every context will be considered valid implicitly.
\end{definition}
\begin{figure}
\center
\begin{prooftree}
\AxiomC{$\Gamma \;\; \text{Valid}$}
\AxiomC{$x \not\in dom(\Gamma)$}
\AxiomC{$FV(A) \subseteq dom(\Gamma) \cup \{x\}$}
\TrinaryInfC{$\Gamma, x : A \;\; \text{Valid}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \;\; \text{Valid}$}
\AxiomC{$\alpha \not\in dom(\Gamma)$}
\AxiomC{$FV(A) \subseteq dom(\Gamma)$}
\TrinaryInfC{$\Gamma, \alpha : \lnot A \;\; \text{Valid}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \;\; \text{Valid}$}
\AxiomC{$a \not\in dom(\Gamma)$}
\BinaryInfC{$\Gamma, a : Term \;\; \text{Valid}$}
\DisplayProof\quad\quad\quad
\AxiomC{$\Gamma \;\; \text{Valid}$}
\AxiomC{$X_n \not\in dom(\Gamma)$}
\BinaryInfC{$\Gamma, X_n : Pred_n \;\; \text{Valid}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \;\; \text{Valid}$}
\AxiomC{$FV(t) \cup FV(u) \subseteq dom(\Gamma)$}
\BinaryInfC{$\Gamma, t \equiv u \;\; \text{Valid}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \;\; \text{Valid}$}
\AxiomC{$FV(t) \cup FV(u) \subseteq dom(\Gamma)$}
\BinaryInfC{$\Gamma, t \not\equiv u \;\; \text{Valid}$}
\DisplayProof\quad\quad\quad
\AxiomC{\vbox{\vspace{0.96em}}} % hack to align lines
\UnaryInfC{$\bullet \;\; \text{Valid}$}
\end{prooftree}
\caption{Rules allowing the construction of a valid context.}
\label{valid_context}
\end{figure}

\begin{definition}
There are two forms of typing judgements:
\begin{itemize}
\item $\Gamma \vvdash v : A$ meaning that the value $v$ has type $A$ in
  context $\Gamma$,
\item $\Gamma \vdash t : A$ meaning that the term $t$ has type $A$ in
  context $\Gamma$.
\end{itemize}
\end{definition}
\input{rules.tex}

The typing rules of the system are given in figure \ref{pml2rules}. Although
most of them are fairly usual, our type system differs in several ways. For
instance the last four rules are related to the extensionality of the
calculus. One can note the value restriction in several places: both
universal quantification introduction rules and the introduction of the
membership predicate. In fact, some value restriction is also hidden in the
rules for the elimination of the existential quantifiers and the elimination
rule for the restriction connective. These rules are presented in their
left-hand side variation, and only values can appear on the left of the
sequent. It is not surprising that elimination of an existential quantifier
requires value restriction as it is the dual of the introduction rule of a
universal quantifier.

An important and interesting difference with existing type systems
is the presence of $\uparrow$ and $\downarrow$. These two rules
allow one to go from one kind of sequent to the other when working on values.
Going from $\Gamma \vvdash v : A$ to $\Gamma \vdash v : A$ is
straight-forward. Going the other direction is the main motivation for our
model. This allows us to lift the value restriction expressed in the syntax
to a restriction expressed in terms of equivalence. For example, the two rules
\begin{prooftree}
\AxiomC{$\Gamma, t \equiv v \vdash t : A$}
\AxiomC{$a \not\in FV(\Gamma)$}
\RightLabel{$\forall_{i,\equiv}$}
\BinaryInfC{$\Gamma, t \equiv v \vdash t : \forall a\;A$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$\Gamma, u \equiv v \vdash t : \Pi_{a:A} B$}
\AxiomC{$\Gamma, u \equiv v \vdash u : A$}
\RightLabel{$\Pi_{e,\equiv}$}
\BinaryInfC{$\Gamma, u \equiv v \vdash t\,u : B[a := u]$}
\end{prooftree}
can be derived in the system (see figure \ref{deriv}).
The value restriction can be removed similarly on every other rule. Thus,
judgements on values can be completely ignored by the user of the system.
Transition to value judgements will only happen internally.

\begin{figure}
\begin{prooftree}
\AxiomC{$\Gamma, t \equiv v \vdash t : A$}
\RightLabel{$\equiv_{t,l}$}
\UnaryInfC{$\Gamma, t \equiv v \vdash v : A$}
\RightLabel{$\downarrow$}
\UnaryInfC{$\Gamma, t \equiv v \vvdash v : A$}
\AxiomC{$a \not\in FV(\Gamma)$}
\RightLabel{$\forall_i$}
\BinaryInfC{$\Gamma, t \equiv v \vvdash v : \forall a\;A$}
\RightLabel{$\uparrow$}
\UnaryInfC{$\Gamma, t \equiv v \vdash v : \forall a\;A$}
\RightLabel{$\equiv_{t,l}$}
\UnaryInfC{$\Gamma, t \equiv v \vdash t : \forall a\;A$}
\end{prooftree}
\begin{prooftree}
\alwaysDoubleLine
\AxiomC{$\Gamma, u \equiv v \vdash t : \Pi_{a:A} B$}
\UnaryInfC{$\Gamma, u \equiv v \vdash t : \forall a (a \in A \Rightarrow B)$}
\alwaysSingleLine
\RightLabel{$\forall_e$}
\UnaryInfC{$\Gamma, u \equiv v \vdash t : u \in A \Rightarrow B[a := u]$}
\AxiomC{$\Gamma, u \equiv v \vdash u : A$}
\RightLabel{$\equiv_{t,l}$}
\UnaryInfC{$\Gamma, u \equiv v \vdash v : A$}
\RightLabel{$\downarrow$}
\UnaryInfC{$\Gamma, u \equiv v \vvdash v : A$}
\RightLabel{$\in_i$}
\UnaryInfC{$\Gamma, u \equiv v \vvdash v : v \in A$}
\RightLabel{$\uparrow$}
\UnaryInfC{$\Gamma, u \equiv v \vdash v : v \in A$}
\RightLabel{$\equiv_{t,l}$}
\UnaryInfC{$\Gamma, u \equiv v \vdash u : v \in A$}
\RightLabel{$\equiv_{t,r}$}
\UnaryInfC{$\Gamma, u \equiv v \vdash u : u \in A$}
\RightLabel{$\Rightarrow_e$}
\BinaryInfC{$\Gamma, u \equiv v \vdash t\,u : B[a := u]$}
\end{prooftree}
\caption{Derivation of the rules $\forall_{i,\equiv}$ and $\Pi_{e,\equiv}$.}
\label{deriv}
\end{figure}

\subsection{Adequacy}

We are now going to prove the soundness of our type system by showing that it
is compatible with our realizability model. This property is specified by the
following theorem which is traditionally called the adequacy lemma.
\begin{definition}
Let $\Gamma$ be a (valid) context. We say that the substitution $\sigma$
realizes $\Gamma$ if:
\begin{itemize}
\item for every $x : A$ in $\Gamma$ we have
  $\sigma(x) \in \llbracket A \rrbracket_\sigma$,
\item for every $\alpha : \lnot A$ in $\Gamma$ we have
  $\sigma(\alpha) \in \llbracket A \rrbracket_\sigma^\bot$,
\item for every $a : Term$ in $\Gamma$ we have
  $\sigma(a) \in \Lambda$,
\item for every $X_n : Pred_n$ in $\Gamma$ we have
  $\sigma(X_n) \in \Lambda^n \to \Lambda_v/\!\!\equiv$,
\item for every $t \equiv u$ in $\Gamma$ we have
  $t\sigma \equiv u\sigma$ and
\item for every $t \not\equiv u$ in $\Gamma$ we have
  $t\sigma \not\equiv u\sigma$.
\end{itemize}
\end{definition}

\begin{theorem}{\emph{(Adequacy.)}}\label{adequacy}
Let $\Gamma$ be a (valid) context, $A$ be a formula such that
$FV(A) \subseteq dom(\Gamma)$ and $\sigma$ be a substitution realizing
$\Gamma$.
\begin{itemize}
\item If $\Gamma \vvdash v : A$ then
  $v\sigma \in \llbracket A \rrbracket_\sigma$,
\item if $\Gamma \vdash t  : A$ then
  $t\sigma \in \llbracket A \rrbracket_\sigma^{\bot\bot}$.
\end{itemize}
\end{theorem}
\input{adequacy}

\begin{remark}
For the sake of simplicity we fixed a pole $\dbot$ at the beginning of the
current section. However, many of the properties presented here (including
the adequacy lemma) remain valid with similar poles. We will make use of
this fact in the proof of the following theorem.
\end{remark}

\begin{theorem}{\emph{(Safety.)}}\label{safety}
Let $\Gamma$ be a context, $A$ be a formula such that
$FV(A) \subseteq dom(\Gamma)$ and $\sigma$ be a substitution realizing
$\Gamma$. If $t$ is a term such that $\Gamma \vdash t : A$ and if $A[\sigma]$
is pure (i.e. it does not contain any $\_ \Rightarrow \_$), then for every
stack $\pi \in \llbracket A \rrbracket_\sigma^\bot$ there is a value
$v \in \llbracket A \rrbracket_\sigma$ and $\alpha \in \mathcal{V}_\mu$ such
that ${t\sigma \ast \pi} \reds {v \ast \alpha}$.
\end{theorem}
\begin{proof}
We do a proof by realizability using the following pole.
$$\dbot_A = \{ p \in \Lambda\times\Pi\;|\;p \reds v \ast \alpha \;\land\; v
\in \llbracket A \rrbracket_\sigma\}$$
It is well-defined as $A$ is pure and hence $\llbracket A \rrbracket_\sigma$
does not depend on the pole. Using the adequacy lemma (theorem \ref{adequacy})
with $\dbot_A$ we obtain $t\sigma \in \llbracket A \rrbracket_\sigma^{\bot\bot}$. Hence for
every stack $\pi \in \llbracket A \rrbracket_\sigma^\bot$ we have
${t\sigma \ast \pi} \in \dbot_A$. We can then conclude using the definition
of the pole $\dbot_A$.
\end{proof}
\begin{remark}
It is easy to see that if $A[\sigma]$ is closed and pure then
$v \in \llbracket A \rrbracket_\sigma$ implies that $\bullet \vdash v : A$.
\end{remark}

\begin{theorem}{\emph{(Consistency.)}}\label{consistency}
There is no $t$ such that $\bullet \vdash t : \bot$.
\end{theorem}
\begin{proof}
Let us suppose that $\bullet \vdash t : \bot$. Using adequacy (theorem
\ref{adequacy}
) we obtain that $t \in \llbracket \bot \rrbracket_\sigma^{\bot\bot}$. Since
$\llbracket \bot \rrbracket_\sigma = \emptyset$ we know that
$\llbracket \bot \rrbracket_\sigma^\bot = \Pi$ by definition. Now using
theorem \ref{poleconsist} we obtain
$\llbracket \bot \rrbracket_\sigma^{\bot\bot} = \emptyset$. This is a
contradiction.
\end{proof}
*)

\begin{def}
To every type $A ∈ \cal{F}$ we associate a set of value $\vs("A") ⊆ Λ_{val}$
called its raw semantics. It is defined inductively on the structure of $A$
as follows.
\begin{center}
\diagram(
let _ =
  let line s m = [ vs s; <$=$>; m ] in
  array [`East ; `East ; `West]
  [ line "Φ"               <$ Φ $>
  ; line "(χ ↦ A)"         <$ Φ ↦ \vs("A[χ≔Φ]") $>
  ; line "A(B)"            <$ ⟦A⟧(⟦B⟧) $>
  ; line "A ⇒ B"           <$ \{\v("λx t") \| ∀v∈\vs("A")
                                 \t("t[x≔v]") ∈ \ts("B")\} $>
  ; line "{(li : Ai) i∈I}" <$ \{\v("{(li = vi) i∈I}") \| ∀i∈I
                                 \v("vi")∈\vs("Ai")\} $>
  ; line "[(Ci : Ai) i∈I]" <$ \bigcup_{i∈I} \{\v("Ci[v]") \| v∈\vs("Ai")\} $>
  ; line "∀χ^s A"          <$ \biginter_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "∃χ^s A"          <$ \bigcup_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "μX A"            <$ ... $>
  ; line "νX A"            <$ ... $> ]
)
\end{center}
\end{def}

=<

=<
