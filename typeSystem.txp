\Caml(
  open Diagrams
  open ProofTree
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>
)
\Include{Macros}

=> Type and realisability semantics \label("typeSystem")

In this chapter, we present a new type system which distinguishing feature
is an embedded notion of program equivalence. It enables the specification
of equational properties over programs, which can then be proved using
equational reasoning. Our types are interpreted using standard classical
realisability techniques, which allows for a semantical justification of
our typing rules.

=> Observational equivalence type

One of the main goals of this thesis is to build a type system that can be
used to reason about programs. To achieve this goal, we need to be able to
specify program behaviours using types. We hence introduce equality types
of the form $\f("t ≡ u")$, where $t$ and $u$ are (possibly untyped) terms.
Intuitively, an equality type is interpreted as $⊤$ (i.e. logical truth,
the biggest type) if $t ≡_{≻} u$, and as $⊥$ (i.e. logical absurdity, the
empty type) if $t \nequiv_{≻} u$. For example, the type
$\f("(λx x) λx x ≡ λx x")$ is inhabited as $\t("(λx x) λx x") ≡_{≻}
\t("λx x")$ according to \thmRef("cbvbeta"), but $\f("λx x ≡ {}")$ is empty
as $\t("λx x") \nequiv_{≻} \t("{}")$ according to \thmRef("nequivlamreco").

Of course, it is undecidable whether two terms are equivalent or not. As a
consequence, we will not be able to decide, in general, whether an equality
type is inhabited or not. We will hence need to rely on a partial decision
procedure that will only approximate our observational equivalence relation.
\begin{thm}
Given $t ∈ Λ$ and $u ∈ Λ$ it is undecidable whether $t ≡_{≻} u$ or
$t \nequiv_{≻} u$.
\begin{proof}
We are going to encode the halting problem $H_t$ using equivalence. In our
system, $H_t$ can be stated as ${\p("t ∗ ε")} {⇓}_{≻}$. Let us
consider a term $Ω ∈ Λ$ such that ${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$.
We will now show that $H_t$ is equivalent to
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. Let us suppose $H_t$ and show
${\t("[ε]t") \nequiv_{≻} \t("Ω")}$. We need to find a stack $π ∈ Π$ such
that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ and ${\p("Ω ∗ π")} {⇑}_{≻}$. This is in fact
true for all $π$ as ${\p("Ω ∗ π")} {⇑}_{≻}$ by hypothesis and
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")} {⇓}_{≻}$ since we supposed $H_t$. We now
suppose ${\t("[ε]t") \nequiv_{≻} \t("Ω")}$ and show $H_t$. By definition,
there must be a stack $π ∈ Π$ such that ${\p("[ε]t ∗ π")} {⇓}_{≻}$ since
${\p("Ω ∗ π")} {⇑}_{≻}$ for all $π ∈ Π$. Now since we have
${\p("[ε]t ∗ π")} ≻ {\p("t ∗ ε")}$ we obtain $H_t$.
\end{proof}
\end{thm}

In the system, proving a program equivalence amounts to showing that the
corresponding equality type is inhabited. However, an equivalence type
may also be used as an assumption. For example, it is possible to define
a function which input type is an equivalence. As a consequence, we need
a form of context to store the set of program equivalences that are
assumed to be true during a proof.
\begin{def}
An equational context $Ξ ⊆ \cal{P}(Λ × Λ)$ is a finite set of couples
of terms denoting hypothetical equivalences. For convenience, equational
contexts we will represented using lists generated using the following
||bnf|| grammar.
\Caml(let _ = sidenote << $Ξ ::= ∅ \| {Ξ, t ≡ u}$ >> << $t,u ∈ Λ$ >>)
\end{def}

During the construction of a proof, the equational context grows with new
hypotheses and equivalences need to be proved eventually. As mentioned
previously, we rely on a partial decision procedure that is supposed
correct, but remains otherwise unspecified. The implementation of such a
decision procedure is discussed in \chapter("implem"). Although we cannot
hope for completeness, we will argue that our implementation is good a
good enough approximation in practice.
\begin{def}
Given an equational context $Ξ$ and a substitution $ρ$, we say that $ρ$
//realises// $Ξ$ and we write $ρ ⊩ Ξ$ if for every $(t,u) ∈ Ξ$ we have
$\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}
\begin{def}
Let $Ξ$ be an equational context and $t ∈ Λ$ and $u ∈ Λ$ be two terms. We
write $Ξ ⊢ t ≡ u$ if our (yet unspecified) decision procedure is able to
show that for every substitution $ρ$ such that $ρ ⊩ Ξ$ we have
$\t("tρ") ≡_{≻} \t("uρ")$.
\end{def}

=<
=> Quantification and membership type

Although equality types can be used to derive simple equational properties,
their use is rather limited without a form of quantification. Indeed, they
only allow the derivation of static equivalences like $\t("(λx x) {}") ≡_{≻}
\t("{}")$, but they cannot be used to show more general properties like
"$\t("(λx x) v") ≡_{≻} \t("v")$ for every value $v$".
(* *)
Terms can contain free variables of several sorts: $λ$-variables (i.e. value
variables), term variables and $μ$-variables (i.e. stack variables). As open
terms may appear in types, and in particular in equality types, it is natural
to allow universal and existential quantification over all three sorts of
variables. This will enables the specification of properties such as
$\f("∀y (λx x) y ≡ y")$ or $\f("∀x ∀y x ≡ y ⇒ C[x] ≡ C[y]")$ inside the
system.
\begin{rem}
The forms of quantification described here range over all (closed) value,
terms or stacks regardless of their types.
\end{rem}
\begin{rem}
It is not clear whether quantification over stacks has a practical use. We
only include it as it fits well in the framework with no extra cost.
\end{rem}

Quantifying over all the (closed) values or terms is not always enough.
Indeed, we often need to quantify over the values or the terms of a given
type only. For example if we quantify over a $λ$-variable that is used in
a case analysis, then a runtime error will be produced for values that do
not correspond to matched constructors. This would not happen when
quantifying over value of the appropriate sum type only.

To achieve typed quantification we introduce a membership type constructor
$\f("t ∈ A")$ where $t$ is a term and $A$ is a type. The elements of
$\f("t∈A")$ are those of $A$ that are equivalent to $t$. In particular,
$\f("t ∈ A")$ is empty if $t$ does not have type $A$. Intuitively,
$\f("t∈A")$ can be read as the proposition "$t$ has type $A$", but we will
see later that a more appropriate interpretation would be
"$t$ realises $A$". Using membership, we can use the well-known relativised
quantification scheme to obtain a dependent function type.
$$ Π_{x : A} B ≔ \f("∀x (x∈A ⇒ B)") $$
The dependent function type exactly correspond to typed quantification as
its elements can only be applied to values of type $A$. Other values are
simply filtered out.
(* *)
Note that we can define a dependent pair type using existential
quantification as follows.
$$ Σ_{x : A} B ≔ \f("∃x {l₁ : x∈A ; l₂ : B}") $$
(* *)
We can also define the same kind of type constructors by quantifying over
term variables in the exact same way.
$$
  Π_{a : A} B ≔ \f("∀a (a∈A ⇒ B)")
  \hspace(4.0)
  Σ_{a : A} B ≔ \f("∃a {l₁ : a∈A ; l₂ : B}")
$$
\begin{rem}
Nothing prevents the variable that is quantified over to appear in $A$.
However, it is not clear whether that is useful in practice.
\end{rem}

=<
=> Sorts and higher-order types

Our type system allows universal and existential quantification over
several sorts of objects. There are first order quantifiers ranging over
values, terms and stack, as shown in the previous section. And the system
also provides second order quantification (i.e. quantification over types),
which corresponds to System F polymorphism and type abstraction. All of
these different forms of quantifiers are handled uniformly in the syntax
and in the semantics thanks to a higher-order formulation.

The higher-order features of the system allow us to define (and quantify
over) types with parameters of any sort. For example, we can define a type
parametrised by another type or a term. This leads to a system in which
it is syntactically correct to use a (not fully applied) parametric type,
or even a term, as a proposition. This does not make sense, and hence we
must make sure that this does not happen. The usual approach to tackle this
problem is to assign a form of type (called sort) to the types themselves.
This will give use the guarantee that our types are "well-formed".
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote << $s,r ::= κ \| {s→r}$ >> << $κ∈\cal{S}₀$ >>)
\end{def}

The language of sorts only contains constants and an arrow constructor for
functions. Our "sort system" will in fact be very similar to the simply
typed $λ$-calculus. In particular, the syntax of our types will contain a
constructor for building functions (i.e. $λ$-abstraction) and a corresponding
constructor for application.
\begin{def}
We require a countable set $\cal{V}_ο = \{X, Y, Z...\}$ of propositional
variables that does not intersect with $\cal{V}_ι$, $\cal{V}_τ$ and
$\cal{V}_σ$.
\end{def}
\begin{def}
We require a countable set of variables $\cal{V} = \{χ, ξ, φ...\}$ such that
for every atomic sort $s ∈ \cal{S}₀$ we have $\cal{V}_s ⊆ \cal{V}$. Given a
variable $χ∈\cal{V}$, we will sometimes write $χ^s$ to mean that $χ$ is to
be considered as a variable of sort $s$. In particular, variables in
$\cal{V}_s$ with $s ∈ \cal{S}₀$ will always be considered as variables of
sort $s$.
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is built from $\cal{V}$, $Λ_ι$,
$Λ$ and $Π$ using the following ||bnf|| grammar.
\begin{center}
\Caml(
let _ = large_bnfs
  [ ( << $(\cal{F})$ >>
    , << $A, B$ >>
    , << $v \| t \| π \| \f("χ^s") \| \f("(χ^s ↦ A)") \| \f("A(B)") \|
          \f("A⇒B") \| \f("t∈A") \| \f("A|t≡u") \| \f("{(li : Ai) i∈I}")$ >> )
  ; ( []
    , []
    , << $\id([]) \| \f("[(Ci : Ai) i∈I]") \| \f("∀χ^s A") \|
         \f("∃χ^s A")$ >> ) ]

)
\end{center}
\end{def}
Our types contain values, terms and stacks, as they will correspond to
types of sort $ι$, $τ$ and $σ$. We then have variables of all sorts,
abstraction to build types with an arrow sort and application. All the
remaining constructors are used to build propositions (i.e. actual
formulas) which will be given sort $ο$. Note that the quantifiers may
range over types of any sort. They are hence very general.
\begin{rem}
The variable constructor in the syntax of types is somewhat redundant for
values, terms and stacks. Indeed, these syntactic entities already provide
variables.
\end{rem}

To track the sort of variables in types we need to introduce a form of
context. It can then be used to define our notion of well-formed type
using a deduction rule system. We will then only consider types that can
be show well-formed in this system.
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, we will represent
sorting contexts using comma-separated lists of sort assignments generated
by the following ||bnf|| grammar.
\Caml(let _ = sidenote << $Σ ::= ∅ \| {Σ, χ : s}$ >>
  << $χ ∈ \cal{V}, s ∈ \cal{S} $ >>)
\end{def}
\begin{def}
A sorting judgment is a triple of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the deduction rules of
\figRef("sortrules").
\end{def}
\Caml(
let r11 =
  << $\unaryR{Σ, x : ι ⊢ \t("t") : τ}{Σ ⊢ \v("λx t") : ι}$ >>
let r12 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \v("C[v]") : ι}$ >>
let r13 =
  << $\unaryR{\{Σ ⊢ \v("vi") : ι\}_{i∈I}}{Σ ⊢ \v("{(li = vi) i∈I}") : ι}$ >>
let r21 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("v") : τ}$ >>
let r22 =
  << $\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \t("u") : τ}{Σ ⊢ \t("t u") : τ}$ >>
let r23 =
  << $\unaryR{Σ, α : σ ⊢ \t("t") : τ}{Σ ⊢ \t("μα t") : τ}$ >>
let r31 =
  << $\binaryR{Σ ⊢ \s("π") : σ}{Σ ⊢ \t("t") : τ}{Σ ⊢ \t("[π]t") : τ}$ >>
let r32 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("v.l") : τ}$ >>
let r33 =
  << $\binaryR{Σ ⊢ v : ι}{\{Σ, x_i : ι ⊢ \t("ti") : τ\}_{i∈I}}{
       Σ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : τ}$ >>
let r41 =
  << $\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("Y(t,v)") : τ}$ >>
let r42 =
  << $\unaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \t("U(v)") : τ}$ >>
let r43 =
  << $\binaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \v("w") : ι}{Σ ⊢ \t("δ(v,w)") : τ}$ >>
let r51 =
  << $\axiomR{Σ ⊢ \s("ε") : σ}$ >>
let r52 =
  << $\binaryR{Σ ⊢ \v("v") : ι}{Σ ⊢ \s("π") : σ}{Σ ⊢ \s("v · π") : σ}$ >>
let r53 =
  << $\binaryR{Σ ⊢ \t("t") : τ}{Σ ⊢ \s("π") : σ}{Σ ⊢ \s("[t] π") : σ}$ >>
let r61 =
  << $\axiomR{Σ, χ : s ⊢ χ : s}$ >>
let r62 =
  << $\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ^s ↦ A)") : s → r}$ >>
let r63 =
  << $\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}$ >>
let r71 =
  << $\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f("A ⇒ B") : ο}$ >>
let r72 =
  << $\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}$ >>
let r73 =
  << $\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}$ >>
let r81 =
  << $\unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("∀χ^s A") : ο}$ >>
let r82 =
  << $\unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("∃χ^s A") : ο}$ >>
let r83 =
  << $\binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f("t∈A") : ο}$ >>
let r91 =
  << $\ternaryR{Σ ⊢ A : ο}{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f("A|t≡u") : ο}$ >>

let rs env =
  (* let env = resize_env 3.4 env in *)
  let rs =
    [ [ r11 ; r12 ; r13 ] ; [ r21 ; r22 ; r23 ] ; [ r31 ; r32 ; r33 ]
    ; [ r41 ; r42 ; r43 ] ; [ r51 ; r52 ; r53 ] ; [ r61 ; r62 ; r63 ]
    ; [ r71 ; r72 ; r73 ] ; [ r81 ; r82 ; r83 ] ; [ r91 ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let sortrules () =
  figure_here ~name:"sortrules" ~caption:[tT "Sorting rules."] (dr rs)
)

The main role of the sorting rules is to keep track of the sort of the free
variables. The rules on the first five lines of \figRef("sortrules") simply
traverse the structure of values, terms and stacks to save the sort of the
free variables in the context. Note that the first rule on the sixth line is
also used for value, term and stack variables.

As an example $\f("λx x ⇒ {}")$ is not well-formed as the type at the left
of the arrow does not have sort $ο$ (it has sort $ι$ or $τ$). However,
$\f("(X ↦ [C₀:{} | C₁ : X])([C₂:{} | C₃:{}])")$ is a well-formed type of
sort $ο$, as shown by the following proof tree.
$$
  \proofTree{
    \binary{⊢ \f("(X ↦ [C₀ : {} | C₁ : X])([C₂ : {} | C₃ : {}])") : ο}{
      \unary{⊢ \f("(X ↦ [C₀ : {} | C₁ : X])") : ο → ο}{
        \binary{X : ο ⊢ \f("[C₀ : {} | C₁ : X]") : ο}{
          \axiom{X : ο ⊢ \f("{}") : ο}
        }{
          \axiom{X : ο ⊢ \f("X") : ο}
        }
      }
    }{
      \binary{⊢ \f("([C₂ : {} | C₃ : {}])") : ο}{
        \axiom{⊢ \f("{}") : ο}
      }{
        \axiom{⊢ \f("{}") : ο}
      }
    }
  }
$$

As types contain the $λ$-calculus, we need to consider their reduction and
normalisation. First we define the notion of $β$-reduction in a type.
\begin{def}
We call a redex a type of the form $\f("(χ^s ↦ A)(B)")$, and we say that a
type is in normal form if it does not contain any redex. The reduction
relation over types is the smallest relation $({\inj}) ⊆ \cal{F} × \cal{F}$
such that:
\begin{itemize}
\item for every redex $\f("(χ^s ↦ A)(B)")$ we have
      $\f("(χ^s ↦ A)(B)") \inj \f("A[χ≔B]")$ and
\item $({\inj})$ is contextually closed. Reduction hence considers all the
      redexes in a type, and not only the surface ones.
\end{itemize}
We denote $({\inj}^{∗})$ its reflexive and transitive closure.
\end{def}
\Caml(let _ = sortrules ())
\begin{thm}
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$
be a sort. If the sorting judgment $Σ ⊢ A : s$ is valid, then there
is a unique type $B∈\cal{F}$ such that $B$ is in normal form,
$A \inj^{∗} B$ and the sorting judgment $Σ ⊢ B : s$ is valid.
\begin{proof}
Our language of types can be seen as an instance of the simply typed
$λ$-calculus extended with countably many constants. For instance, a
type of the form $\f("∀χ^s A")$ can be encoded using a constant ${∀}$
of sort $(s→ο)→ο$. Note that an infinite number of constants is
required to encode product types, sum types, records and pattern
matchings as they can be indexed by any finite subset of $\bbN$. As a
consequence, the theorem follows from well-known properties of the
simply typed $λ$-calculus with the subtyping relation induced by the
axiom $ι ≤ τ$ on base types (See, e.g., \mcite(["Mitchell1996"])).
\end{proof}
\end{thm}
In the following sections, we will always consider well-formed types. As a
consequence, we may also assume that a type is in normal form as we can
alway normalise well-formed types according to the previous theorem.

=<
=> Typing judgments for values and terms

As our language is call-by-value and has operations generating side-effects,
we need to be careful to achieve type-safety. In particular, some of our
typing rules will not apply to terms, but only to values (as mentioned in
\chapter("intro")). Here, value restriction will be encoded using two forms
of judgments: usual typing judgments ranging over terms (including values),
and a restricted form of judgments ranging over values only.

To be able to assign types to terms containing free $λ$-variables and free
$μ$-variables, we need our typing judgments to carry a form of context.
\begin{def}
A //typing context// is a finite map $Γ$ over $\cal{V}_ι ∪ \cal{V}_σ$ such
that $Γ(x) ∈ \cal{F}$ for all $x ∈ dom(Γ) ∩ \cal{V}_ι$ and $Γ(α) ∈ \cal{F}$
for all $α ∈ dom(Γ) ∩ \cal{V}_σ$. For convenience, we will represent typing
contexts using comma-separated lists of type assignments generated by the
following ||bnf|| grammar. Note that variables can only be mapped once in
a context, the order in which they appear is thus irrelevant.
\Caml(let _ = sidenote << $Γ ::= ∅ \| {Γ, x : A} \| {Γ, α : A^⊥}$ >>
  << $x ∈ \cal{V}_ι, α ∈ \cal{V}_τ, A ∈ \cal{F} $ >>)
\end{def}

The full context of typing judgments will be built using a typing context
and an equational context. As these contexts may contain types and hence
free variables, we need to define a notions of well-formedness for these
two forms of contexts.
\begin{def}
Given a sorting context $Σ$, we say that a typing context $Γ$ is well-formed
and write $Σ ⊢ Γ$ if for all $x ∈ dom(Γ) ∩ \cal{V}_ι$ we have $Σ ⊢ Γ(x) : ο$
and $Σ ⊢ x : ι$, and for all $α ∈ dom(Δ) ∩ \cal{V}_σ$ we have $Σ ⊢ Γ(α) : ο$
and $Σ ⊢ α : σ$.
\end{def}
\begin{def}
Given a sorting context $Σ$, we say that an equational context $Ξ$ is
well-formed and write $Σ ⊢ Ξ$ if for all $(t,u) ∈ Σ$ we have
$Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{def}

Using our three forms of contexts, we can now define our actual judgments.
Again, a notion of well-formedness need to be considered as our judgments
contain objects of different sorts, which all need to be well-formed.
\begin{def}
A value judgement is a tuple of a typing context $Γ$, an equational
context $Ξ$, a value $v ∈ Λ_ι$ and a type $A ∈ \cal{F}$ that is
denoted $Γ; Ξ ⊢_\tval v : A$. We say that such a judgment is well-formed
under the sorting context $Σ$, and we write $Σ \sp Γ; Ξ ⊢_\tval v : A$,
if and only if we have $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ v : ι$ and $Σ ⊢ A : ο$.
\end{def}
\begin{def}
A term judgement is a tuple of a typing context $Γ$, an equational
context $Ξ$, a term $t ∈ Λ$ and a type $A ∈ \cal{F}$ that is denoted
$Γ; Ξ ⊢ t : A; Δ$. We say that such a judgment is well-formed under
the sorting context $Σ$, and we write $Σ \sp Γ; Ξ ⊢ t : A$, if and
only if we have $Σ ⊢ Γ$, $Σ ⊢ Ξ$, $Σ ⊢ t : τ$ and $Σ ⊢ A : ο$.
\end{def}

We can now give the typing rules of our system, which will involve
both value and term judgments. Moreover, some of our rules have a
premise of the form $Ξ ⊢ t ≡ u$. They can only be applied if our
(yet unspecified) equivalence decision procedure is successful in
proving that $t$ is equivalent to $u$ in the equational context
$Ξ$ (see the first section of this chapter).
\begin{def}
A value or term judgment is said to be valid if it can be derived using the
typing rules of \figRef("typerules").
\end{def}
The typing rules of our system, and hence our typing derivations, only
involve well-formed judgments. In particular, a typing rule can only be
applied if all the involved judgments are well-formed.
\begin{rem}
Note that the $∀_i$ rule cannot apply if the variable $χ$ appears in the
contexts $Γ$ and $Ξ$ nor in $t$. This would prevent the conclusion
judgment to be well-formed.
\end{rem}

As our system is call-by-value and has effect, the $∀_i$ rule needs value
restriction to remain sound. In our formalism, this means that the $∀_i$
rule applies to value judgments. The $∈_i$ rule requires value restriction
as well, as otherwise the system cannot be proved sound. As the $∈_i$ rule
will be involved in the derivation of the typing rule for the elimination
of the dependent function type in \section("encodedep"), the latter will
also need value restriction.

\Caml(
let r_ax =
  <<$\axiomRN{Ax}{Σ, x:ι \sp Γ, x:A; Ξ ⊢_\tval \t("x") : A}$>>

let r_up =
  <<$\unaryRN{↑}{Σ \sp Γ;Ξ ⊢_\tval \v("v") : A}
   {Σ ⊢ (Γ;Ξ ⊢ \t("v") : A; Δ)}$>>

let r_arrow_i =
  <<$\unaryRN{⇒_i}{Σ, x:ι \sp Γ,x:A;Ξ ⊢ \t("t") : B}
   {Σ \sp Γ;Ξ ⊢_\tval \v("λx t") : A ⇒ B}$>>

let r_arrow_e =
  <<$\binaryRN{⇒_e}{Σ \sp Γ;Ξ ⊢ \t("t") : A ⇒ B}{Σ \sp Γ;Ξ ⊢ \t("u") : A}
   {Σ \sp Γ;Ξ ⊢ \t("t u") : B}$>>

let r_mu =
  <<$\unaryRN{μ}{Σ, α:σ \sp Γ,α:A;Ξ ⊢ \t("t") : A}
   {Σ \sp Γ;Ξ ⊢ \t("μα t") : A}$>>

let r_name =
  <<$\unaryRN{[\wc]}{Σ, α:σ \sp Γ,α:A;Ξ ⊢ \t("t") : A}
   {Σ, α:σ \sp Γ,α:A;Ξ ⊢ \t("[α]t") : B}$>>

let r_forall_i =
  <<$\unaryRN{∀_i}{Σ, χ:s \sp Γ;Ξ ⊢_\tval \v("v") : A}
   {Σ \sp Γ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A")}$>>

let r_forall_e =
  <<$\binaryRN{∀_e}{Σ \sp Γ;Ξ ⊢ \t("t") : \f("∀χ^s A")}{Σ ⊢ B : s}
   {Σ \sp Γ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]")}$>>

let r_exists_i =
  <<$\binaryRN{∃_i}{Σ \sp Γ;Ξ ⊢ \t("t") : \f("A[χ≔B]")}{Σ ⊢ B : s}
   {Σ \sp Γ;Ξ ⊢ \t("t") : \f("∃χ^s A")}$>>

let r_exists_e =
  <<$\binaryRN{∃_e}{Σ, x:ι \sp Γ,x:\f("A[χ≔B]");Ξ ⊢ \t("t") : \f("C")}
   {Σ ⊢ B : s}{Σ, x:ι \sp Γ,x:\f("∃χ^s A");Ξ ⊢ \t("t") : \f("C")}$>>

let r_memb_i =
  <<$\unaryRN{∈_i}{Σ \sp Γ;Ξ ⊢_\tval \v("v") : A}
   {Σ \sp Γ;Ξ ⊢_\tval \v("v") : \f("v∈A")}$>>

let r_memb_e =
  <<$\unaryRN{∈_e}{Σ, x:ι \sp Γ,x:A;Ξ,x≡t ⊢ \t("u") : C}
   {Σ, x:ι \sp Γ,x:\f("t∈A");Ξ ⊢ \t("u") : C}$>>

let r_rest_i =
  <<$\binaryRN{↾_i}{Σ \sp Γ;Ξ ⊢ \t("t") : A}{Ξ ⊢ \t("u₁") ≡ \t("u₂")}
   {Σ \sp Γ;Ξ ⊢ \t("t") : \f("A | u₁≡u₂")}$>>

let r_rest_e =
  <<$\unaryRN{↾_e}{Σ, x:ι \sp Γ,x:A;Ξ,\t("u₁")≡\t("u₂") ⊢ \t("t") : C}
   {Σ, x:ι \sp Γ,x:\f("A | u₁≡u₂");Ξ ⊢ \t("t") : C}$>>

let r_prod_i =
  <<$\unaryRN{×_i}{[Σ \sp Γ;Ξ ⊢_\tval \v("vi") : \f("Ai")]_{i∈I}}
   {Σ \sp Γ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")}$>>

let r_prod_e =
  <<$\binaryRN{×_e}{Σ \sp Γ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}")}
   {k∈I}{Σ \sp Γ;Ξ ⊢ \t("v.lk") : A_k}$>>

let r_sum_i =
  <<$\binaryRN{+_i}{Σ \sp Γ;Ξ ⊢_\tval \v("v") : \f("Ak")}{k∈I}
   {Σ \sp Γ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]")}$>>

let r_sum_e =
  <<$\binaryRN{+_e}{Σ \sp Γ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]")}
   {[Σ \sp Γ,x_i:A_i;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B]_{i∈I}}
   {Σ \sp Γ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B}$>>

let r_eq_ti =
  <<$\binaryRN{≡_{τ,ι}}{Σ \sp Γ[x≔w₁];Ξ ⊢ \t("t[x≔w₁]") : \f("A[x≔w₁]")}
   {Ξ ⊢ \v("w₁") ≡ \v("w₂")}
   {Σ \sp Γ[x≔w₂];Ξ ⊢ \t("t[x≔w₂]") : \f("A[x≔w₂]")}$>>

let r_eq_ii =
  <<$\binaryRN{≡_{ι,ι}}{Σ \sp Γ[x≔w₁];Ξ ⊢_\tval \v("v[x≔w₁]") : \f("A[x≔w₁]")}
   {Ξ ⊢ \v("w₁") ≡ \v("w₂")}
   {Σ \sp Γ[x≔w₂];Ξ ⊢ \v("v[x≔w₂]") : \f("A[x≔w₂]")}$>>

let r_eq_tt =
  <<$\binaryRN{≡_{τ,τ}}{Σ \sp Γ[a≔u₁];Ξ ⊢ \t("t[a≔u₁]") : \f("A[a≔u₁]")}
   {Ξ ⊢ \t("u₁") ≡ \t("u₂")}
   {Σ \sp Γ[a≔u₂];Ξ ⊢ \t("t[a≔u₂]") : \f("A[a≔u₂]")}$>>

let r_eq_it =
  <<$\binaryRN{≡_{ι,τ}}{Σ \sp Γ[a≔u₁];Ξ ⊢_\tval \v("v[a≔u₁]") : \f("A[a≔u₁]")}
   {Ξ ⊢ \t("u₁") ≡ \t("u₂")}
   {Σ \sp Γ[a≔u₂];Ξ ⊢_\tval \v("v[a≔u₂]") : \f("A[a≔u₂]")}$>>

let rs env =
  let env = resize_env 3.2 env in
  let rs =
    [ [r_ax;r_arrow_i] ; [r_up;r_arrow_e] ; [r_mu;r_name]
    ; [r_forall_i;r_exists_e] ; [r_forall_e;r_exists_i] ; [r_memb_e;r_rest_i]
    ; [r_memb_i;r_rest_e] ; [r_prod_e;r_sum_i] ; [r_prod_i] ; [r_sum_e]
    ; [r_eq_ii] ; [r_eq_ti] ; [r_eq_it] ; [r_eq_tt] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let _ = figure_here ~name:"typerules" ~caption:[tT "Typing rules."] (dr rs)
)

=<
=> Call-by-value realisability semantics

The abstract machine presented in \chapter("calculus") is part of a
//classical realisability// machinery that will be built upon here.
We aim at obtaining a semantical interpretation of our higher-order
type system. In particular, a proposition (i.e. a type of sort $ο$)
will be interpreted by three sets: a set of values, a set of stacks
and a set of terms. As always in classical realisability, the model
is parametrised by a pole, which serves as an exchange point between
the world of programs and the world of execution contexts, encoded
as stacks.
\begin{def}
Given a reduction relation $R ⊆ (Λ×Π) × (Λ×Π)$, a //pole// is a set
of processes $\dbot ⊆ Λ×Π$ which is //$R$-saturated// (i.e. closed
under backward reduction). More formally, if we have $q ∈ \dbot$ and
$p R q$ then $p ∈ \dbot$.
\end{def}
It is important to note that in the remaining of this chapter, we
will consider, if not otherwise specified, a fixed (but arbitrary)
pole $\dbot$.

The notion of //orthogonality// is central in Krivine's classical
realisability. In this framework a type is interpreted (or realised) by
programs computing corresponding values. This interpretation is spread
in a three-layered construction, even though it is fully determined by
the first layer and the choice of the pole. The first layer consists of
a set of values that we will call the //raw semantics//. It gathers all
the syntactic values that should be considered as having the corresponding
type. As an example, if we were to consider the type of natural numbers,
its raw semantics would be the set $\{\hat{n} \| n ∈ \bbN\}$ where
$\hat{n}$ is some encoding of $n$.
(* *)
The second layer, called //falsity value//, is a set containing every
closed stack that is a candidate for building a valid process using any
value from the raw semantics. The notion of validity depends on the
choice of the pole. The third layer, called //truth value// is a set of
closed terms that is built by iterating the process once more. The
formalism for the two levels of orthogonality is given in the following
definitions. Recall that $Λ_ι^{∗}$, $Λ^{∗}$ and $Π^{∗}$ denote the set
of closed values, closed terms and closed stacks respectively.
\begin{def}\label("orthodef1")
For every set $Φ ⊆ Λ_ι^{∗}$ we define a set $Φ^⊥ ⊆ Π^{∗}$ as follows.
$$ Φ^⊥ = \{π∈Π^{∗} \| ∀v∈Φ, \p("v ∗ π") ∈ \dbot\} $$
\end{def}
\begin{def}\label("orthodef2")
For every set $Ψ ⊆ Π^{∗}$ we define a set $Ψ^⊥ ⊆ Λ^{∗}$ as follows.
$$ Ψ^⊥ = \{t∈Λ^{∗} \| ∀π∈Ψ, \p("t ∗ π") ∈ \dbot\} $$
\end{def}
\begin{rem}
In the usual presentation of Krivine's classical realisability, the
interpretation of types can contain open values, terms and stacks.
Here, we need to restrict ourselves to closed objects for our model
to be compatible with our notion of equivalence.
\end{rem}

We now give several general properties of orthogonality, which hold in
every call-by-value classical realisability model. They will be useful
when proving the soundness of our type system.
\begin{lem}\label("orthosimple")
If $Φ ⊆ Λ_ι^{∗}$ is a set of values, then $Φ ⊆ Φ^{⊥⊥}$.
\begin{proof}
We take $v ∈ Φ$ and show $v ∈ Φ^{⊥⊥}$. By definition we need to
show $\p("v∗π") ∈ \dbot$ for all stack $π ∈ Φ^⊥$. This is immediate
by definition of $Φ^⊥$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclstack")
Let $Φ$, $Ψ ⊆ Λ_ι^{∗}$ be sets of closed values. If $Φ ⊆ Ψ$ then
$Ψ^⊥ ⊆ Φ^⊥$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$, take $π ∈ Ψ^⊥$ and show that $π ∈ Φ^⊥$.
By definition, we know that for all $v ∈ Ψ$ we have $\p("v ∗ π") ∈ \dbot$.
Since $Φ ⊆ Ψ$, this is also true for all $v ∈ Φ$, and hence $π ∈ Φ^⊥$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoinclterm")
Let $Φ$, $Ψ ⊆ Λ_ι^{∗}$ be sets of closed values. If $Ψ^⊥ ⊆ Φ^⊥$ then
$Φ^{⊥⊥} ⊆ Ψ^{⊥⊥}$.
\begin{proof}
Let us suppose that $Ψ^⊥ ⊆ Φ^⊥$, take $t ∈ Φ^{⊥⊥}$ and show that
$t ∈ Ψ^{⊥⊥}$. By definition, we know that for all $π ∈ Φ^⊥$ we have
$\p("t ∗ π") ∈ \dbot$. Since $Ψ^⊥ ⊆ Φ^⊥$, this is also true for all
$π ∈ Ψ^⊥$, and hence $t ∈ Ψ^{⊥⊥}$.
\end{proof}
\end{lem}
\begin{lem}\label("orthoincl")
Let $Φ$, $Ψ ⊆ Λ_ι^{∗}$ be sets of closed values. If $Φ ⊆ Ψ$ then
$Φ^{⊥⊥} ⊆ Ψ^{⊥⊥}$.
\begin{proof}
Let us suppose that $Φ ⊆ Ψ$ and apply \lemRef("orthoinclstack") to obtain
$Ψ^⊥ ∈ Φ^⊥$. We can then conclude using \lemRef("orthoinclterm").
\end{proof}
\end{lem}

When choosing a pole, it is important to check that it does not yield a
degenerate model. In particular we need to check that no term is able to
face every stacks. If it were the case, such a term could be used as a
proof of $⊥$.
\begin{def}
A pole $\dbot ⊆ Λ×Π$ is said to be consistent if for every closed term
$t ∈ Λ$ there is a stack $π$ such that $\p("t ∗ π") ∉ \dbot$.
\end{def}

In this thesis, another property will be required of our poles. As we
are in the presence of an equivalence relation over terms, we will need
our poles to be closed under this relation in some sense. This will
allow us to derive the same properties for equivalent terms, and handle
the uniformly.
\begin{def}
Given an equivalence relation $R ⊆ Λ×Λ$, a pole $\dbot ⊆ Λ×Π$ is said to
be $R$-extentional if for every closed terms $t$, $u ∈ Λ^{∗}$ such that
$t R u$, and for every stack $π ∈ Π$, we have $\p("t∗π") ∈ \dbot$ if and
only if $\p("u∗π") ∈ \dbot$.
\end{def}
From now on, and until the end of this chapter, we will only consider
poles that $≻$-saturated and $≡_{≻}$-extensional. This information will
be kept implicit most of the time.
\begin{thm}\label("poleext")
Let $Φ ⊆ Λ_ι^{∗}$ be a set of closed values and $t$, $u ∈ Λ^{∗}$ be two
closed terms. With an ${≡}_{≻}$-extentional pole, if $t ∈ Φ^{⊥⊥}$ and
$t ≡_{≻} u$ then $u ∈ Φ^{⊥⊥}$.
\begin{proof}
By definition we need to take $π ∈ Φ^⊥$ and show that $\p("u∗π") ∈ \dbot$.
Since $t ∈ Φ^{⊥⊥}$ we have $\p("t∗π") ∈ \dbot$ and hence we can conclude
since our pole is ${≡}_{≻}$-extentional and we have $t ≡_{≻} u$.
\end{proof}
\end{thm}

In our realisability model, the well-formed closed types will be
interpreted by the elements of a set defined according to their sort.
Such a set can be seen as the interpretation, in the model, of the sort
themselves.
\begin{def}
To every sort $s ∈ \cal{S}$ we associate a set $⟦s⟧$ defined as follows.
\Caml(
let _ = tabular_layout 0.6 2.0
  [ [ <<$⟦ι⟧ = Λ_ι^{∗}$>>
    ; <<$⟦τ⟧ = Λ^{∗}$>>
    ; <<$⟦σ⟧ = Π^{∗}$>> ]
  ; [ <<$⟦ο⟧ = \cal{P}(Λ_ι^{∗} / {≡}_≻)$>>
    ; <<$⟦s→r⟧ = ⟦r⟧^⟦s⟧$>> ] ]
)
\end{def}

The semantical interpretation of types usually relies on a substitution
(or interpretation function) to interpret free variables. Here, we will
use another common method consisting in extending the syntax of types
with the elements of the model. We will thus substitute free variables
with such elements of the model, which will allow us to interpret closed
types only. Of course, an open type can always be made into a closed
types by replacing its free variables by elements of the interpretation
of the corresponding sorts.
\begin{def}
We extend the syntax of types with the elements of the model. As a
consequence, we will consider that $⟦s⟧ ⊆ \cal{F}$ for every sort
$⟦s⟧$. Note that this is already true for $s = ι$, $s = τ$ and
$s = σ$. We will often use the letter $Φ$ to denote an element of the
model in the syntax. Our system is also extended with the following
sorting rule.
$$ \unaryR{Φ ∈ ⟦s⟧}{Σ ⊢ Φ : s} $$
\end{def}
\begin{def}
Given a sorting context $Σ$, we call a //valuation// over $Σ$ a finite
map $ρ$ such that for all $χ∈dom(Σ)$ we have $ρ(χ) ∈ ⟦Σ(χ)⟧$. If
$A∈\cal{F}$ is a type and $s∈\cal{S}$ is a sort such that $Σ ⊢ A: s$
then we denote $\f("Aρ")$ the type formed by applying $ρ$ to $A$.
\end{def}
\begin{lem}\label("typevalaux")
Let $Σ₁$ and $Σ₂$ be two sorting contexts such that $dom(Σ₁) ∩ dom(Σ₂) = ∅$.
Let $A∈\cal{F}$ be a type and $s∈\cal{S}$ be a sort such that $Σ₁,Σ₂ ⊢ A:s$.
If $ρ$ is a valuation over $Σ₁$ such that $dom(ρ) ∩ dom(Σ₂) = ∅$ then
$Σ₂ ⊢ \f("Aρ") : s$.
\begin{proof}
Simple induction on the derivation of $Σ₁, Σ₂ ⊢ A : s$ by replacing the
variables of $Σ₁$ by their value in $ρ$. During the induction $Σ₂$ will
grow when going through the rules that extend the context. The proof for
the other rules can be handled immediably by induction hypothesis. The
only interesting case is the axiom
$$\axiomR{Σ₁, Σ₂ ⊢ χ : s}$$
for which there are two cases. Either $χ∈dom(Σ₂)$ and the derivation
remains an axiom, or $χ∈dom(Σ₁)$. In this second case we have $χ∈dom(ρ)$
and thus $χρ = ρ(χ) ∈ ⟦s⟧$. As a consequence the derivation becomes
the following.
$$ \unaryR{ρ(χ) ∈ ⟦s⟧}{Σ₂ ⊢ ρ(χ) : s} $$
\end{proof}
\end{lem}
\begin{lem}\label("typeval")
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be
a sort such that we have $Σ ⊢ A : s$. If $ρ$ is a valuation over $Σ$ then
$⊢ \f("Aρ") : s$.
\begin{proof}
Direct consequence of \lemRef("typevalaux") by takind $Σ₁ = Σ$ and
$Σ₂ = ∅$.
\end{proof}
\end{lem}

We can now give the interpretation of our type constructors in our model.
In particular, the elements of the model such as values, terms or stacks
will be interpreted as themselves.
\begin{def}
To every closed type $A ∈ \cal{F}$ we associate a set $⟦A⟧$ called its
//interpretation//. It is defined inductively on the structure of $A$ as
follows.
\begin{center}
\diagram(
let _ =
  let line s m = [ vs s; <$=$>; m ] in
  array [`East ; `East ; `West]
  [ line "Φ"               <$ Φ $>
  ; line "(χ^s ↦ A)"       <$ Φ ↦ \vs("A[χ≔Φ]") $>
  ; line "A(B)"            <$ ⟦A⟧(⟦B⟧) $>
  ; line "A ⇒ B"           <$ \{\v("λx t") \| ∀v∈\vs("A"),
                                 \t("t[x≔v]") ∈ \ts("B")\} $>
  ; line "t ∈ A"           <$ \{\v("v") ∈ \vs("A") \|
                                 \v("v") ≡_{≻} \t("t")\} $>
  ; line "A | t ≡ u"       <$ \{\v("v") ∈ \vs("A") \|
                                 \t("t") ≡_{≻} \t("u")\} $>
  ; line "{(li : Ai) i∈I}" <$ \{\v("{(li = vi) i∈I}") \| ∀i∈I,
                                 \v("vi")∈\vs("Ai")\} $>
  ; line "[(Ci : Ai) i∈I]" <$ \bigcup_{i∈I} \{\v("Ci[v]") \| v∈\vs("Ai")\} $>
  ; line "∀χ^s A"          <$ \biginter_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $>
  ; line "∃χ^s A"          <$ \bigcup_{Φ∈⟦s⟧} \vs("A[χ≔Φ]") $> ]
)
\end{center}
\end{def}
\begin{rem}
We have $\vs("A | t ≡ u") = \vs("A")$ if $t ≡_{≻} u$ and
$\vs("A | t ≡ u") = ∅$ otherwise. We also have $\vs("t∈A") = ∅$ if there
is no $v ∈ \vs("A")$ such that $v ≡_{≻} t$.
\end{rem}
\begin{thm}\label("sortsem")
Let $Σ$ be a sorting context, $A∈\cal{F}$ be a type and $s∈\cal{S}$ be
a sort. If we have a derivation of $Σ ⊢ A : s$ and if $ρ$ is a valuation
over $Σ$ then $\vs("Aρ") ∈ ⟦s⟧$.
\begin{proof}
The proof is done by induction on the derivation of $Σ ⊢ A : s$. We reason
by case on the last rules used in the deduction tree. In the case of the
rule
$$ \unaryR{Φ ∈ ⟦s⟧}{Σ ⊢ Φ : s} $$
the proof is trivial. For the first heighteen rules of \figRef("sortrules"),
the proof is immediate using the induction hypothesis. The remaining cases
are treated bellow. Note that We recall the corresponding rules after the
proof of each case.
\begin{itemize}
\item In the case of the arrow type, we need to show $\vs("(A⇒B)ρ") ∈ ⟦ο⟧$.
  By induction hypothesis, we know $\vs("Aρ") ∈ ⟦ο⟧$ and $\vs("Bρ") ∈ ⟦ο⟧$,
  which give us $\vs("Aρ") ⊆ Λ_ι^{∗}$ and $\ts("Bρ") ∈ Λ^{∗}$.
  Consequently, $\vs("Aρ⇒Bρ")$ is well-defined and $\vs("Aρ⇒Bρ") ⊆ Λ_ι^{∗}$.
  It remains to show that $\vs("Aρ⇒Bρ")$ is closed under $({≡}_{≻})$.
  Let us take $\v("λx t") ∈ \vs("Aρ ⇒ Bρ")$ and a value $w ∈ Λ_ι^{∗}$
  such that $\v("λx t") ≡_{≻} \v("w")$. According to \thmRef("canonlambda")
  we have $w = \v("λx u")$ for some $u ∈ Λ$ (up to renaming of $x$) and
  $t ≡_{≻} u$. To prove $\v("λx u") ∈ \vs("Aρ⇒Bρ")$ we take a value
  $v ∈ \vs("Aρ")$ and show $\t("u[x≔v]") ∈ \ts("Bρ")$. As
  $\v("λxt") ∈ \vs("Aρ⇒Bρ")$ we know that by definition we have
  $\t("t[x≔v]") ∈ \ts("Bρ")$. We can hence conclude with \thmRef("poleext")
  as we have $\t("u[x≔v]") ≡_{≻} \t("t[x≔v]")$ according to
  \thmRef("substequiv").
  $$ \binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ \f("A ⇒ B") : ο} $$
\item \todo(None) (* TODO *)
      $$ \unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο} $$
\item \todo(None) (* TODO *)
      $$ \unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο} $$
\item In the case of the universal type, we need to show that
      $\vs("(∀χ A)ρ") ∈ ⟦ο⟧$. As we are free to rename $χ$ we may
      assume that $χ ∉ dom(ρ)$ and hence our goal rewrites
      $\vs("∀χ Aρ") = \bigcap_{Φ∈⟦s⟧} \vs("Aρ[χ≔Φ]") ∈ ⟦ο⟧$. As an
      intersection of sets closed under $({≡}_{≻})$ remains closed
      under this relation, we take $Φ ∈ ⟦s⟧$ and show (* FIXME lemma ? *)
      $\vs("Aρ[χ≔Φ]") ∈ ⟦ο⟧$. We can then conclude by induction
      hypothesis with the valuation $ρ[χ≔Φ]$.
      $$ \unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("∀χ A") : ο} $$
\item In the case of the existential type, we need to show that
      $\vs("(∃χ A)ρ") ∈ ⟦ο⟧$. As we are free to rename $χ$ we may
      assume that $χ ∉ dom(ρ)$ and hence our goal rewrites
      $\vs("∃χ Aρ") = \bigcup_{Φ∈⟦s⟧} \vs("Aρ[χ≔Φ]") ∈ ⟦ο⟧$. As a
      union of sets closed under $({≡}_{≻})$ remains closed under
      this relation, we take $Φ ∈ ⟦s⟧$ and show (* FIXME lemma ? *)
      $\vs("Aρ[χ≔Φ]") ∈ ⟦ο⟧$. We can then conclude by induction
      hypothesis with the valuation $ρ[χ≔Φ]$.
      $$ \unaryR{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("∃χ A") : ο} $$
\item In the case of the membership type, we need to show that
      $\vs("tρ∈Aρ") ∈ ⟦ο⟧$. By induction hypothesis, we know
      $\vs("tρ") = \t("tρ") ∈ ⟦τ⟧ = Λ^{∗}$ and
      $\vs("Aρ") ∈ ⟦ο⟧$. As a consequence, the set
      $\{\v("v") ∈ \vs("A") \| \v("v") ≡_{≻} \t("t")\}$ is well-defined
      and it is a subset of $\vs("Aρ")$. Moreover, it is closed under
      the $({≡}_{≻})$ relation so we have $\vs("tρ∈Aρ") ∈ ⟦ο⟧$.
      $$ \binaryR{Σ ⊢ t : τ}{Σ ⊢ A : ο}{Σ ⊢ \f("t∈A") : ο} $$
\item In the case of the restriction type, we need to show that
      $\vs("Aρ|tρ≡uρ") ∈ ⟦ο⟧$. By induction hypothesis, we know
      $\vs("tρ") = \t("tρ") ∈ ⟦τ⟧ = Λ^{∗}$ and
      $\vs("uρ") = \t("uρ") ∈ ⟦τ⟧ = Λ^{∗}$. Hence the equivalence
      $t ≡_{≻} u$ is well-defined, so $\vs("Aρ|tρ≡uρ")$ is either
      equal to $\vs("Aρ")$, in which case we can conclude by
      induction hypothesis, or to $∅$. In this second case we can
      also conclude since $∅ ∈ ⟦ο⟧$.
      $$ \ternaryR{Σ ⊢ A : ο}{Σ ⊢ t : τ}{Σ ⊢ u : τ}{Σ ⊢ \f("A|t≡u") : ο} $$
\end{itemize}
\end{proof}
\end{thm}

\begin{thm}\label("vexttyp")
Let $A∈\cal{F}$ be a type, $x ∈ \cal{V}_ι$ be a $λ$-variable and
$v₁ ∈ Λ_ι$ and $v₂ ∈ Λ_ι$ be values such that $x : ι ⊢ A : ο$,
$⊢ v₁ : ι$ and $⊢ v₂ : ι$.
If we have $v₁ ≡_{≻} v₂$ then we also have $\vs("A[x≔v₁]") = \vs("A[x≔v₂]")$.
\begin{proof}
\todo(None) (* TODO *)
\end{proof}
\end{thm}
\begin{thm}\label("texttyp")
Let $A∈\cal{F}$ be a type, $a ∈ \cal{V}_τ$ be a term variable and $u₁ ∈ Λ$
and $u₂ ∈ Λ$ be terms such that $a : τ ⊢ A : ο$, $⊢ u₁ : τ$ and $⊢ u₂ : τ$.
If we have $u₁ ≡_{≻} u₂$ then we also have $\vs("A[a≔u₁]") = \vs("A[a≔u₂]")$.
\begin{proof}
\todo(None) (* TODO *)
\end{proof}
\end{thm}

=<
=> Adequacy

Now that the interpretation of our types in our model has been specified,
we need to show that our typing rules actually agree with the semantics.
Intuitively, we need to check that whenever our type system can be used to
prove that a term $t$ has type $A$, then $t$ is indeed in the term level
interpretation of $A$. This will be summarised in the following theorem,
but we first need some definition.
\begin{def}
Let $Σ$ be a sorting context and $Γ$ be a typing context such that $Σ ⊢ Γ$.
If $ρ$ is a valuation over $Σ$ then we say that $ρ$ realises $Γ$ and we
write $ρ ⊩ Γ$ if for every $x∈dom(Γ)$ we have $ρ(x) ∈ ⟦Γ(x)⟧$.
\end{def}
\begin{def}
Let $Σ$ be a sorting context and $Δ$ be a stack context such that $Σ ⊢ Δ$.
If $ρ$ is a valuation over $Σ$ then we say that $ρ$ realises $Δ$ and we
write $ρ ⊩ Δ$ if for every $α∈dom(Δ)$ we have $ρ(α) ∈ ⟦Δ(α)⟧$.
\end{def}
\begin{thm}\label("vadequacy")
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the value
judgment $Σ ⊢ (Γ;Ξ ⊢_\tval v:A;Δ)$ is derivable and if $ρ ⊩ Γ$, $ρ ⊩ Δ$ and
$ρ ⊩ Ξ$ then $\v("vρ") ∈ \vs("Aρ")$.
\begin{proof}
Proof by mutual induction with the proof of \thmRef("tadequacy").
\end{proof}
\end{thm}
\begin{thm}\label("tadequacy")
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the term
judgment $Σ ⊢ (Γ;Ξ ⊢ t:A;Δ)$ is derivable and if $ρ ⊩ Γ$, $ρ ⊩ Δ$ and
$ρ ⊩ Ξ$ then $\t("tρ") ∈ \ts("Aρ")$.
\begin{proof}
We proceed by induction on the derivation of the judgment $Σ ⊢ (Γ;Ξ ⊢ t:A;Δ)$
or $Σ ⊢ (Γ;Ξ ⊢_\tval v:A;Δ)$, and we reason by case on the last used rule.
\begin{itemize}

\item In the case of the ($Ax$) rule, we immediately obtain
      $\v("xρ") = \v("ρ(x)") ∈ \vs("Aρ")$ by hypothesis since $ρ ⊩ Γ, x:A$.

      $$\axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Ξ ⊢_\tval \t("x") : A; Δ)}$$

\item If the last used rule is ($↑$) then we need to show
      $\v("vρ") ∈ \ts("Aρ")$. By induction hypothesis we know
      $\v("vρ") ∈ \vs("Aρ")$, hence we can conclude using
      \thmRef("orthosimple").

      $$\unaryRN{↑}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : A; Δ)}
        {Σ ⊢ (Γ;Ξ ⊢ \t("v") : A; Δ)}$$

\item If the last used rule is ($⇒_i$) then we need to show that
      $\t("(λx t)ρ") ∈ \vs("(A ⇒ B)ρ")$. By definition, we need to take
      $v ∈ \vs("Aρ")$ and show $\t("(tρ)[x ≔ v]") ∈ \ts("Bρ")$. We can
      conclude by induction hypothesis using the valuation
      $\subs("ρ[x ≔ v]")$.

      $$\unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Ξ ⊢ \t("t") : B; Δ)}
        {Σ ⊢ (Γ;Ξ ⊢_\tval \v("λx t") : A ⇒ B; Δ)}$$

\item If the last used rule is ($⇒_e$) then we need to show
      $\t("(t u)ρ") = \t("tρ uρ") ∈ \ts("Bρ")$. Let us take
      $π ∈ \ss("Bρ")$ and show $\p("tρ uρ ∗ π") ∈ \dbot$. Since
      $\p("tρ uρ ∗ π") ≻ \p("uρ ∗ [tρ]π")$ and $\dbot$ is saturated, is is
      enough to show $\p("uρ ∗ [tρ]π") ∈ \dbot$. As $\t("uρ") ∈ \ts("Aρ")$
      by induction hypothesis, it only remains to show
      $\s("[tρ]π") ∈ \ss("Aρ")$. Let us take $\v("v") ∈ \vs("Aρ")$
      and show that $\p("v ∗ [tρ]π") ∈ \dbot$. Since
      $\p("v ∗ [tρ]π") ≻ \p("tρ ∗ v·π")$ and $\dbot$ is saturated, it is
      enough to show $\p("tρ ∗ v·π") ∈  \dbot$. By induction hypothesis
      $\t("tρ") ∈ \ts("Aρ ⇒ Bρ")$, hence it only remains
      to show $\s("v·π") ∈ \ss("Aρ ⇒ Bρ")$. Let us now take
      $\v("w") ∈ \vs("Aρ ⇒ Bρ")$ and show that $\p("w ∗ v·π") ∈ \dbot$. By
      definition of the set $\vs("Aρ ⇒ Bρ")$, $w$ must be of the form
      $\v("λx f")$. Since $\p("λx f ∗ v·π") ≻ \p("f[x ≔ v] ∗ π")$ and
      $\dbot$ is saturated, it is enough to show that
      $\p("f[x ≔ v] ∗ π") ∈ \dbot$. Since
      $\s("π") ∈ \ss("Bρ")$ it only remains to show that
      $\t("f[x ≔ v]") ∈ \ts("Bρ")$. This is true by definition of
      $\vs("Aρ ⇒ Bρ")$ since $\v("v") ∈ \vs("Aρ")$.

      $$\binaryRN{⇒_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : A ⇒ B; Δ)}
        {Σ ⊢ (Γ;Ξ ⊢ \t("u") : A; Δ)}{Σ ⊢ (Γ;Ξ ⊢ \t("t u") : B; Δ)}$$

\item If the last used rule is ($μ$) then we need to show that
      $\t("(μα t)ρ") = \t("μα tρ") ∈ \ts("Aρ")$. Let us take
      $π ∈ \ss("Aρ")$ and show $\p("μα tρ ∗ π") ∈ \dbot$. Since
      $\p("μα tρ ∗ π") ≻ \p("tρ[α ≔ π] ∗ π")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ[α ≔ π] ∗ π") ∈ \dbot$. We can then conclude
      by induction hypothesis using the valuation $\subs("ρ[α ≔ π]")$.

      $$\unaryRN{μ}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
        {Σ ⊢ (Γ;Ξ ⊢ \t("μα t") : A; Δ)}$$

\item If the last used rule is ($[\wc]$) then we need to show
      $\t("([α]t)ρ") = \t("[ρ(α)]tρ") ∈ \ts("Bρ")$. Let us take
      $π ∈ \ss("Bρ")$ and show $\p("[ρ(α)]tρ ∗ π") ∈ \dbot$. Since
      $\p("[ρ(α)]tρ ∗ π") ≻ \p("tρ ∗ ρ(α)")$ and $\dbot$ is saturated, it
      is enough to show $\p("tρ ∗ ρ(α)") ∈ \dbot$. By induction hypothesis,
      we know that $\t("tρ") ∈ \ts("Aρ")$, hence we only need to show that
      $\s("ρ(α)") ∈ \ss("Aρ")$. This is true by hypothesis since $ρ ⊩ Δ, α:A$.

      $$\unaryRN{[\wc]}{Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("t") : A; Δ,α:A)}
        {Σ, α:σ ⊢ (Γ;Ξ ⊢ \t("[α]t") : B; Δ,α:A)}$$

\item If the last used rule is ($∀_i$) then we need to show
      $\v("vρ") ∈ \vs("(∀χ^s A)ρ")$. By definition we have
      $\vs("(∀χ^s A)ρ") = \bigcap_{\f("B")∈⟦s⟧} \vs("Aρ[χ ≔ B]")$,
      hence it is enough to take $\f("B") ∈ ⟦s⟧$ and show
      $\v("vρ") ∈ \vs("Aρ[χ ≔ B]")$. Note that $\v("vρ") = \v("vρ[χ ≔ B]")$
      as $\f("χ")$ cannot appear in $\v("v")$ for the conclusion judgment to
      be well-formed. We conclude by induction hypothesis with the
      valuation $\subs("ρ[χ ≔ B]")$.

      $$\unaryRN{∀_i}{Σ, χ:s ⊢ (Γ;Ξ ⊢_\tval \v("v") : A;Δ)}
        {Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A");Δ)}$$

\item If the last used rule is ($∀_e$) then we need to show
      $\t("tρ") ∈ \ts("(A[χ ≔ B])ρ")$. By induction hypothesis we have
      $\t("tρ") ∈ \ts("(∀χ^s A)ρ")$, and as a consequence it is enough to
      show $\ts("(∀χ^s A)ρ") ⊆ \ts("(A[χ ≔ B])ρ")$, or
      $\vs("(∀χ^s A)ρ") ⊆ \vs("(A[χ ≔ B])ρ")$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume that $χ ∉ dom(Σ)$,
      hence our goal rewrites to $\vs("∀χ^s Aρ") ⊆ \vs("Aρ[χ ≔ Bρ]")$.
      Since $\vs("∀χ^s Aρ") = \bigcap_{\f("B")∈⟦s⟧} \vs("Aρ[χ ≔ B]")$ and
      $\f("Bρ") ∈ ⟦s⟧$ the inclusion follows

      $$\binaryRN{∀_e}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∀χ^s A");Δ)}{Σ ⊢ B : s}
        {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]");Δ)}$$

\item If the last used rule is ($∃_i$) then we need to show
      $\t("tρ") ∈ \ts("(∃χ^s A)ρ")$. By induction hypothesis we have
      $\t("tρ") ∈ \ts("(A[χ ≔ B])ρ")$, and as a consequence it is enough
      to show $\ts("(A[χ ≔ B])ρ") ⊆ \ts("(∃χ^s A)ρ")$, or
      $\vs("(A[χ ≔ B])ρ") ⊆ \vs("(∃χ^s A)ρ")$ according to
      \thmRef("orthoincl"). Up to renaming, we can assume $χ ∉ dom(Σ)$,
      hence our goal rewrites to $\vs("Aρ[χ ≔ Bρ]") ⊆ \vs("∃χ^s Aρ")$.
      Since $\vs("∃χ^s Aρ") = \bigcup_{\f("B")∈⟦s⟧} \vs("Aρ[χ ≔ B]")$ and
      $\f("Bρ") ∈ ⟦s⟧$ the inclusion follows

      $$\binaryRN{∃_i}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A[χ≔B]");Δ)}{Σ ⊢ B : s}
        {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("∃χ^s A");Δ)}$$

\item If the last used rule is ($∃_e$) then we need to show
      $\t("tρ") ∈ \ts("Cρ")$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ \vs("(A[χ ≔ B])ρ")$ provided
      $\v("ρ(x)") ∈ \vs("(∃χ^s A)ρ")$. In other words, we need to show
      $\vs("(A[χ ≔ B])ρ") ⊆ \vs("(∀χ^s A)ρ")$. Up to renaming, we can
      assume $χ ∉ dom(Σ)$, hence our goal rewrites to 
      $\vs("Aρ[χ ≔ Bρ]") ⊆ \vs("∃χ^s Aρ")$. The inclusion follows since
      $\vs("∃χ^s Aρ") = \bigcup_{\f("B")∈⟦s⟧} \vs("Aρ[χ ≔ B]")$ and
      $\f("Bρ") ∈ ⟦s⟧$.

      $$\binaryRN{∃_e}{Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Ξ ⊢ \t("t") : \f("C");Δ)}
        {Σ ⊢ B : s}{Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Ξ ⊢ \t("t") : \f("C");Δ)}$$

\item If the last used rule is ($∈_e$) then we need to show
      $\t("uρ") ∈ \ts("Cρ")$. To apply the induction hypothesis,
      we need to check that $\v("ρ(x)") ∈ \vs("Aρ")$ and that
      $\v("ρ(x)")≡\t("tρ")$, provided that we have
      $\v("xρ") ∈ \vs("(t∈A)ρ")$. By definition
      $\vs("(t∈A)ρ") = \vs("tρ∈Aρ") = \{v∈\vs("Aρ") \st v≡\t("tρ")\}$,
      and hence $\v("ρ(x)") ∈ \vs("Aρ")$ and $\v("ρ(x)")≡\t("tρ")$.

      $$\unaryRN{∈_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,x≡t ⊢ \t("u") : C;Δ)}
        {Σ, x:ι ⊢ (Γ,x:\f("t∈A");Ξ ⊢ \t("u") : C;Δ)}$$

\item In the case of ($∈_i$) we need to show
      $\v("vρ") ∈ \vs("(v ∈ A)ρ") = \{w ∈ \vs("Aρ") \| w ≡_{≻} vρ\}$. As
      we have $\v("vρ") ∈ \vs("Aρ")$ by induction hypothesis, it only
      remains to show $\t("vρ") ≡_{≻} \t("vρ")$, which is immediate.

      $$\unaryRN{∈_i}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : A;Δ)}
        {Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("v∈A");Δ)}$$

\item If the last used rule is ($↾_i$) then we must show
      $\t("tρ") ∈ \ts("(A | u₁≡u₂)ρ")$. By hypothesis, we know
      $\t("u₁ρ") ≡ \t("u₂ρ")$, and hence we have
      $\vs("Aρ | u₁ρ ≡ u₂ρ") = \vs("Aρ")$.
      As a consequence $\ts("Aρ | u₁ρ ≡ u₂ρ") = \ts("Aρ")$ and hence we can
      conclude since $\t("tρ") ∈ \ts("Aρ")$ by induction hypothesis.

      $$\binaryRN{↾_i}{Σ ⊢ (Γ;Ξ ⊢ \t("t") : A;Δ)}{Ξ ⊢ \t("u₁") ≡ \t("u₂")}
        {Σ ⊢ (Γ;Ξ ⊢ \t("t") : \f("A | u₁≡u₂");Δ)}$$

\item If the last used rule is ($↾_e$) then we need to show
      $\t("tρ") ∈ \ts("Cρ")$. To be able to apply the induction hypothesis,
      we need to show $ρ(x) ∈ \vs("Aρ")$ and $u₁ρ ≡_{≻} u₂ρ$ under the
      assumption that $ρ(x) ∈ \vs("Aρ | u₁ρ ≡ u₂ρ") ≠ ∅$. This immediately
      follows from the definition of $\vs("Aρ | u₁ρ ≡ u₂ρ")$ since it is
      non-empty.

      $$\unaryRN{↾_e}{Σ, x:ι ⊢ (Γ,x:A;Ξ,\t("u₁")≡\t("u₂") ⊢ \t("t") : C;Δ)}
        {Σ, x:ι ⊢ (Γ,x:\f("A | u₁≡u₂");Ξ ⊢ \t("t") : C;Δ)}$$

\item If the last used rule is ($×_i$) then we need to show
      $\v("{(li = vi) i∈I}ρ") ∈ \vs("{(li : Ai) i∈I}ρ")$. By definition it
      is enough to show that $\v("viρ") ∈ \vs("Aiρ")$ for all index $i$ in
      $I$. This exactly corresponds to the induction hypotheses.

      $$\unaryRN{×_i}{[Σ ⊢ (Γ;Ξ ⊢_\tval \v("vi") : \f("Ai");Δ)]_{i∈I}}
        {Σ ⊢ (Γ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}");Δ)}$$

\item If the last used rule is ($×_e$) then we need to show that
      $\t("(v.lk)ρ") ∈ \ts("Akρ")$. By induction hypothesis we know that
      $\v("vρ") ∈ \vs("{(li : Ai) i∈I}ρ")$, hence by definition
      $\v("vρ") = \v("{(li = vi) i∈I}")$ and for all index $i$ in $I$ we
      have $\v("vi") ∈ \vs("Aiρ")$. Let us now take $π ∈ \ss("Akρ")$ and
      show that $\p("{(li = vi) i∈I}.lk ∗ π") ∈ \dbot$. As $k$ is in $I$, we
      have $\p("{(li = viρ) i∈I}.lk ∗ π") ≻ \p("viρ ∗ π")$, hence it is enough
      to show $\p("vkρ ∗ π") ∈ \dbot$ as $\dbot$ is saturated. Since
      $π ∈ \ss("Akρ")$, we only have to show $\v("vkρ") ∈ \ts("Akρ")$. We can
      hence conclude using \thmRef("orthosimple") as $\v("vkρ") ∈ \vs("Akρ")$.

      $$\binaryRN{×_e}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}");Δ)}
        {k∈I}{Σ ⊢ (Γ;Ξ ⊢ \t("v.lk") : A_k;Δ)}$$

\item If the last used rule is ($+_i$) then we need to show
      $\t("(Ck[v])ρ") ∈ \vs("[(Ci : Ai) i∈I]ρ")$. By definition we only need
      to show $\v("vρ") ∈ \vs("Akρ")$ since the index $k$ is in $I$. This is
      exactly the induction hypothesis.

      $$\binaryRN{+_i}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("Ak");Δ)}{k∈I}
        {Σ ⊢ (Γ;Ξ ⊢_\tval \v("Ck[v]") : \f("[(Ci : Ai) i∈I]");Δ)}$$

\item If the last used rule is ($+_e$) then we need to show
      $\t("[v | (Ci[xi] → ti) i∈I]ρ") ∈ \ts("Bρ")$. By induction hypothesis
      $\v("vρ") ∈ \vs("[(Ci : Ai) i∈I]ρ")$, hence by definition
      $\v("vρ") = \v("Ck[w]")$ for some index $k$ in $I$ and
      $w ∈ \vs("Akρ")$. Let us now take a stack $π ∈ \ss("Bρ")$ and show
      that we have $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ∈ \dbot$. As
      $\p("[Ck[w] | (Ci[xi] → tiρ) i∈I] ∗ π") ≻ \p("tkρ[xk≔w] ∗ π")$ and
      $\dbot$ is saturated, it is enough to show
      $\p("tkρ[xk≔w] ∗ π") ∈ \dbot$. Let us now consider the valuation
      $\subs("ρ[xk≔w]")$. Up to renaming, we can assume that $\v("xk")$ does
      not appear free in $\f("B")$, hence $\f("Bρ") = \f("Bρ[xi≔w]")$.
      Consequently we have $π ∈ \ss("Bρ[xk≔w]")$, hence it is enough to
      show that $\t("tkρ[xk≔w]") ∈ \ts("Bρ[xk≔w]")$. We can conclude by
      induction hypothesis using the valuation $\subs("ρ[xk≔w]")$ since
      $\v("vρ[xk≔w]") ≡_{≻} \v("Ck[w]")$.

      \begin{env}(scale 0.96)
      $$\binaryRN{+_e}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]");Δ)}
        {[Σ ⊢ (Γ,x_i:A_i;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B;Δ)]_{i∈I}}
        {Σ ⊢ (Γ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B;Δ)}$$
      \end{env}

\item If the last used rule is ($≡_{l,τ,ι}$) then we need to show
      $\t("(t[x≔v₂])ρ") ∈ \ts("Aρ")$. Without loss of generality we may
      assume that $x ∉ dom(ρ)$, hence $\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$
      and $\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$. By hypothesis we have
      $\v("v₁ρ") ≡_{≻} \v("v₂ρ")$, hence \thmRef("sextval") gives us
      $\t("tρ[x≔v₁ρ]") ≡_{≻} \t("tρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("poleext") since we have $\t("tρ[x≔v₁ρ]") ∈ \ts("Aρ")$
      by induction hypothesis.

      $$\binaryRN{≡_{l,τ,ι}}{Σ ⊢ (Γ;Ξ ⊢ \t("t[x≔v₁]") : A;Δ)}
        {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢ \t("t[x≔v₂]") : A;Δ)}$$

\item If the last used rule is ($≡_{l,τ,τ}$) then we need to show
      $\t("(t[a≔u₂])ρ") ∈ \ts("Aρ")$. Without loss of generality we may
      assume that $a ∉ dom(ρ)$, hence $\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$
      and $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$. By hypothesis we have
      $\t("u₁ρ") ≡_{≻} \t("u₂ρ")$, hence \thmRef("sextterm") gives us
      $\t("tρ[a≔u₁ρ]") ≡_{≻} \t("tρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("poleext") since we have $\t("tρ[a≔u₁ρ]") ∈ \ts("Aρ")$
      by induction hypothesis.

      $$\binaryRN{≡_{l,τ,τ}}{Σ ⊢ (Γ;Ξ ⊢ \t("t[a≔u₁]") : A;Δ)}
        {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢ \t("t[a≔u₂]") : A;Δ)}$$

\item If the last used rule is ($≡_{r,τ,ι}$) then we need to show
      $\t("tρ") ∈ \ts("(A[x≔v₂])ρ")$. By induction hypothesis we have
      $\t("tρ") ∈ \ts("(A[x≔v₁])ρ")$, and to conclude we will show that
      $\vs("(A[x≔v₁])ρ") = \vs("(A[x≔v₂])ρ")$ (and hence
      $\ts("(A[x≔v₁])ρ") = \ts("(A[x≔v₂])ρ")$). Without loss of generality
      we may assume that $x ∉ dom(ρ)$, hence our goal rewrites
      $\vs("Aρ[x≔v₁ρ]") = \vs("Aρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("vexttyp") as we have $\v("v₁ρ") ≡_{≻} \v("v₂ρ")$ by
      hypothesis.

      $$\binaryRN{≡_{r,τ,ι}}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[x≔v₁]");Δ)}
        {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[x≔v₂]");Δ)}$$

\item If the last used rule is ($≡_{r,τ,τ}$) then we need to show
      $\t("tρ") ∈ \ts("(A[a≔u₂])ρ")$. By induction hypothesis we have
      $\t("tρ") ∈ \ts("(A[a≔u₁])ρ")$, and to conclude we will show that
      $\vs("(A[a≔u₁])ρ") = \vs("(A[a≔u₂])ρ")$. Without loss of generality
      we may assume that $a ∉ dom(ρ)$, hence our goal rewrites
      $\vs("Aρ[a≔u₁ρ]") = \vs("Aρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("texttyp") as we have $\t("u₁ρ") ≡ \t("u₂ρ")$ by
      hypothesis.

      $$\binaryRN{≡_{r,τ,τ}}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[a≔u₁]");Δ)}
        {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢ t : \f("A[a≔u₂]");Δ)}$$

\item If the last used rule is ($≡_{l,ι,ι}$) then we need to show
      $\t("(v[x≔v₂])ρ") ∈ \vs("Aρ")$. Without loss of generality we may
      assume that $x ∉ dom(ρ)$, hence $\t("(v[x≔v₂])ρ") = \t("vρ[x≔v₂ρ]")$
      and $\t("(v[x≔v₁])ρ") = \t("vρ[x≔v₁ρ]")$. By hypothesis we have
      $\v("v₁ρ") ≡_{≻} \v("v₂ρ")$, hence \thmRef("sextval") gives us
      $\v("vρ[x≔v₁ρ]") ≡_{≻} \v("vρ[x≔v₂ρ]")$. We can then conclude since
      $\v("vρ[x≔v₁ρ]") ∈ \vs("Aρ")$ by induction hypothesis and
      $\vs("Aρ") ∈ ⟦ο⟧$ is closed under $({≡}_{≻})$

      $$\binaryRN{≡_{l,ι,ι}}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[x≔v₁]") : A;Δ)}
        {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[x≔v₂]") : A;Δ)}$$

\item If the last used rule is ($≡_{l,ι,τ}$) then we need to show
      $\t("(v[a≔u₂])ρ") ∈ \vs("Aρ")$. Without loss of generality we may
      assume that $a ∉ dom(ρ)$, hence $\t("(v[a≔u₂])ρ") = \t("vρ[a≔u₂ρ]")$
      and $\t("(v[a≔u₁])ρ") = \t("vρ[a≔u₁ρ]")$. By hypothesis we have
      $\t("u₁ρ") ≡_{≻} \t("u₂ρ")$, hence \thmRef("sextterm") gives us
      $\t("vρ[a≔u₁ρ]") ≡_{≻} \t("vρ[a≔u₂ρ]")$. We can then conclude as
      $\v("vρ[a≔u₁ρ]") ∈ \vs("Aρ")$ by induction hypothesis and
      $\vs("Aρ") ∈ ⟦ο⟧$ is closed under $({≡}_{≻})$

      $$\binaryRN{≡_{l,ι,τ}}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[a≔u₁]") : A;Δ)}
        {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval \v("v[a≔u₂]") : A;Δ)}$$

\item If the last used rule is ($≡_{r,ι,ι}$) then we need to show
      $\v("vρ") ∈ \vs("(A[x≔v₂])ρ")$. By induction hypothesis we have
      $\v("vρ") ∈ \vs("(A[x≔v₁])ρ")$, and to conclude we will show that
      $\vs("(A[x≔v₁])ρ") = \vs("(A[x≔v₂])ρ")$. Without loss of generality
      we may assume that $x ∉ dom(ρ)$, hence our goal rewrites
      $\vs("Aρ[x≔v₁ρ]") = \vs("Aρ[x≔v₂ρ]")$. We can then conclude using
      \thmRef("vexttyp") as we have $\v("v₁ρ") ≡_{≻} \v("v₂ρ")$ by
      hypothesis.

      $$\binaryRN{≡_{r,ι,ι}}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[x≔v₁]");Δ)}
        {Ξ ⊢ \v("v₁") ≡ \v("v₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[x≔v₂]");Δ)}$$

\item If the last used rule is ($≡_{r,ι,τ}$) then we need to show...
      $\v("vρ") ∈ \vs("(A[a≔u₂])ρ")$. By induction hypothesis we have
      $\v("vρ") ∈ \vs("(A[a≔u₁])ρ")$, and to conclude we will show that
      $\vs("(A[a≔u₁])ρ") = \vs("(A[a≔u₂])ρ")$. Without loss of generality
      we may assume that $x ∉ dom(ρ)$, hence our goal rewrites
      $\vs("Aρ[a≔u₁ρ]") = \vs("Aρ[a≔u₂ρ]")$. We can then conclude using
      \thmRef("texttyp") as we have $\t("u₁ρ") ≡_{≻} \t("u₂ρ")$ by
      hypothesis.

      $$\binaryRN{≡_{r,ι,τ}}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[a≔u₁]");Δ)}
        {Ξ ⊢ \t("u₁")≡\t("u₂")}{Σ ⊢ (Γ;Ξ ⊢_\tval v : \f("A[a≔u₂]");Δ)}$$

\end{itemize}
\end{proof}
\end{thm}

=<
=> Properties of the system

\todo(None) (* TODO from here *)

=<
=> Derived rules for dependent types

\label("encodedep") (* FIXME why do I need to put the label here ???!!!! *)

(* The weak Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, x:ι_v}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{x ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, x:ι_v}; Γ; Δ; Ξ ⊢_\tval λx t : x∈A ⇒ B}{
   \unaryN{∈}{{Σ, x:ι_v}; {Γ, x:{x∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, x:ι_v}; {Γ, x:A}; Δ; {Ξ, x≡x} ⊢ t : B}{
     \hyp{{Σ, x:ι_v} ; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{x ∉ FV(Γ; Δ; Σ)}}
}
$$
(* The weak Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[x := v] ⇒ B[x := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[x := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[x := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]}
   }
  }
 }
}
$$

(* The Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{a ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, a:ι}; Γ; Δ; Ξ ⊢_\tval λx t : a∈A ⇒ B}{
   \unaryN{∈}{{Σ, a:ι}; {Γ, x:{a∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, a:ι}; {Γ, x:A}; Δ; {Ξ, x≡a} ⊢ t : B}{
     \hyp{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{a ∉ FV(Γ; Δ; Σ)}}
}
$$

(* The Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[a := v] ⇒ B[a := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[a := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[a := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]}
   }
  }
 }
}
$$
(* TODO *)

=<

=<
