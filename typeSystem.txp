\Caml(
  open Diagrams
  open ProofTree
  let (v,t,c,s,p) = KAM.(v,t,c,s,p)
  let f = Type.f
)
\Include{Macros}

=> Higher-order classical \sc{ml} \label("typeSystem")

In this chapter, we introduce the formalisms of type theory and classical
realizability. These theories are used here to build a higher-order type
system for the language defined in \chapter("calculus"). Our types will be
interpreted using standard realisability techniques, which will allow us
to give a semantical justification to our typing rules.

=> Simple types

In order to prevent undesired computational behaviours such as runtime
errors, functional programming languages rely on syntactic checks. We
will first consider a small type system with only three type constructors:
functions, products (in the form of records) and sums (in the form of
variants).
\begin{def}
The set of all types $\cal{F}$ is built using the following ||bnf|| grammar.
$$ A,B ::= \f("A ⇒ B") \| \f("{(li : Ai) i∈I}") \| \f("[(Ci : Ai) i∈I]")$$
\end{def}
\begin{rem}
To lighten the notations, we will consider the function type to be right
associative. That is, we will always read a type of the form
$\f("A ⇒ B ⇒ C")$ as $\f("A ⇒ (B ⇒ C)")$.
\end{rem}
Through the Curry-Howard isomorphism, it is possible to see our type system
as a logic. In particular, a type can be read as a formula in which the
arrow type corresponds to logical implication. Similarly, product and sum
types can be interpreted as logical conjunction and disjunction.

To be able to assign a type to terms containing free variables, we need to
use typing contexts. A typing context will map variables to their assumed
type. Logically, a context will simply correspond to a set of hypothesis.
That is, a set of formulas that are assumed to be true.
\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ such that for all
$λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent contexts using lists generated using the following ||bnf|| grammar.
$$ Γ ::= • \| {Γ, x : A} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that their order is irrelevant.
\end{def}

\begin{def}
A typing judgement is a triple of a term $t ∈ Λ$, a type $A ∈ \cal{F}$ and
a context $Γ$ that is denoted $Γ ⊢ t : A$. A judgment is said to be
//well-formed// if $FV_λ(t) ⊆ dom(Γ)$ and if $FV_ι(t) ∪ FV_μ(t) = ∅$.
\end{def}
\begin{rem}
Our first type system will only be able to work with terms not containing
$μ$-variables or term variables. The mechanism for handling such variables
will be introduced in later sections.
\end{rem}
\begin{rem}
In the following, we will only consider well-formed judgements. This
information will be kept implicit most of the time.
\end{rem}
\begin{def}
We say that a well-formed judgement is //valid// if and only if it can be
derived using the following deduction rule system.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢ \t("λx t") : \f("A ⇒ B")}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : \f("A ⇒ B")}{Γ ⊢ u : A}{Γ ⊢ \t("t u") : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢ v_i : A_i]_{i∈I}}{
    Γ ⊢ \t("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}")
  }
  \hspace(6.0)
  \unaryRN{×_e}{Γ ⊢ v : \f("{(li : Ai) i∈I}")}{Γ ⊢ \t("v.lj") : A_j}
$$
$$
  \unaryRN{+_i}{Γ ⊢ v : A_j}{Γ ⊢ \t("Cj[v]") : \f("[(Ci : Ai) i∈I]")}
  \hspace(2.0)
  \binaryRN{+_e}{Γ ⊢ v : \f("[(Ci : Ai) i∈I]")}{
    [Γ, x_i : A_i ⊢ t_i : B]_{i∈I}
  }{
    Γ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B
  }
$$
\end{def}

As a first example, we can show that the term $\t("λx λy {l₁ = x; l₂ = y;}")$
can be given the type $\f("A ⇒ B ⇒ {l₁ : A; l₂ : B;}")$ in any context $Γ$
and for any given types $A$ and $B$.
$$
  \proofTree{
    \unaryN{⇒_i}{
      Γ ⊢ \t("λx λy {l₁ = x; l₂ = y;}") : \f("A ⇒ B ⇒ {l₁ : A; l₂ : B;}")
    }{
      \unaryN{⇒_i}{
        Γ, x : A ⊢ \t("λy {l₁ = x; l₂ = y;}") : \f("B ⇒ {l₁ : A; l₂ : B;}")
      }{
        \binaryN{×_i}{
          Γ, x : A, y : B ⊢ \t("{l₁ = x; l₂ = y;}") : \f("{l₁ : A; l₂ : B;}")
        }{
          \axiomN{Ax}{Γ, x : A, y : B ⊢ x : A}
        }{
          \axiomN{Ax}{Γ, x : A, y : B ⊢ y : B}
        }
      }
    }
  }
$$
Similarly, we can show that the term $λx λy x y$ has type $(A ⇒ B) ⇒ A ⇒ B$
in any context $Γ$ and for any given types $A$ and $B$.
$$
  \proofTree{
    \unaryN{⇒_i}{
      Γ ⊢ \t("λx λy x y") : \f("(A ⇒ B) ⇒ A ⇒ B")
    }{
      \unaryN{⇒_i}{
        Γ, x : \f("A ⇒ B") ⊢ \t("λy x y") : \f("A ⇒ B")
      }{
        \binaryN{⇒_e}{
          Γ, x : \f("A ⇒ B"), y : A ⊢ \t("x y") : B
        }{
          \axiomN{Ax}{Γ, x : \f("A ⇒ B"), y : A ⊢ x : \f("A ⇒ B")}
        }{
          \axiomN{Ax}{Γ, x : \f("A ⇒ B"), y : A ⊢ y : A}
        }
      }
    }
  }
$$


(*
\begin{def}
A context over $t$ is a finite map $Γ$ over $\cal{V}_λ$ and $\cal{V}_μ$ such
that for all $λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$ and for all
$μ$-variable $α ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent contexts using lists generated using the following ||bnf|| grammar.
$$ Γ ::= • \| {Γ, x : A} \| {Γ, α : A^⊥} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that their order is irrelevant.
\end{def}

$$
  \unaryRN{μ}{Γ, α : A^⊥ ⊢ t : A}{Γ ⊢ \t("μα t") : A}
  \hspace(4.0)
  \unaryRN{[\wc]}{Γ, α : A^⊥ ⊢ t : A}{Γ, α : A^⊥ ⊢ \t("[α]t") : B}
$$
*)


Throught the Curry-Howard isomorphism, our type system can be seen as a
logic. Types then correspond to formulas that can be proved using deduction
rules. In our simple type system, the structure of a derivation is completely
determined by the terms of the \lmcalc. Consequently, we may think of
a well-typed term as a proof of the formula corresponding to its type.
Following this analogy, the function type can be read as logical implication,
our product type can be read as conjunction and our sum type can be read as
disjunction. Note that a context cas be seen as a list of assumptions, hence
the truth of a formula can only been established in an empty context.

As our calculus contains control structures, the logic corresponding to our
type system is not limited to intuitionisticaly valid formulas. Indeed,
control structures have been shown to give a computational interpretation to
classical logic by Timothy Griffin \cite("Griffin1990"). As an example, the
following type derivation shows that the term $\t("λf μα f λx [α]x")$ can be
given a type corresponding to Peirce's Law in any context $Γ$.
\begin{env}(scale 0.85)
$$
  \proofTree{
    \unaryN{⇒_i}{
      Γ ⊢ \t("λf μα f λx [α]x") : \f("((A ⇒ B) ⇒ A) ⇒ A")
    }{
      \unaryN{μ}{
        Γ, f:\f("(A ⇒ B) ⇒ A") ⊢ \t("μα f λx [α]x") : A
      }{
        \binaryN{⇒_e}{
          Γ, f:\f("(A ⇒ B) ⇒ A"), α:A^⊥ ⊢ \t("f λx [α]x") : A
        }{
          \axiomN{Ax}{Γ, f:\f("(A ⇒ B) ⇒ A"), α:A^⊥ ⊢ f : \f("(A ⇒ B) ⇒ A")}
        }{
          \unaryN{⇒_i}{
            Γ, f:\f("(A ⇒ B) ⇒ A"), α:A^⊥ ⊢ \t("λx [α]x") : \f("A ⇒ B")
          }{
            \unaryN{[{-}]}{
              Γ, f:\f("(A ⇒ B) ⇒ A"), α:A^⊥, x:A ⊢ \t("[α]x") : A
            }{
              \axiomN{Ax}{Γ, f:\f("(A ⇒ B) ⇒ A"), α:A^⊥, x:A ⊢ x : A}
            }
          }
        }
      }
    }
  }
$$
\end{env}

=<

=> Polymorphism and universal quantification

Let us consider the term $λx λy x$, which can be given the type $X ⇒ Y ⇒ X$
as show in the previous section. This term really corresponds to a function
taking as input two arguments, and returning the first directly. Note that
we do not need to say anything about the nature of the arguments this
function may accepts. In fact, this function can be applied to arguments
of any two types. This information is not conveyed by the type $X ⇒ Y ⇒ X$,
as it only specifies that the function takes arguments of two particular
types $X$ and $Y$, and returns an element of type $X$.

To solve this expressivity problem, we extend our type system with a new
type constructor for universal quantification, or polymorphism. We will then
be able to use types like $∀X ∀Y X ⇒ Y ⇒ X$. The obtained system is called
System F, it was introduced by Jean-Yves Girard and John Reynolds
independently \mcite(["Girard1972";"Reynolds1974"]).

\begin{def}
The set of types (or formulas) is extended with universal quantification. It
is now defined using the following BNF grammar.
$$A,B ::= {X} \| {A ⇒ B} \| {∀X A} \hspace(4.0) X ∈ \cal{V}_\cal{F}$$
\end{def}
\begin{rem}
To lighten the notations, we will consider that universal quantification
binds stronger than the function type. As a consequence, we will read
$∀X ∀Y X ⇒ Y ⇒ X$ as $∀X (∀Y (X ⇒ (Y ⇒ X)))$.
\end{rem}

$$
  \binaryRN{{∀}_i}{Γ ⊢ t : A}{X ∉ FV(Γ)}{Γ ⊢ t : ∀X A}
  \hspace(2.0)
  \unaryRN{{∀}_e}{Γ ⊢ t : ∀X A}{Γ ⊢ t : A[X := B]}
$$

$$
  \proofTree{
    \binaryN{∀_i}{⊢ λx λy x : ∀X ∀Y X ⇒ Y ⇒ X}{
      \binaryN{∀_i}{X ⊢ λx λy x : ∀Y X ⇒ Y ⇒ X}{
        \unaryN{⇒_i}{X, Y ⊢ λx λy x : X ⇒ Y ⇒ X}{
          \unaryN{⇒_i}{X, Y, x : X ⊢ λy x : Y ⇒ X}{
            \axiomN{Ax}{X, Y, x : X, y : Y ⊢ x : X}
          }
        }
      }{\hyp{Y ∉ FV(X,Y)}}
    }{\hyp{X ∉ FV(X)}}
  }
$$

=<

=> Value restriction

A soundness issue related to side-effects and call-by-value evaluation
arose in the seventies with the advent of ML. The problem stems from a
bad interaction between side-effects and Hindley-Milner polymorphism. It was
first formulated in terms of references \citen("Wright1995")("Section 2"),
and many alternative type systems were designed (e.g. \mcite(["Tofte1990";
"Damas1982"; "Leroy1991"; "Leroy1993"])) However, they all introduced a
complexity that contrasted with the elegance and simplicity of ML's type
system (for a detailed account, see \citen("Wright1995")("Section 2") and
\citen("Garrigue2004")("Section 2")).

A simple and elegant solution was finally found by Andrew Wright in the
nineties. He suggested restricting generalization in let-bindings to cases
where the bound term is a syntactic value \mcite(["Wright1994";"Wright1995"]).
In ML the polymorphism mechanism is strongly linked with let-bindings. In
OCaml syntax, they are expressions of the form ##let x = u in t##. In slightly
more expressive type systems, this restriction appears in the typing rule for
the introduction of the universal quantifier.
$$ \binaryR{Γ ⊢ t : A}{X ∉ FV(Γ)}{Γ ⊢ t : ∀X A} $$
This rule cannot be proved safe (in a call-by-value system with side-effects)
if $t$ is not a syntactic value.
(* *)
Similarly, the elimination rule for dependent product (shown previously)
requires value restriction. It is possible to exhibit a counter-example
breaking the type safety of our system if it is omitted. (* TODO *)

In this paper, we consider control structures, which have been shown to give
a computational interpretation to classical logic by Timothy Griffin
\cite("Griffin1990").
(* *)
In 1991, Robert Harper and Mark Lillibridge found a complex program breaking
the type safety of ML extended with \emph{call/cc} \cite("Harper1991").
As with references, value restriction solves the inconsistency and yields a
sound type system. 
(* *)
Instead of using control operators like \emph{call/cc}, we adopt the syntax
of Michel Parigot's $λμ$-calculus \cite("Parigot1992"). Our language hence
contains a new binder $μα t$ capturing the continuation in the $μ$-variable
$α$. The continuation can then be restored in $t$ using the syntax $[α]u$.
(* *)
In the context of the $λμ$-calculus, the soundness issue arises when
evaluating $t (μα u)$ when $μα u$ has a polymorphic type. Such a situation
cannot happen with value restriction since $μα u$ is not a value.

=<

=> Higher-order logic

\begin{def}
The set of sorts $\cal{S}$ is generated from a set of atomic sorts $\cal{S}₀$
with $ο ∈ \cal{S}₀$, using the following BNF grammar.
$$ s,r ::= {s → r} \| ξ \hspace(4.0) ξ ∈ \cal{S}₀ $$
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is generated from a set of type
variables $\cal{F}₀$ using the following BNF grammar.
$$
  A,B ::= χ \| (χ^s ↦ A) \| A(B) \| {∀χ^s A} \| {∃χ^s A} \| {A ⇒ B} \|
          \{l_i : A_i\}_{i∈I} \| [l_i : A_i]_{i∈I}
$$
\end{def}

(* Sorting rules. *)
$$
\binaryR{Δ ⊢ A : ο}{Δ ⊢ B : ο}{Δ ⊢ A ⇒ B : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ \{l_i : A_i\}_{i∈I} : ο}
\hspace(3.0)
\unaryR{\{Δ ⊢ A_i : ο\}_{i∈I}}{Δ ⊢ [C_i : A_i]_{i∈I} : ο}
$$
$$
\axiomR{Δ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ E : r}{Δ ⊢ (χ^s ↦ E) : s → r}
\hspace(3.0)
\binaryR{Δ ⊢ E : s → r}{Δ ⊢ F : s}{Δ ⊢ E(F) : r}
$$
$$
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∀χ^s A : ο}
\hspace(3.0)
\unaryR{Δ, χ : s ⊢ A : ο}{Δ ⊢ ∃χ^s A : ο}
$$
$$
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ μX A : ο}
\hspace(3.0)
\binaryR{Δ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Δ ⊢ νX A : ο}
$$
(* TODO *)

=<

=> Full type system

In this section, we present the higher-order type system that will serve as
a base for the work presented in this thesis. Although the following extends
definitions given in the previous sections, we choose not to avoid
repetitions so that this section remains completely self-contained.

In this thesis, we consider a programming language that is very similar to
the functional programming languages of the ||ml|| family (e.g. SML or
OCaml). In the following, we provide a full formal definition of such a
type system. It will provide a product type for records, a sum type for
variants, polymorphism and higher-order quantification, least and greatest
fixpoints.
\begin{def}
We denote $\cal{S}₀$ the set of all the atomic sorts. We require this set to
be finite (or at least countable), and to contain the sort of propositions
denoted $ο$.
\end{def}
\begin{def}
The set of all the sorts is generated from the set of atomic sorts $\cal{S}₀$
using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= {s→r} \| ξ$ >> << $ξ∈\cal{S}₀$ >>)
\end{def}
\begin{def}
We require disjoint countable sets of variables $\cal{V}_s$ for every sort
$s ∈ \cal{S}$. In particular, we will take $\cal{V}_ο = \{X, Y, Z...\}$. The
set of all the variables is denoted $\cal{V}$ and is defined as
$\cal{V} = \bigunion_{s∈\cal{S}} \cal{V}_s$.
\end{def}
\begin{def}
The set of types (or formulas) $\cal{F}$ is generated from the set $\cal{V}$
using the following ||bnf|| grammar.
$$
  A,B ::= \f("χ") \| \f("(χ ↦ A)") \| \f("A(B)") \| \f("A ⇒ B") \|
          \f("{(li : Ai) i∈I}") \mbr \| \f("[(Ci : Ai) i∈I]")
          \| \f("∀χ A") \| \f("∃χ A") \| \f("μX A") \| \f("νX A")
$$
\end{def}
\begin{def}
A //sorting context// is a finite map $Σ$ over $\cal{V}$ such that for all
$χ ∈ dom(Σ)$ we have $Σ(χ) ∈ \cal{S}$. For convenience, sorting contexts are
represented using comma-separated lists of sort assignments of the form
$χ : s$. variable of $\cal{V}$ are mapped at most onces in a sorting context,
and their order is irrelevant.
\end{def}

\begin{def}
A sorting judgment is a trile of a sorting context $Σ$, a type $A$ and a sort
$s$ denoted $Σ ⊢ A : s$. We say that the sorting judgment $Σ ⊢ A : s$ is
valid if and only if it can be derived using the following rules.
$$
\axiomR{Σ, χ : s ⊢ χ : s}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("(χ ↦ A)") : s → r}
\hspace(3.0)
\binaryR{Σ ⊢ A : s → r}{Σ ⊢ B : s}{Σ ⊢ \f("A(B)") : r}
$$
$$
\binaryR{Σ ⊢ A : ο}{Σ ⊢ B : ο}{Σ ⊢ A ⇒ B : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("{(li : Ai) i∈I}") : ο}
\hspace(3.0)
\unaryR{\{Σ ⊢ A_i : ο\}_{i∈I}}{Σ ⊢ \f("[(Ci : Ai) i∈I]") : ο}
$$
$$
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∀χ A") : r}
\hspace(3.0)
\unaryR{Σ, χ : s ⊢ A : r}{Σ ⊢ \f("∃χ A") : r}
\hspace(3.0)
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("μX A") : ο}
$$
$$
\binaryR{Σ, X : ο ⊢ A : ο}{X ∉ FV^{-}(A)}{Σ ⊢ \f("νX A") : ο}
$$
\end{def}

\begin{def}
A typing context is a finite map $Γ$ over $\cal{V}_λ$ and $\cal{V}_μ$ such
that for all $λ$-variable $x ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$ and for all
$μ$-variable $α ∈ dom(Γ)$ we have $Γ(x) ∈ \cal{F}$. For convenience, we will
represent typing contexts using comma-separated lists of mappings generated
of the form $x : A$ or $α : A^⊥$. Note that variables can only be mapped once
in a typing context, and that their order is irrelevant.
\end{def}
\begin{def}
A typing context $Γ$ is said to be valid under a sorting context $Σ$ if for
all mapping $x:A$ or $α:A^⊥$ in $Γ$ the judgment $Σ ⊢ Γ(x) : ο$ is valid. If
$Γ$ is valid under $Σ$ then we write $Σ ⊢ Γ$.
\end{def}

(* Typing rules. *)
$$
  \axiomRN{Ax}{Γ, x : A ⊢_\tval x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢_\tval λx t: A ⇒ B}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : A ⇒ B}{Γ ⊢ u : A}{Γ ⊢ (t) u : B}
$$
$$
  \unaryRN{↑}{Γ ⊢_\tval v : A}{Γ ⊢ v : A}
  \hspace(4.0)
  \unaryRN{μ}{Γ, α : ¬A ⊢ t : A}{Γ ⊢ μα t : A}
  \hspace(4.0)
  \unaryRN{[{-}]}{Γ, α : ¬A ⊢ t : A}{Γ, α : ¬A  ⊢ [α] t : B}
$$
$$
  \binaryRN{∀_i}{Γ, X_n ⊢_\tval v : A}{X_n ∉ FV(Γ)}{Γ ⊢_\tval v : ∀X_n A}
  \hspace(4.0)
  \unaryRN{∀_e}{Γ ⊢ t : ∀X_n A}{Γ ⊢ t : A[X_n := P_n]}
$$
$$
  \unaryRN{∃_i}{Γ ⊢ t : A[X_n := P_n]}{Γ ⊢ t : ∃X_n A}
  \hspace(4.0)
  \binaryRN{∃_e}{Γ, X_n, x : A ⊢ t : B}{X_n ∉ FV(Γ,B)}{Γ, x : ∃X_n A ⊢ t : B}
$$
$$
  \unaryRN{×_i}{[Γ ⊢_\tval v_i : A_i]_{1≤i≤n}}{
    Γ ⊢_\tval \{l_i = v_i\}_{1≤i≤n} : \{l_i : A_i\}_{1≤i≤n}
  }
  \hspace(4.0)
  \unaryRN{×_e}{Γ ⊢_\tval v : \{l_i : A_i\}_{1≤i≤n}}{Γ ⊢ v{.}l_i : A_i}
$$
$$
  \unaryRN{+_i}{Γ ⊢_\tval v : A_i}{Γ ⊢ C_i[v] : [C_i : A_i]_{1≤i≤n}}
  \hspace(1.0)
  \binaryRN{+_e}{Γ ⊢_\tval v : [C_i : A_i]_{1≤i≤n}}{
    [Γ, x_i : A_i ⊢ t_i : B]_{1≤i≤n}
  }{
    Γ ⊢ case_v [C_i[x_i] → t_i]_{1≤i≤n} : B
  }
$$

=<

=> Call-by-value realisability model

... (* TODO *)

=<

=<
