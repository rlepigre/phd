\Caml(
open Decap

type vari = string * int option

type valu =
  | VVari of vari               (* x, y   *)
  | VMeta of vari               (* v, w   *)
  | VLAbs of vari * term        (* λx t   *)
and  term =
  | TVari of vari               (* a, b   *)
  | TMeta of vari               (* t, u   *)
  | TValu of valu
  | TGrou of term               (* (t)    *)
  | TAppl of term * term        (* t u    *)
  | TSave of vari * term        (* μα t   *)
  | TRest of stac * term        (* [π]t   *)
  | TSubs of term * vari * valu (* t[x≔v] *)
  | TCtxt of ctxt * term        (* E[t]   *)
and  ctxt =
  | CHole                       (* [-]    *)
  | CMeta of vari               (* E, F   *)
  | CGrou of ctxt               (* (E)    *)
  | CLAbs of vari * ctxt        (* λx E   *)
  | CAppL of ctxt * term        (* E t    *)
  | CAppR of term * ctxt        (* t E    *)
and  stac =
  | SEmpt                       (* ε      *)
  | SVari of vari               (* α, β   *)
  | SMeta of vari               (* π, ρ   *)
  | SPush of valu * stac        (* v.π    *)
  | SFram of term * stac        (* [t]π   *)
and  proc =
  | PMeta of vari               (* p, q   *)
  | PProc of term * stac        (* t ∗ π  *)

let parser index =
  | "₀" -> 0 | "₁" -> 1 | "₂" -> 2 | "₃" -> 3 | "₄" -> 4
  | "₅" -> 5 | "₆" -> 6 | "₇" -> 7 | "₈" -> 8 | "₉" -> 9

let parser vari p = x:p i:index? _:relax
let vari ns = vari (alternatives (List.map (fun n -> string n n) ns))

let vvari = vari ["x"; "y"; "z"]
let vmeta = vari ["v"; "w"]
let tvari = vari ["a"; "b"; "c"]
let tmeta = vari ["t"; "u"]
let cmeta = vari ["E"; "F"]
let svari = vari ["α"; "β"; "γ"]
let smeta = vari ["π"; "ρ"]
let pmeta = vari ["p"; "q"]

let appl = List.fold_left (fun t u -> TAppl(t,u))

type prio = Atom | Subs | Appl

let parser valu =
  | x:vvari                                                   -> VVari(x)
  | v:vmeta                                                   -> VMeta(v)
  | "λ" x:vvari t:(term Appl)                                 -> VLAbs(x,t)
and        term prio =
  | a:tvari                                  when prio = Atom -> TVari(a)
  | t:tmeta                                  when prio = Atom -> TMeta(t)
  | v:valu                                   when prio = Atom -> TValu(v)
  | '(' t:(term Appl) ')'                    when prio = Atom -> TGrou(t)
  | t:(term Subs) ts:(term Subs)*$           when prio = Appl -> appl t ts
  | "μ" a:svari t:(term Appl)                when prio = Atom -> TSave(a,t)
  | '[' s:stac ']' t:(term Appl)             when prio = Atom -> TRest(s,t)
  | t:(term Atom) '[' x:vvari "≔" v:valu ']' when prio = Subs -> TSubs(t,x,v)
  | c:(ctxt Atom) '[' t:(term Appl) ']'      when prio = Atom -> TCtxt(c,t)
  | t:(term Atom)                            when prio = Subs -> t
and        ctxt prio =
  | "[]"                                     when prio = Atom -> CHole
  | e:cmeta                                  when prio = Atom -> CMeta(e)
  | '(' e:(ctxt Appl) ')'                    when prio = Atom -> CGrou(e)
  | "λ" x:vvari e:(ctxt Appl)                when prio = Atom -> CLAbs(x,e)
  | e:(ctxt Subs) t:(term Atom)              when prio = Appl -> CAppL(e,t)
  | t:(term Atom) e:(ctxt Subs)              when prio = Appl -> CAppR(t,e)
  | e:(ctxt Atom)                            when prio = Subs -> e
  | e:(ctxt Subs)                            when prio = Appl -> e
and        stac =
  | "ε"                                                       -> SEmpt
  | a:svari                                                   -> SVari(a)
  | s:smeta                                                   -> SMeta(s)
  | v:valu '.' s:stac                                         -> SPush(v,s)
  | '[' t:(term Appl) ']' s:stac                              -> SFram(t,s)
and        proc =
  | p:pmeta                                                   -> PMeta(p)
  | t:(term Appl) "∗" s:stac                                  -> PProc(t,s)

let term = term Appl
let ctxt = ctxt Appl

let parse g =
  let parse = parse_string g (blank_regexp ''[ ]*'') in
  handle_exception parse

let parse_valu = parse valu
let parse_term = parse term
let parse_ctxt = parse ctxt
let parse_stac = parse stac
let parse_proc = parse proc

let _ = parse_valu "λx x"
let _ = parse_valu "λx λy x"
let _ = parse_term "(λx x x) (λx x x)"

)
