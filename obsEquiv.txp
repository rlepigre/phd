\Caml(
open Diagrams
open ProofTree
open LCKAM.Lang
open Lang
)
\Include{Macros}

=> Observational equivalence of programs \label("obsEquiv")

In this chapter, we define a notion of equivalence over programs. We
will see two programs as equivalent if they have the same observable
behaviour in terms of computation. A partial axiomatization of the
corresponding equivalence relation is provided to allow for the
implementation of a partial decision procedure.

=> Definitions of equivalence

We will now consider a notion of //observational equivalence// over
terms. More precisely, we will say that two terms are equivalent if
they have the same computational behaviour in every evaluations
context. Using the formalism of our abstract machine, it is very
easy to quantify over every evaluation contexts. Indeed, this only
amounts to quantifying over every stacks. In this thesis, the
considered observable behaviour is successful termination (versus
non-termination or runtime error).
\begin{def}
We say that a process $p ∈ Λ×Π$ converges, and we write $p {⇓}_{≻}$,
if there is a final state $q ∈ Λ×Π$ such that $p ≻^{∗} q$. If $p$
does not converge we say that it diverges and we write $p {⇑}_{≻}$.
\end{def}

The idea now is to relate terms that form converging processes when put
against exactly the same stacks. However, with such a definition, free
variables cannot be distinguished. Therefore, we not only quantify over
stacks, but also over substitutions.
\begin{def}
The relation $({≡}_{≻}) ⊆ {Λ×Λ}$ is defined as follows.
$$ ({≡}_{≻}) = \{(t, u) \| ∀{π∈Π}, ∀{ρ∈\cal{S}},
     {{\p("tρ∗π")} {⇓}_{≻}} ⇔ {{\p("uρ∗π")} {⇓}_{≻}}\} $$
\end{def}
\begin{lem}
$({≡}_{≻})$ is an equivalence relation.
\begin{proof}
Immediate.
\end{proof}
\end{lem}

We will now provide a second (to be proved equivalent) definition of
$({≡}_{≻})$. We will then use whichever definition is most convenient
depending on our need. Our two definitions are very similar, the only
difference is that the substitution is only applied to the terms in
the first one, and it is applied to the whole processes in the second
one.
\begin{def}
The relation $({\iso}_{≻}) ⊆ {Λ×Λ}$ is defined as follows.
$$ ({\iso}_{≻}) = \{(t, u) \| ∀{π∈Π}, ∀{ρ∈\cal{S}},
     {{\p("(t∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("(u∗π)ρ")} {⇓}_{≻}}\} $$
\end{def}
\begin{thm}\label("equivsame")
For every term $t$, $u ∈ Λ$ we have $t ≡_{≻} u$ if and only if
$t \iso_{≻} u$.
\begin{proof}
We first suppose that $t ≡_{≻} u$ and show $t \iso_{≻} u$. Let us take
$π∈Π$ and $ρ∈\cal{S}$. By symmetry, we assume ${\p("(t∗π)ρ")} {⇓}_{≻}$
and show ${\p("(u∗π)ρ")} {⇓}_{≻}$. As
${\p("(t∗π)ρ")} = {\p("tρ∗πρ")} {⇓}_{≻}$, we obtain
${\p("uρ∗πρ")} = {\p("(u∗π)ρ")} {⇓}_{≻}$ since $t ≡_{≻} u$.

Let us now suppose that $t \iso_{≻} u$ and show $t ≡_{≻} u$. We take
$π∈Π$ and $ρ∈\cal{S}$. By symmetry, we assume ${\p("tρ∗π")} {⇓}_{≻}$ and
show ${\p("uρ∗π")} {⇓}_{≻}$. As the substitution $ρ$ binds variables in
$t$, we may rename them in such a way that $FV(t) ∩ dom(ρ) = ∅$. Therefore
we obtain $\p("tρ∗π") = \p("tρ∗πρ") = {\p("(t∗π)ρ")} {⇓}_{≻}$, and thus
$\p("(u∗π)ρ") = \p("uρ∗πρ") = {\p("uρ∗π")} {⇓}_{≻}$ since $t \iso_{≻} u$.
This exactly means that $t ≡_{≻} u$.
\end{proof}
\end{thm}

=<

=> Equivalences from reduction

The equivalence relation $({≡}_{≻})$ identifies terms with the same
computational behaviour. In particular, taking reduction steps does
not fundamentally change the observable computational behaviour of
a term. We can thus derive several primitive equivalences based on
the definition of our $({≻})$ reduction relation using the following
two lemmas.
\begin{lem}\label("redequiv")
Let $t$, $u ∈ Λ$ be two terms. If for all stack $π∈Π$ there is a
process $p ∈ Λ×Π$ such that $\p("t ∗ π") ≻^{∗} p$ and
$\p("u ∗ π") ≻^{∗} p$ then $t ≡_{≻} u$.
\begin{proof}
Let us take $π ∈ Π$ and $ρ ∈ \cal{S}$. By hypothesis $\p("t∗π") ≻^{∗} p$
and $\p("u∗π") ≻^{∗} p$ for some $p ∈ Λ×Π$. Using \thmRef("redcompatall")
we obtain $\p("(t∗π)ρ") ≻^{∗} \p("pρ")$ and $\p("(u∗π)ρ") ≻^{∗} \p("pρ")$.
Consequently, ${{\p("(t∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("pρ")} {⇓}_{≻}}$ and
${{\p("(u∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("pρ")} {⇓}_{≻}}$. We hence have
${{\p("(t∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("(u∗π)ρ")} {⇓}_{≻}}$, which gives
us $t ≡_{≻} u$ using \thmRef("equivsame").
\end{proof}
\end{lem}
\begin{lem}\label("redtosame")
Let $t$, $u∈Λ$ be two terms. If we have $\p("t∗π") ≻^{∗} \p("u∗π")$ for
every stack $π∈Π$ then $t ≡_{≻} u$.
\begin{proof}
Direct conseqence of \lemRef("redequiv") using $p = \p("u∗π")$.
\end{proof}
\end{lem}

Based on the reduction rules of our abstract machine, we can derive four
immediate equivalences corresponding to record projection, case analysis,
the unfolding of the fixpoint combinator and the elimination of the special
term $\t("U({})")$. Indeed, the corresponding reduction rules do not
involve an interaction with the stack. In particular, they leave the stack
unchanged.
\begin{thm}
Let $I$ be a finite set of indices such that $v_i ∈ Λ_ι$ for all $i ∈ I$.
If $k ∈ I$ then $\t("{(li = vi) i∈I}.lk") ≡_{≻} \t("vk")$.
\begin{proof}
Since $\p("{(li = vi) i∈I}.lk ∗ π") ≻ \p("vk ∗ π")$ for all $π$ we
can use \lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
Let $v ∈ Λ_ι$ be a value and $I$ be a finite set of indices such that for
all $i ∈ I$ we have $x_i ∈ \cal{V}_ι$ and $\t("ti") ∈ Λ$. If $k ∈ I$ then
$\t("[Ck[v]|(Ci[xi] → ti) i∈I]") ≡_{≻} \t("tk[xk≔v]")$.
\begin{proof}
Since $\p("[Ck[v]|(Ci[xi] → ti) i∈I] ∗ π") ≻ \p("tk[xk≔vk] ∗ π")$ for
every stack $π$ we can use \lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
For every $t ∈ Λ$ and $v ∈ Λ_ι$ we have
$\t("Y(t,v)") ≡_{≻} \t("t (λx Y(t,x)) v")$.
\begin{proof}
Since $\p("Y(t,v) ∗ π") ≻ \p("t (λx Y(t,x)) v ∗ π")$ for every stack $π$
we can use \lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
We have $\t("U({})") ≡_{≻} \t("{}")$.
\begin{proof}
Since $\p("U({}) ∗ π") ≻ \p("{} ∗ π")$ for every stack $π$ we can use
\lemRef("redtosame").
\end{proof}
\end{thm}

To go a little bit further, we can look at the first three rules of
\defRef("reduction"), which are used to handle $β$-reduction. In
particular, these three rules can be composed immediatly in the case
where we consider the application of a $λ$-abstraction to a value.
This corresponds exactly to the call-by-value $β$-reduction relation.
\begin{thm}\label("cbvbeta")
For every $t ∈ Λ$, $v ∈ Λ_ι$ and $x ∈ \cal{V}_ι$ we have
$\t("(λx t) v") ≡_{≻} \t("t[x≔v]")$.
\begin{proof}
Since $\p("(λxt) v∗π") ≻ \p("v∗[λxt]π") ≻ \p("λxt∗v·π") ≻ \p("t[x≔v]∗π")$
for all $π$ we can apply \lemRef("redtosame") to conclude.
\end{proof}
\end{thm}
(* FIXME Enlever ? Conjecture à la fin ? (Christophe) *)
Similarly, it seems to be possible to prove an equivalence corresponding
to (a call-by-value version of) the $η$-equivalence relation. We only
include it as a claim as the author did not write a full proof.
\begin{clm}
For every $u ∈ Λ$ and $x$, $y ∈ \cal{V}_ι$ such that $x ∉ FV(u)$ we have
$\t("λy u") ≡_{≻} \t("λx (λy u) x")$.
\end{clm}

The reduction rule for processes of the form $\p("μα t ∗ π")$ is inherently
non-local. Indeed, the bound $μ$-variable can be substituted anywhere in $t$
and any reduction rule may apply afterwards (depending on the form of $t$
and $π$). However, we can still derive equivalences corresponding
to the usual reduction rules of the \lmcalc \cite("Parigot1992"). In
particular, we can obtain two equivalences corresponding to call-by-value
//structural reductions//.
\begin{thm}
For every $t$, $u ∈ Λ$ and $α$, $β ∈ \cal{V}_σ$ such that $β ∉ FV(t)$ and
$β ∉ FV(u)$ we have $\t("t (μα u)") ≡_{≻} \t("μβ t u[α≔[t]β]")$.
\begin{proof}
Since for every stack $π$ we have
$\p("t (μα u) ∗ π") ≻ \p("μα u ∗ [t]π") ≻ \p("u[α≔[t]π] ∗ [t]π")$
and
$\p("μβ t u[α≔[t]β] ∗ π") ≻ \p("t u[α≔[t]π] ∗ π") ≻ \p("u[α≔[t]π] ∗ [t]π")$
we can conclude using \lemRef("redequiv").
\end{proof}
\end{thm}
\begin{thm}
For every $t ∈ Λ$, $v ∈ Λ_ι$ and $α$, $β ∈ \cal{V}_σ$ such that $β ∉ FV(t)$
and $β ∉ FV(v)$ we have $\t("(μα t) v") ≡_{≻} \t("μβ t[α≔v·β] v")$.
\begin{proof}
Since we have
$\p("(μαt) v∗π") ≻ \p("v∗[μαt]π") ≻ \p("μαt∗v·π") ≻ \p("t[α≔v·π]∗v·π")$
and
$\p("μβ t[α≔v·β] v ∗ π") ≻ \p("t[α≔v·π] v ∗ π") ≻ \p("v ∗ [t[α≔v·π]]π") ≻
  \p("t[α≔v·π]∗v·π")$
for all stack $π$, we can conclude using \lemRef("redequiv").
\end{proof}
\end{thm}
Similarly, the following theorem provides an equivalence corresponding to
//renaming//. Note that our version of renaming is more general than the
one found in \cite("Parigot1992") as our formalism includes stacks. Indeed,
only $μ$-variables can be used in named terms in the original version of
the \lmcalc.
\begin{thm}
For every $ξ∈Π$, $β ∈ \cal{V}_σ$ and $t ∈ Λ$ we have
$\t("[ξ]μβ t") ≡_{≻} \t("[ξ]t[β≔ξ]")$.
\begin{proof}
As $\p("[ξ]μβ t ∗ π") ≻ \p("μβ t ∗ ξ") ≻ \p("t[β≔ξ] ∗ ξ")$ and
$\p("[ξ]t[β≔ξ] ∗ π") ≻ \p("t[β≔ξ] ∗ ξ")$ we can conclude using
\lemRef("redequiv").
\end{proof}
\end{thm}

As a named term has the effect of erasing the whole stack. Consequently,
terms that are applied (as functions) to a named term can always be
removed. Similarly, values used as arguments of a named term can be
removed as they will never be considered. The following two theorems will
hence allow us to discard unnecessary subterms as early as possible, when
attempting to prove an equivalence.
\begin{thm}
For every $t ∈ Λ$, $v ∈ Λ_ι$ and $ξ ∈ Π$ we have
$\t("([ξ]t) v") ≡_{≻} \t("[ξ]t")$.
\begin{proof}
Since for every stack $π$ we have
$\p("([ξ]t) v ∗ π") ≻ \p("v ∗ [[ξ]t]π") ≻ \p("[ξ]t ∗ v·π") ≻ \p("t∗ξ")$
and $\p("[ξ]t ∗ π") ≻ \p("t∗ξ")$
we can conclude using \lemRef("redequiv").
\end{proof}
\end{thm}
\begin{thm}
For every $t$, $u ∈ Λ$ and $ξ ∈ Π$ we have
$\t("t ([ξ]u)") ≡_{≻} \t("[ξ]u")$.
\begin{proof}
Since we have $\p("t ([ξ]u) ∗ π") ≻ \p("[ξ]u ∗ [t]π") ≻ \p("u∗ξ")$
and $\p("[ξ]u ∗ π") ≻ \p("u∗ξ")$ for every stack $π$, we can conclude
using \lemRef("redequiv").
\end{proof}
\end{thm}

We can also remark that saving the stack twice in a row using two
consecutive $μ$-abstractions leads to saving the same stack twice.
We can thus obtain the same computational behaviour by saving the
stack only once. Similarly, using two named terms in a row is the
same as using only the later one.
\begin{thm}
For every $α$, $β ∈ \cal{V}_σ$ and $t ∈ Λ$ we have
$\t("μαμβ t") ≡_{≻} \t("μβ t[α≔β]")$.
\begin{proof}
We have $\p("μαμβ t ∗ π") ≻ \p("μβ t[α≔π] ∗ π") ≻ \p("(t[α≔π])[β≔π] ∗ π")$
and we also have $\p("μβ t[α≔β] ∗ π") ≻ \p("(t[α≔β])[β≔π] ∗ π")$. To be able
to conclude using \lemRef("redequiv") we need to show that
$\t("(t[α≔π])[β≔π]") = \t("(t[α≔β])[β≔π]")$. This is immediate as we may
assume $α ∉ FV_σ(π)$ and $β ∉ FV_σ(π)$ up to renaming.
\end{proof}
\end{thm}
\begin{thm}
For every $ξ₁$, $ξ₂ ∈ Π$ and $t ∈ Λ$ we have
$\t("[ξ₁][ξ₂]t") ≡_{≻} \t("[ξ₂]t")$.
\begin{proof}
As we have $\p("[ξ₁][ξ₂]t ∗ π") ≻ \p("[ξ₂]t ∗ ξ₁") ≻ \p("t ∗ ξ₂")$ and
$\p("[ξ₂]t ∗ π") ≻ \p("t ∗ ξ₂")$ for all $π$ we can use \lemRef("redequiv").
\end{proof}
\end{thm}

Finaly, we provide two last equivalences allowing the simplification of
terms involving $μ$-abstractions. For instance, if the variable bound by
a $μ$-abstraction does not occur in its body, then it can be removed.
Similarly, it is not useful to restore a stack right after it has been
saved.
\begin{thm}
For every $α ∈ \cal{V}_σ$ and $t ∈ Λ$ such that $α ∉ FV_σ(t)$ we have
$\t("μα t") ≡_{≻} t$.
\begin{proof}
As we have $\p("μα t ∗ π") ≻ \p("t[α≔π] ∗ π") = \p("t ∗ π")$ we can use
\lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
For every $α ∈ \cal{V}_σ$ and $t ∈ Λ$ we have $\t("μα[α]t") ≡_{≻} \t("μαt")$.
\begin{proof}
As $\p("μα [α]t ∗ π") ≻ \p("[π]t[α≔π] ∗ π") = \p("t[α≔π] ∗ π")$ and
$\p("μα t ∗ π") ≻ \p("t[α≔π] ∗ π")$ for all $π$ we can use
\lemRef("redequiv").
\end{proof}
\end{thm}
Note that we can compose the previous two theorems to obtain
$\t("μα [α]t") ≡ t$ in the case where $α ∉ FV_σ(t)$. This can
be seen as a form of $η$-equivalence for $μ$-abstraction, as
remarked by Michel Parigot in \cite("Parigot1992").

=<

=> Inequivalences from counter-examples

Using the theorems of the previous section, it is possible to derive
equivalences in a direct way. However, we will sometimes need to
reason in an indirect way by exhibiting a contradiction. We will hence
provide several means of identifying inequivalences.
\begin{def}
Given $t$, $u∈Λ$ we write $t \nequiv_{≻} u$ if and only if we do not have
$t ≡_{≻} u$.
\end{def}
(* FIXME deux lemmes inutiles ? (Christophe) *)
\begin{lem}\label("equivcounterex")
Let $t$, $u∈Λ$ be two terms. If there is a stack $π ∈Π$ and a substitution
$ρ∈\cal{S}$ such that ${\p("tρ ∗ π")} {⇓}_{≻}p$ and ${\p("uρ ∗ π")} {⇑}_{≻}p$
then $t \nequiv_{≻} u$.
\begin{proof}
Immediate by definition of $({≡})$.
\end{proof}
\end{lem}
\begin{lem}\label("stackcounterex")
Let $t$, $u∈Λ$ be two terms. If there is a stack $π ∈Π$ such that we have
${\p("t ∗ π")} {⇓}_{≻}$ and ${\p("u ∗ π")} {⇑}_{≻}$ then $t \nequiv_{≻} u$.
\begin{proof}
Immediate consequence of \lemRef("equivcounterex") using $π$ and
$ρ = ρ_{id}$.
\end{proof}
\end{lem}

We will now start by showing that records with different fields cannot
be equivalent. Similarly, we will show that variants with different
constructors are never equivalent. In both case, it is not difficult to
find a stack distinguishing between the two values.
\begin{thm}\label("consnequiv")
Let $m$, $n ∈ \bbN$ be two natural numbers and $v$, $w ∈ Λ_ι$ be two values.
If we have $m ≠ n$ then $\v("Cm[v]") \nequiv_{≻} \v("Cn[w]")$.
\begin{proof}
We can apply \lemRef("stackcounterex") with $π = \s("[λy[y|Cm[z]→{}]]ε")$.
Indeed, ${\p("Cm[v] ∗ π")} {⇓}_{≻}$ since $\p("Cm[v] ∗ π") ≻
\p("λy[y|Cm[z]→{}] ∗ Cm[v]·ε") ≻ \p("[Cm[v]|Cm[z]→{}] ∗ ε") ≻ \p("{} ∗ ε")$.
Moreover, we have ${\p("Cn[w] ∗ π")} {⇑}_{≻}$ as $\p("Cn[v] ∗ π") ≻
\p("λy[y|Cm[z]→{}] ∗ Cn[w]·ε") ≻ \p("[Cn[w]|Cm[z]→{}] ∗ ε")$ and
$\p("[Cn[w]|Cm[z]→{}] ∗ ε")$ is stuck since $m ≠ n$.
\end{proof}
\end{thm}
\begin{thm}\label("reconequiv")
Let $I₁$, $I₂$ be two set of indices such that for all $i∈I₁$ we have
$v_i ∈ Λ_ι$ and for all $i∈I₂$ we have $w_i ∈ Λ_ι$. If $I₁ ≠ I₂$ then
$\v("{(li = vi) i∈I₁}") \nequiv_{≻} \v("{(li = wi) i∈I₂}")$.
\begin{proof}
Since $I₁ ≠ I₂$ there must be $k$ such that $k∈I₁$ and $k∉I₂$ (up to
symmetry). We can hence apply \lemRef("stackcounterex") with the stack
$π = \s("[λx x.lk]ε")$. Indeed, ${\p("{(li = vi) i∈I₁} ∗ π")} {⇓}_{≻}$
since $\p("{(li = vi) i∈I₁} ∗ π") ≻ \p("λx x.lk ∗ {(li = vi) i∈I₁} · ε") ≻
\p("{(li = vi) i∈I₁}.lk ∗ ε") ≻ \p("vk ∗ ε")$. Moreover, we have
$\p("{(li = wi) i∈I₂} ∗ π") ≻ \p("λx x.lk ∗ {(li = wi) i∈I₂} · ε") ≻
\p("{(li = wi) i∈I₂}.lk ∗ ε")$, and as $k ∉ I₂$ we know that
$\p("{(li = wi) i∈I₂}.lk ∗ ε")$ is stuck.
\end{proof}
\end{thm}

Similarly, we can show that a record and a variant can never be equivalent.
Indeed, pattern-matching on a record will lead to a stuck state. The same
argument can also be used to distinguish $λ$-abstractions from variants.
\begin{thm}\label("consneqrec")
Let $m ∈ \bbN$ be a natural number, $v ∈ Λ_ι$ be a value and $I$ be a
finite set of indices such that $v_i ∈ Λ_ι$ for all $i∈I$. We have
$\t("Cm[v]") \nequiv_{≻} \t("{(li = vi) i∈I}")$.
\begin{proof}
We can apply \lemRef("stackcounterex") using the stack
$π = \s("[λy [y|Cm[z]→{}]]ε")$. Indeed, we have ${\p("Cm[v] ∗ π")} {⇓}_{≻}$
like in the proof of \thmRef("consnequiv"). Moreover, we have
${\p("{(li = vi) i∈I} ∗ π")} {⇑}_{≻}$ since
$\p("{(li = vi) i∈I} ∗ π") ≻ \p("λy [y|Cm[z]→{}] ∗ {(li = vi) i∈I} · ε") ≻
\p("[{(li = vi) i∈I} | Cm[z] → {}] ∗ ε")$ and we know that the process
$\p("[{(li = vi) i∈I} | Cm[z] → {}] ∗ ε")$ is stuck.
\end{proof}
\end{thm}
\begin{thm}\label("nequivlamcons")
Let $m ∈ \bbN$ be a natural number, $v ∈ Λ_ι$ be a value, $x ∈ \cal{V}_ι$
be a $λ$-variable and $t ∈ Λ$ be a term. We have
$\t("Cm[v]") \nequiv_{≻} \t("λx t")$.
\begin{proof}
As for \thmRef("consneqrec") we can apply \lemRef("stackcounterex") using
$π = \s("[λy [y|Cm[z]→{}]]ε")$. Indeed, ${\p("λxt∗π")} {⇑}_{≻}$ since we have
$\p("λx t ∗ π") ≻ \p("λy [y|Cm[z]→z] ∗ λx t·ε") ≻ \p("[λx t|Cm[z]→z] ∗ ε")$
and the process $\p("[λx t|Cm[z]→z] ∗ ε")$ is stuck
\end{proof}
\end{thm}

Although it is possible to show that a record is not equivalent to a
$λ$-abstraction, one should be careful in the case of an empty record
and a $λ$-abstraction diverging on every value (i.e. for every $v ∈ Λ_ι$
and $π ∈ Π$, ${\p("(λxt) v ∗ π")} {⇓}_{≻}$). In this case, we need to
use the $\t("U(v)")$ term constructor, which has been introduced for
exactly this purpose.
\begin{thm}\label("nequivlamreco")
Let $x ∈ \cal{V}_ι$ be a $λ$-variable, $t ∈ Λ$ be a term and $I$ be a
finite set of indices such that $v_i ∈ Λ_ι$ for all $i∈I$. We have
$\t("λx t") \nequiv_{≻} \t("{(li = vi) i∈I}")$.
\begin{proof}
If $I ≠ ∅$ then we have $k ∈ I$ so we can use \lemRef("stackcounterex")
with the stack $π = \s("[λy y.lk]ε")$. Indeed, we have
${\p("{(li = vi) i∈I} ∗ π")} {⇓}_{≻}$ as
$\p("{(li = vi) i∈I} ∗ π") ≻^{∗} \p("vk ∗ ε")$ and we have
${\p("λx t ∗ π")} {⇑}_{≻}$ as $\p("λx t ∗ π") ≻^{∗} \p("(λxt).lk ∗ ε")$
and $\p("(λxt).lk ∗ ε")$ is stuck. Similarly, if $I = ∅$ then we can use
\lemRef("stackcounterex") with the stack $π = \s("[λy U(y)]ε")$. Indeed,
${\p("{} ∗ π")} {⇓}_{≻}$ as $\p("{} ∗ π") ≻^{∗} \p("{} ∗ ε")$ and
${\p("{} ∗ π")} {⇑}_{≻}$ as $\p("λxt ∗ π") ≻^{∗} \p("U(λxt) ∗ ε")$ and
$\p("U(λxt) ∗ ε")$ is stuck.
\end{proof}
\end{thm}

To conclude this section, we consider two more ways of deriving an
inequivalence when working with records and variants. Provided that
two values stored in a given record field or in a constructor are
not equivalent, it is possible to derive that two records or two
variants are not equivalent.
\begin{thm}
Let $m ∈ \bbN$ be a natural number and $v$, $w ∈ Λ_ι$ be two values.
If $v \nequiv_{≻} w$ then $\v("Cm[v]") \nequiv_{≻} \v("Cm[w]")$.
\begin{proof}
As $v \nequiv_{≻} w$ there must be a stack $π ∈ Π$ and a substitution
$ρ ∈ \cal{S}$ such that we have ${\p("vρ∗π")} {⇓}_{≻}$ and
${\p("wρ∗π")} {⇑}_{≻}$ (up to symmetry). We
hence apply \lemRef("equivcounterex") with $ρ$ and the stack
$\s("[λx [x|Cm[y]→y]]π")$ since we have
$\p("(Cm[v])ρ∗[λx [x|Cm[y]→y]]π") ≻^{∗} {\p("vρ ∗ π")} {⇓}_{≻}$
and $\p("(Cm[w])ρ∗[λx [x|Cm[y]→y]]π") ≻^{∗} {\p("wρ ∗ π")} {⇑}_{≻}$.
\end{proof}
\end{thm}
\begin{thm}
Let $I$ be a finite set of indices such that for all $i∈I$ we have
$v_i$, $w_i ∈ Λ_ι$. If there is $k ∈ I$ such that
$\v("vk") \nequiv_{≻} \v("wk")$ then
$\v("{(li = vi) i∈I}") \nequiv_{≻} \v("{(li = wi) i∈I}")$.
\begin{proof}
As $\v("vk") \nequiv_{≻} \v("wk")$ there must be a stack $π ∈ Π$ and
a substitution $ρ ∈ \cal{S}$ such that we have ${\p("vkρ∗π")} {⇓}_{≻}$
and ${\p("wkρ∗π")} {⇑}_{≻}$ (up to symmetry). We hence apply
\lemRef("equivcounterex") with $ρ$ and the stack $π₀ = \s("[λx x.lk]π")$
as we have $\p("{(li = vi) i∈I}ρ∗π₀") ≻^{∗} {\p("vkρ ∗ π")} {⇓}_{≻}$
and we also have $\p("{(li = wi) i∈I}ρ∗π₀") ≻^{∗} {\p("wkρ ∗ π")} {⇑}_{≻}$.
\end{proof}
\end{thm}

=<

=> Canonical values

The idea now is to characterise the equivalence classes of the
different forms of values. The results presented here will be
required in \chapter("typeSystem") to show that the semantics
of our types is well-formed in some sense. We will first start
by showing that a $λ$-variable is only equivalent to itself if
we only consider values.
\begin{lem}\label("subsneq")
Let $t∈Λ$ and $u∈Λ$ be two terms. If there is a substitution $ρ$ such that
$\t("tρ") \nequiv_{≻} \t("uρ")$ then $\t("t") \nequiv_{≻} \t("u")$.
\begin{proof}
By definition we have a stack $π₀∈Π$ and a substitution $ρ₀$ such that
${\p("(tρ)ρ₀ ∗ π")} {⇓}_{≻}$ and ${\p("(uρ)ρ₀ ∗ π")} {⇑}_{≻}$ (up to
symmetry). We can hence show $\t("t") \nequiv_{≻} \t("u")$ using the stack
$π₀$ and the substitution $ρ₀ \circ ρ$.
\end{proof}
\end{lem}
\begin{lem}
Let $t∈Λ$ and $u∈Λ$ be two terms. If $\t("t") ≡_{≻} \t("u")$ then for every
substitution $ρ$ we have $\t("tρ") ≡_{≻} \t("uρ")$.
\begin{proof}
Immediate consequence of {\lemRef("subsneq")} (contrapositive).
\end{proof}
\end{lem}
\begin{thm}\label("varequiv")
Let $x ∈ \cal{V}_ι$ be a $λ$-variable and $v ∈ Λ_ι$ be a value. The
equivalence $x ≡_{≻} v$ holds if and only if $v = x$.
\begin{proof}
If $v = x$ then we obviously have $v ≡_{≻} x$ by reflexivity. We will now
show that for every other possible value $v$ we have $x \nequiv_{≻} v$.
In each case we only need to find a substitution $ρ$ such that
$\t("xρ") \nequiv_{≻} \t("vρ")$ as we can then conclude using
\lemRef("subsneq").
\begin{itemize}
\item If there is $λ$-variable $y ∈ \cal{V}_ι$ such that $v = y$ and $y ≠ x$
      then we consider the substitution $ρ = \subs("[x≔Cm[{}]][y≔Cn[{}]]")$
      where $m$, $n ∈ \bbN$ are two distinct natural numbers. We have
      $\t("xρ") = \t("Cm[{}]") \nequiv_{≻} \t("Cn[{}]") = \t("yρ")$
      according to \lemRef("subsneq").
\item If there is a $λ$-variable $y ∈ \cal{V}_ι$ and a term $t∈Λ$ such that
      $v = \v("λy t")$ then we consider $ρ=\subs("[x≔{}]")$. We have
      $\t("xρ") = \t("{}") \nequiv_{≻} \t("λy tρ")$ according to
      \thmRef("nequivlamreco").
\item If there is a natural number $m ∈ \bbN$ and a value $w ∈ Λ_ι$ such
      that $v = \v("Cm[w]")$ then we consider $ρ=\subs("[x≔{}]")$. We have
      $\t("xρ") = \t("{}") \nequiv_{≻} \t("Cm[vρ]")$ according to
      \thmRef("consneqrec").
\item If there is a set of indices $I$ such that $v_i ∈ Λ_ι$ for all $i∈I$
      and $v = \v("{(li = vi) i∈I}")$ then we consider the substitution
      $ρ=\subs("[x≔Cm[{}]]")$ where $m ∈ \bbN$ is a natural number. We have
      $\t("xρ") = \t("Cm[{}]") \nequiv_{≻} \t("{(li = viρ) i∈I}")$
      according to \thmRef("consneqrec").
\end{itemize}
\end{proof}
\end{thm}

We will now identify the value that are equivalent to a given variant, and
those that are equivalent to a given record. In both case, the equivalent
values have the same structure and equivalent subvalues.
\begin{thm}
Let $m ∈ \bbN$ be a natural number and $v$, $w₀ ∈ Λ_ι$ be two values. The
equivalence $\v("Cm[v]") ≡_{≻} w₀$ holds if and only if $w₀ = \v("Cm[w]")$
for some $w ∈ Λ_ι$ such that $w ≡_{≻} v$.
\begin{proof}
Let us first assume $w₀ = \v("Cm[w]")$ for some $w ∈ Λ_ι$ such that
$w ≡_{≻} v$ and show $\v("Cm[v]") ≡_{≻} w₀$. We do a proof by contradiction
so we suppose that $\v("Cm[v]") \nequiv_{≻} \v("Cm[w]")$. By definition,
there is a stack $π ∈ Π$ and substitution $ρ ∈ \cal{S}$ such that
${\p("Cm[vρ] ∗ π")} {⇓}_{≻}$ and ${\p("Cm[wρ] ∗ π")} {⇑}_{≻}$ (up to
symmetry). We can thus use \lemRef("equivcounterex") to show
$\v("v") \nequiv_{≻} \v("w")$ since we have
$\p("vρ ∗ [λx Cm[x]]π") ≻^{∗} {\p("Cm[vρ] ∗ π")} {⇓}_{≻}$ and
$\p("wρ ∗ [λx Cm[x]]π") ≻^{∗} {\p("Cm[wρ] ∗ π")} {⇑}_{≻}$. This
contradicts $w ≡_{≻} v$ and hence we can conclude
$\v("Cm[v]") ≡_{≻} \v("Cm[w]")$.

Let us now suppose that $\v("Cm[v]") ≡_{≻} \v("w₀")$ and show that
$\v("w₀")$ is of the form $\v("Cm[w]")$ for some $w ∈ Λ_ι$ such that
$w ≡_{≻} v$. We reason by case on the possible forms of the value
$\v("w₀")$. Using \thmRef("varequiv"), \thmRef("nequivlamcons"),
\thmRef("consneqrec") and \thmRef("consnequiv") we obtain
$\v("w₀") = \v("Cm[w]")$ for some $\v("w") ∈ Λ_ι$. Let us now
suppose that $w \nequiv_{≻} v$. By definition, there must be
$π ∈ Π$ and $ρ ∈ \cal{S}$ such that ${\p("vρ ∗ π")} {⇓}_{≻}$
and ${\p("wρ ∗ π")} {⇑}_{≻}$ (up to symmetry). We can thus use
\lemRef("equivcounterex") to show $\v("Cm[v]") \nequiv_{≻} \v("Cm[w]")$
since we have
$\p("Cm[vρ] ∗ [λx [x|Cm[x]→x]]π") ≻^{∗} {\p("vρ ∗ π")} {⇓}_{≻}$ and we alse
have $\p("Cm[wρ] ∗ [λx [x | Cm[x]→x]]π") ≻^{∗} {\p("wρ ∗ π")} {⇑}_{≻}$. This
contradicts $\v("Cm[v]") ≡_{≻} \v("w₀")$ and thus $w ≡_{≻} v$.
\end{proof}
\end{thm}
\begin{thm}
Let $I$ be a finite set of indices such that $v_i ∈ Λ_ι$ for all $i∈I$, and
let $w₀ ∈ Λ_ι$ be a value. We have $\v("{(li = vi) i∈I}") ≡_{≻} w₀$ if and
only if $w₀ = \v("{(li = wi) i∈I}")$ for some values $\v("wi") ∈ Λ_ι$ such
that $\v("wi") ≡_{≻} \v("vi")$ for all $i∈I$.
\begin{proof}
Let us first assume that $w₀ = \v("{(li = wi) i∈I}")$ with
$\v("vi") ≡_{≻} \v("wi")$ for all $i∈I$ and show
$\v("{(li = vi) i∈I}") ≡_{≻} \v("{(li = wi) i∈I}")$.
(* TODO *) \todo(Some "with extentionality")

Let us now suppose $\v("{(li = vi) i∈I}") ≡_{≻} w₀$ and show that $w₀$ is
of the form $\v("{(li = wi) i∈I}")$ with $\v("wi") ≡_{≻} \v("vi")$ for all
$i∈I$. Using \thmRef("varequiv"), \thmRef("nequivlamreco"),
\thmRef("consneqrec") and \thmRef("reconequiv") we obtain
$\v("w₀") = \v("{(li=wi) i∈I}")$ with $w_i ∈ Λ_ι$ for all $i∈I$.
We now suppose $v_k \nequiv_{≻} w_k$ for some $k ∈ I$.
By definition, there must be $π ∈ Π$ and $ρ ∈ \cal{S}$ such
that ${\p("vkρ ∗ π")} {⇓}_{≻}$ and ${\p("wkρ ∗ π")} {⇑}_{≻}$ (up to symmetry).
We can thus apply \lemRef("equivcounterex") to show that
$\v("{(li=vi) i∈I}") \nequiv_{≻} \v("{(li=wi) i∈I}")$
as $\p("{(li=vi) i∈I}ρ ∗ [λx x.lk]π") ≻^{∗} {\p("vkρ ∗ π")} {⇓}_{≻}$ and
$\p("{(li=wi) i∈I}ρ ∗ [λx x.lk]π") ≻^{∗} {\p("wkρ ∗ π")} {⇑}_{≻}$. This
contradicts $\v("{(li=vi) i∈I}") ≡_{≻} \v("w₀")$ and hence
$\v("wi") ≡_{≻} \v("vi")$ for all $i∈I$.
\end{proof}
\end{thm}

\begin{thm}\label("canonlambda")
Let $x ∈ \cal{V}_ι$ be a $λ$-variable, $t ∈ Λ$ be a term and $v ∈ Λ_ι$
be a value. If the equivalence $\t("λx t") ≡_{≻} v$ holds, then there
are $y ∈ \cal{V}_ι$ and $u ∈ Λ$ such that $v = \t("λy u")$ and
$t ≡_{≻} \t("u[y≔x]")$.
\begin{proof}
Let us first assume that $w₀ = \v("λyu")$ with $\t("t") ≡_{≻} \t("u[y≔x]")$
and show $\v("λxt") ≡_{≻} \v("λy u")$.
(* TODO *) \todo(Some "not sure how")

We now suppose $\v("λxt") ≡_{≻} \v("w₀")$ and show that $w₀$ has
form $\v("λyu")$ with $t ≡_{≻} \t("u[y≔x]")$. We reason by case on the
possible forms of the value $\v("w₀")$. Using \thmRef("varequiv"),
\thmRef("nequivlamreco") and \thmRef("nequivlamcons") we obtain that
$\v("w₀")$ cannot be a $λ$-variable, a record or a variant. Consequently,
we know that $w₀ = \v("λy u")$ for some $y ∈ \cal{V}_ι$ and $u ∈ Λ$. We
now assume that $t \nequiv_{≻} u$. By our second definition of equivalence,
there must be $π ∈ Π$ and $ρ ∈ \cal{S}$ such that ${\p("(t ∗ π)ρ")} {⇓}_{≻}$
and ${\p("(u ∗ π)ρ")} {⇑}_{≻}$ (up to symmetry). Moreover, we have
$\p("λxt ∗ x·π") ≻ \p("t ∗ π")$ and we also have
$\p("λyu ∗ x·π") ≻ \p("u[y≔x] ∗ π")$ so can use \thmRef("redcompatall") to
obtain $\p("(λxt ∗ x·π)ρ") ≻ {\p("(t ∗ π)ρ")} {⇓}_{≻}$ and
$\p("(λyu ∗ x·π)ρ") ≻ {\p("(u[y≔x] ∗ π)ρ")} {⇑}_{≻}$. We can thus apply
\lemRef("equivcounterex") with $ρ$ and the stack $\s("x · π")$ to obtain
$\v("λxt") \nequiv_{≻} \v("λyu")$, which gives us a contradiction. As a
consequence, the equivalence $t ≡_{≻} u$ must hold.
\end{proof}
\end{thm}

=<

=> Extentionality

(* TODO relecture. *)
To be able to work with the equivalence relation $({≡})_{≻}$, we need to
check that it is extensional. In other words, we need to be able to replace
equals by equals at any place in terms without changing their observed
behaviour. This property is summarized in the following two theorems.
\begin{thm}\label("sextval")
Let $v₁ ∈ Λ_ι$ and $v₂ ∈ Λ_ι$ be values, $t ∈ Λ$ be a term and
$x ∈ \cal{V}_ι$ be a $λ$-variable. If $v₁ ≡_{≻} v₂$ then
$\t("t[x≔v₁]") ≡_{≻} \t("t[x≔v₂]")$.
\begin{proof}
We are going to prove the contrapositive so we suppose
$\t("t[x≔v₁]") \nequiv_{≻} \t("t[x≔v₂]")$ and we show $v₁ \nequiv_{≻} v₂$.
By definition, there is a stack $π$ and a substitution $ρ$ such that we
have ${\p("(t[x≔v₁])ρ ∗ π")} {⇓}_{≻}$ and ${\p("(t[x≔v₂])ρ ∗ π")} {⇑}_{≻}$
(up to symmetry). As $x$ is bound we can rename it so that
$\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$ and
$\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$. To finish the proof, we need to find
a stack $π₀$ and a substitution $ρ₀$ such that ${\p("v₁ρ₀ ∗ π₀")} {⇓}_{≻}$
and ${\p("v₂ρ₀ ∗ π₀")} {⇑}_{≻}$ (up to symmetry). We can take
$π₀ = \s("[λx tρ]π")$ and $ρ₀ = ρ$ since by definition we know that
${\p("v₁ρ ∗ [λx tρ]π")} ≻^2 {\p("tρ[x≔v₁ρ] ∗ π")} {⇓}_{≻}$ and
${\p("v₂ρ ∗ [λx tρ]π")} ≻^2 {\p("tρ[x≔v₂ρ] ∗ π")} {⇑}_{≻}$.
\end{proof}
\end{thm}
\begin{lem}\label("sexttermaux")
Let $p ∈ Λ×Π$ be a process, $a ∈ \cal{V}_τ$ be a term variable and $t$ be
a term such that ${\p("p[a≔t]")} {⇓}_{≻}$. Either there is a value
$v ∈ Λ_ι$ such that $p ≻^{∗} \p("v ∗ ε")$ or there is a stack $π ∈ Π$
such that $p ≻^{∗} \p("a ∗ π")$.
\begin{proof}
There must be a blocked process $q$ such that $p ≻^{∗} q$. If it were not
the case $p$ would be non-terminating, and hence $\p("p[a≔t]")$ would also
be non-terminating according to \lemRef("redstable"). This would hence
contradict the hypothesis that ${\p("p[a≔t]")} {⇓}_{≻}$. Since
$\p("p") ≻^{∗} \p("q")$ we obtain $\p("p[a≔t]") ≻^{∗} \p("q[a≔t]")$ by
\thmRef("redcompatall") and hence ${\p("q[a≔t]")} {⇓}_{≻}$. We can then
proceed by case analysis according to \lemRef("possibilities") as $q$ is
blocked. If $q$ is not of the form $\p("v ∗ ε")$ nor of the form
$\p("a ∗ π")$ then $\p("q[a≔t]")$ is a blocked process that is not final.
Consequently, we obtain a contradiction with ${\p("q[a≔t]")} {⇓}_{≻}$.
\end{proof}
\end{lem}
\begin{thm}\label("sextterm")
Let $u₁ ∈ Λ$, $u₂ ∈ Λ$ and $t ∈ Λ$ be three terms and $a ∈ \cal{V}_τ$ be a
term variable. If $u₁ ≡_{≻} u₂$ then $\t("t[a≔u₁]") ≡_{≻} \t("t[a≔u₂]")$.

\begin{proof}
Let us suppose $u₁ ≡_{≻} u₂$ and show $\t("t[a≔u₁]") ≡_{≻} \t("t[a≔u₂]")$.
We take a stack $π$, a substitution $ρ$ and we show
${{\p("(t[a≔u₁])ρ ∗ π")} {⇓}_{≻}} ⇔ {{\p("(t[a≔u₂])ρ ∗ π")} {⇓}_{≻}}$. As we
are free to rename $a$ we may assume $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$,
$\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$ and $a ∉ FV(π)$. Consequently our goal
is now ${{\p("tρ[a≔u₁ρ] ∗ π")} {⇓}_{≻}} ⇔ {{\p("tρ[a≔u₂ρ] ∗ π")} {⇓}_{≻}}$.
By symmetry we can suppose that ${\p("tρ[a≔u₁ρ] ∗ π")} {⇓}_{≻}$ and show
${\p("tρ[a≔u₂ρ] ∗ π")} {⇓}_{≻}$. Let us now consider the reduction of the
process $\p("tρ ∗ π")$. According to \lemRef("sexttermaux") there are two
possibilities.
\begin{itemize}
\item If $\p("tρ ∗ π") ≻^{∗} \p("v ∗ ε")$ for some value $v ∈ Λ_ι$ then
  $\p("(tρ ∗ π)[a≔u₂]") ≻^{∗} \p("(v ∗ ε)[a≔u₂]")$ by \thmRef("redcompatall").
  This rewrites to $\p("tρ[a≔u₂] ∗ π") ≻^{∗} \p("v[a≔u₂] ∗ ε")$ as
  $a ∉ FV(π)$, and hence we obtain ${\p("tρ[a≔u₂] ∗ π")} {⇓}_{≻}$.
\item If $\p("tρ ∗ π") ≻^{∗} \p("a ∗ π₀")$ for some stack $π₀ ∈ Π$ then
  $\p("(tρ ∗ π)[a≔u₁]") ≻^{∗} \p("(a ∗ π₀)[a≔u₁]")$ and
  $\p("(tρ ∗ π)[a≔u₂]") ≻^{∗} \p("(a ∗ π₀)[a≔u₂]")$ by
  \thmRef("redcompatall"). As a consequence, we assume
  ${\p("(a ∗ π₀)[a≔u₁]")} {⇓}_{≻}$ and show
  ${\p("(a ∗ π₀)[a≔u₂]")} {⇓}_{≻}$. We are going to build a sequence of
  stacks $(π_i)_{i≤n}$, starting with $π₀$, such that
  $\p("(a ∗ πi)[a≔u₁]") ≻^{+} \p("(a ∗ πi+1)[a≔u₁]")$ for all $i<n$. Note
  that the sequence has to be finite since otherwise there would be an
  infinite sequence of reductions from $\p("(a ∗ π₀)[a≔u₁]")$. To define
  $π_{i+1}$ we consider $\p("u₁ ∗ πi")$. By transitivity
  $\p("(a ∗ π₀)[a≔u₁]") ≻^{∗} \p("(a ∗ πi)[a≔u₁]") = \p("(u₁ ∗ πi)[a≔u₁]")$
  and hence ${\p("(u₁ ∗ πi)[a≔u₁]")} {⇓}_{≻}$. According to
  \lemRef("sexttermaux") there are two possibilities for the reduction of
  $\p("u₁ ∗ πi")$. Either $\p("u₁ ∗ πi") ≻^{∗} \p("v ∗ ε")$ for some value
  $v$ and the sequence ends with $n = i$, or
  $\p("u₁ ∗ πi") ≻^{∗} \p("a ∗ ξ")$ for some stack $ξ$ and we define
  $π_{i+1} = ξ$.
  
  To end the proof, we will now show ${\p("(a ∗ πi)[a≔u₂]")} {⇓}_{≻}$ for all
  $i ≤ n$. For $i = 0$ this will give us ${\p("(a ∗ π₀)[a≔u₂]")} {⇓}_{≻}$
  which is the expected result. For $i = n$ we know that
  $\p("u₁ ∗ πn") ≻^{∗} {\p("v ∗ ε")} {⇓}_{≻}$, and hence
  ${\p("u₂ ∗ πn")} {⇓}_{≻}$ since $u₁ ≡_{≻} u₂$. As a consequence, we obtain
  that ${\p("(a ∗ πn)[a≔u₂]")} = {\p("(u₂ ∗ πn)[a≔u₂]")} {⇓}_{≻}$ by
  \lemRef("redstable"). Let us now suppose that we have
  ${\p("(a ∗ πi+1)[a≔u₂]")} = {\p("u₂ ∗ πi+1[a≔u₂]")} {⇓}_{≻}$ for some
  $i<n$ and show that
  ${\p("(a ∗ πi)[a≔u₂]")} = {\p("u₂ ∗ πi[a≔u₂]")} {⇓}_{≻}$. Since we know
  $u₁ ≡_{≻} u₂$ we can deduce that ${\p("u₁ ∗ πi+1[a≔u₂]")} {⇓}_{≻}$.
  Moreover, since $\p("u₁ ∗ πi") ≻^{∗} \p("a ∗ πi+1")$ we may use
  \thmRef("redcompatall") to obtain
  $\p("u₁ ∗ πi[a≔u₂]") = \p("(u₁ ∗ πi)[a≔u₂]") ≻^{∗} \p("(a ∗ πi+1)[a≔u₂]")
  = \p("u₂ ∗ πi+1[a≔u₂]")$. As a consequence, we have
  ${\p("u₁ ∗ πi[a≔u₂]")} {⇓}_{≻}$ from which we obtain
  ${\p("u₂ ∗ πi[a≔u₂]")} {⇓}_{≻}$ since $u₁ ≡_{≻} u₂$.
\end{itemize}
(* FIXME ajouter un diagramme pour la preuve. *)
\end{proof}
\end{thm}

It is not enough for our equivalence relation to be extentional. As we want
to identify programs with the same computational behaviour, we expect
equivalence to be preserved by evaluation.

=<

=<
