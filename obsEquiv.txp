\Caml(
open Diagrams
open ProofTree
open LCKAM.Lang
open Lang
)
\Include{Macros}

=> Observational equivalence of programs \label("obsEquiv")

In this chapter, we define a notion of equivalence over programs. We
will see two programs as equivalent if they have the same observable
behaviour in terms of computation. A partial axiomatization of the
corresponding equivalence relation is provided to allow for the
implementation of a pseudo-decision procedure.

=> Definitions of equivalence

We will now consider a notion of //observational equivalence// over
terms. More precisely, we will say that two terms are equivalent if
they have the same computational behaviour in every evaluations
context. Using the formalism of our abstract machine, it is very
easy to quantify over every evaluation contexts. Indeed, this only
amounts to quantifying over every stacks. In this thesis, the
considered observable behaviour is successful termination (versus
non-termination or runtime error).
\begin{def}
Let $R ⊆ (Λ×Π)×(Λ×Π)$ be a reduction relation which reflexive-transitive
closure is denoted $R^{∗}$. We say that a process $p ∈ Λ×Π$ converges,
and we write $p {⇓}_R$, if there is a final state $q ∈ Λ×Π$ such that
$(p,q) ∈ {R^{∗}}$. If $p$ does not converge we say that it diverges and
we write $p {⇑}_R$. Note that we will write $p {⇓}_i$ and $p {⇑}_i$ when
working with indexed relation symbols such as $({\epi}_i)$.
\end{def}

The idea now is to relate terms that form converging processes when put
against exactly the same stacks. However, with such a definition, free
variables cannot be distinguished. Therefore, we not only quantify over
stacks, but also over substitutions.
\begin{def}
The relation $({≡}_{≻}) ⊆ {Λ×Λ}$ is defined as follows.
$$ ({≡}_{≻}) = \{(t, u) \| ∀{π∈Π}, ∀{ρ∈\cal{S}},
     {{\p("tρ∗π")} {⇓}_{≻}} ⇔ {{\p("uρ∗π")} {⇓}_{≻}}\} $$
\end{def}
\begin{lem}
$({≡}_{≻})$ is an equivalence relation.
\begin{proof}
Immediate.
\end{proof}
\end{lem}

We will now provide a second (to be proved equivalent) definition of
$({≡}_{≻})$. We will then use whichever definition is most convenient
depending on our need. Our two definitions are very similar, the only
difference is that the substitution is only applied to the terms in
the first one, and it is applied to the whole processes in the second
one.
\begin{def}
The relation $({\iso}_{≻}) ⊆ {Λ×Λ}$ is defined as follows.
$$ ({\iso}_{≻}) = \{(t, u) \| ∀{π∈Π}, ∀{ρ∈\cal{S}},
     {{\p("(t∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("(u∗π)ρ")} {⇓}_{≻}}\} $$
\end{def}
\begin{thm}\label("equivsame")
For every term $t$, $u ∈ Λ$ we have $t ≡_{≻} u$ if and only if
$t \iso_{≻} u$.
\begin{proof}
We first suppose that $t ≡_{≻} u$ and show $t \iso_{≻} u$. Let us take
$π∈Π$ and $ρ∈\cal{S}$. By symmetry, we assume ${\p("(t∗π)ρ")} {⇓}_{≻}$
and show ${\p("(u∗π)ρ")} {⇓}_{≻}$. As
${\p("(t∗π)ρ")} = {\p("tρ∗πρ")} {⇓}_{≻}$, we obtain
${\p("uρ∗πρ")} = {\p("(u∗π)ρ")} {⇓}_{≻}$ since $t ≡_{≻} u$.

Let us now suppose that $t \iso_{≻} u$ and show $t ≡_{≻} u$. We take
$π∈Π$ and $ρ∈\cal{S}$. By symmetry, we assume ${\p("tρ∗π")} {⇓}_{≻}$ and
show ${\p("uρ∗π")} {⇓}_{≻}$. As the substitution $ρ$ binds variables in
$t$, we may rename them in such a way that $FV(t) ∩ dom(ρ) = ∅$. Therefore
we obtain $\p("tρ∗π") = \p("tρ∗πρ") = {\p("(t∗π)ρ")} {⇓}_{≻}$, and thus
$\p("(u∗π)ρ") = \p("uρ∗πρ") = {\p("uρ∗π")} {⇓}_{≻}$ since $t \iso_{≻} u$.
This exactly means that $t ≡_{≻} u$.
\end{proof}
\end{thm}

=<

=> Equivalences from reduction

The equivalence relation $({≡}_{≻})$ identifies terms with the same
computational behaviour. In particular, taking reduction steps does
not fundamentally change the observable computational behaviour of
a term. We can thus derive several primitive equivalences based on
the definition of our $({≻})$ reduction relation using the following
two lemmas.
\begin{lem}\label("redequiv")
Let $t$, $u ∈ Λ$ be two terms. If for all stack $π∈Π$ there is a
process $p ∈ Λ×Π$ such that $\p("t ∗ π") ≻^{∗} p$ and
$\p("u ∗ π") ≻^{∗} p$ then $t ≡_{≻} u$.
\begin{proof}
Let us take $π ∈ Π$ and $ρ ∈ \cal{S}$. By hypothesis $\p("t∗π") ≻^{∗} p$
and $\p("u∗π") ≻^{∗} p$ for some $p ∈ Λ×Π$. Using \thmRef("redcompatall")
we obtain $\p("(t∗π)ρ") ≻^{∗} \p("pρ")$ and $\p("(u∗π)ρ") ≻^{∗} \p("pρ")$.
Consequently, ${{\p("(t∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("pρ")} {⇓}_{≻}}$ and
${{\p("(u∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("pρ")} {⇓}_{≻}}$. We hence have
${{\p("(t∗π)ρ")} {⇓}_{≻}} ⇔ {{\p("(u∗π)ρ")} {⇓}_{≻}}$, which gives
us $t ≡_{≻} u$ using \thmRef("equivsame").
\end{proof}
\end{lem}
\begin{lem}\label("redtosame")
Let $t$, $u∈Λ$ be two terms. If we have $\p("t∗π") ≻^{∗} \p("u∗π")$ for
every stack $π∈Π$ then $t ≡_{≻} u$.
\begin{proof}
Direct conseqence of \lemRef("redequiv") using $p = \p("u∗π")$.
\end{proof}
\end{lem}

Based on the reduction rules of our abstract machine, we can derive four
immediate equivalences corresponding to record projection, case analysis,
the unfolding of the fixpoint combinator and the elimination of the special
term $\t("U({})")$. Indeed, the corresponding reduction rules do not
involve an interaction with the stack. In particular, they leave the stack
unchanged.
\begin{thm}
Let $I$ be a finite set of index such that $v_i ∈ Λ_ι$ and $l_i ∈ \cal{L}$
for all $i ∈ I$. If $k ∈ I$ then $\t("{(li = vi) i∈I}.lk") ≡_{≻} \t("vk")$.
\begin{proof}
Since $\p("{(li = vi) i∈I}.lk ∗ π") ≻ \p("vk ∗ π")$ for all $π$ we
can use \lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
Let $v ∈ Λ_ι$ be a value and $I$ be a finite set of index such that
$x_i ∈ \cal{V}_ι$, $C_i ∈ \cal{C}$ and $\t("ti") ∈ Λ$ for all $i ∈ I$.
If $k ∈ I$ then $\t("[Ck[v]|(Ci[xi] → ti) i∈I]") ≡_{≻} \t("tk[xk≔v]")$.
\begin{proof}
Since $\p("[Ck[v]|(Ci[xi] → ti) i∈I] ∗ π") ≻ \p("tk[xk≔vk] ∗ π")$ for
every stack $π$ we can use \lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
For every $t ∈ Λ$ and $v ∈ Λ_ι$ we have
$\t("Y(t,v)") ≡_{≻} \t("t (λx Y(t,x)) v")$.
\begin{proof}
Since $\p("Y(t,v) ∗ π") ≻ \p("t (λx Y(t,x)) v ∗ π")$ for every stack $π$
we can use \lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
We have $\t("U({})") ≡_{≻} \t("{}")$.
\begin{proof}
Since $\p("U({}) ∗ π") ≻ \p("{} ∗ π")$ for every stack $π$ we can use
\lemRef("redtosame").
\end{proof}
\end{thm}

To go a little bit further, we can look at the first three rules of
\defRef("reduction"), which are used to handle $β$-reduction. In
particular, these three rules can be composed immediatly in the case
where we consider the application of a $λ$-abstraction to a value.
This corresponds exactly to the call-by-value $β$-reduction relation.
\begin{thm}\label("cbvbeta")
For every $t ∈ Λ$, $v ∈ Λ_ι$ and $x ∈ \cal{V}_ι$ we have
$\t("(λx t) v") ≡_{≻} \t("t[x≔v]")$.
\begin{proof}
Since $\p("(λxt) v∗π") ≻ \p("v∗[λxt]π") ≻ \p("λxt∗v·π") ≻ \p("t[x≔v]∗π")$
for all $π$ we can apply \lemRef("redtosame") to conclude.
\end{proof}
\end{thm}
Similarly, it seems to be possible to prove an equivalence corresponding
to (a call-by-value version of) the $η$-equivalence relation. We only
include it as a claim as the author did not write a full proof.
\begin{clm}
For every $u ∈ Λ$ and $x$, $y ∈ \cal{V}_ι$ such that $x ∉ FV(u)$ we have
$\t("λy u") ≡_{≻} \t("λx (λy u) x")$.
\end{clm}

The reduction rule for processes of the form $\p("μα t ∗ π")$ is inherently
non-local. Indeed, the bound $μ$-variable can be substituted anywhere in $t$
and any reduction rule may apply afterwards (depending on the form of $t$
and $π$). However, we can still derive equivalences corresponding
to the usual reduction rules of the \lmcalc \cite("Parigot1992"). In
particular, we can obtain two equivalences corresponding to call-by-value
//structural reductions//.
\begin{thm}
For every $t$, $u ∈ Λ$ and $α$, $β ∈ \cal{V}_σ$ such that $β ∉ FV(t)$ and
$β ∉ FV(u)$ we have $\t("t (μα u)") ≡_{≻} \t("μβ t u[α≔[t]β]")$.
\begin{proof}
Since for every stack $π$ we have
$\p("t (μα u) ∗ π") ≻ \p("μα u ∗ [t]π") ≻ \p("u[α≔[t]π] ∗ [t]π")$
and
$\p("μβ t u[α≔[t]β] ∗ π") ≻ \p("t u[α≔[t]π] ∗ π") ≻ \p("u[α≔[t]π] ∗ [t]π")$
we can conclude using \lemRef("redequiv").
\end{proof}
\end{thm}
\begin{thm}
For every $t ∈ Λ$, $v ∈ Λ_ι$ and $α$, $β ∈ \cal{V}_σ$ such that $β ∉ FV(t)$
and $β ∉ FV(v)$ we have $\t("(μα t) v") ≡_{≻} \t("μβ t[α≔v·β] v")$.
\begin{proof}
Since we have
$\p("(μαt) v∗π") ≻ \p("v∗[μαt]π") ≻ \p("μαt∗v·π") ≻ \p("t[α≔v·π]∗v·π")$
and
$\p("μβ t[α≔v·β] v ∗ π") ≻ \p("t[α≔v·π] v ∗ π") ≻ \p("v ∗ [t[α≔v·π]]π") ≻
 \p("t[α≔v·π]∗v·π")$
for every stack $π$, we can conclude using \lemRef("redequiv").
\end{proof}
\end{thm}
Similarly, the following theorem provides an equivalence corresponding to
//renaming//. Note that our version of renaming is more general than the
one found in \cite("Parigot1992") as our formalism includes stacks. Indeed,
only $μ$-variables can be used in named terms in the original version of
the \lmcalc.
\begin{thm}
For every $ξ∈Π$, $β ∈ \cal{V}_σ$ and $t ∈ Λ$ we have
$\t("[ξ]μβ t") ≡_{≻} \t("[ξ]t[β≔ξ]")$.
\begin{proof}
As $\p("[ξ]μβ t ∗ π") ≻ \p("μβ t ∗ ξ") ≻ \p("t[β≔ξ] ∗ ξ")$ and
$\p("[ξ]t[β≔ξ] ∗ π") ≻ \p("t[β≔ξ] ∗ ξ")$ we can conclude using
\lemRef("redequiv").
\end{proof}
\end{thm}

As a named term has the effect of erasing the whole stack. Consequently,
terms that are applied (as functions) to a named term can always be
removed. Similarly, values used as arguments of a named term can be
removed as they will never be considered. The following two theorems will
hence allow us to discard unnecessary subterms as early as possible, when
attempting to prove an equivalence.
\begin{thm}
For every $t ∈ Λ$, $v ∈ Λ_ι$ and $ξ ∈ Π$ we have
$\t("([ξ]t) v") ≡_{≻} \t("[ξ]t")$.
\begin{proof}
Since for every stack $π$ we have
$\p("([ξ]t) v ∗ π") ≻ \p("v ∗ [[ξ]t]π") ≻ \p("[ξ]t ∗ v·π") ≻ \p("t∗ξ")$
and $\p("[ξ]t ∗ π") ≻ \p("t∗ξ")$
we can conclude using \lemRef("redequiv").
\end{proof}
\end{thm}
\begin{thm}
For every $t$, $u ∈ Λ$ and $ξ ∈ Π$ we have
$\t("t ([ξ]u)") ≡_{≻} \t("[ξ]u")$.
\begin{proof}
Since we have $\p("t ([ξ]u) ∗ π") ≻ \p("[ξ]u ∗ [t]π") ≻ \p("u∗ξ")$
and $\p("[ξ]u ∗ π") ≻ \p("u∗ξ")$ for every stack $π$, we can conclude
using \lemRef("redequiv").
\end{proof}
\end{thm}

We can also remark that saving the stack twice in a row using two
consecutive $μ$-abstractions leads to saving the same stack twice.
We can thus obtain the same computational behaviour by saving the
stack only once. Similarly, using two named terms in a row is the
same as using only the later one.
\begin{thm}
For every $α$, $β ∈ \cal{V}_σ$ and $t ∈ Λ$ we have
$\t("μαμβ t") ≡_{≻} \t("μβ t[α≔β]")$.
\begin{proof}
We have $\p("μαμβ t ∗ π") ≻ \p("μβ t[α≔π] ∗ π") ≻ \p("(t[α≔π])[β≔π] ∗ π")$
and we also have $\p("μβ t[α≔β] ∗ π") ≻ \p("(t[α≔β])[β≔π] ∗ π")$. To be able
to conclude using \lemRef("redequiv") we need to show that
$\t("(t[α≔π])[β≔π]") = \t("(t[α≔β])[β≔π]")$. This is immediate as we may
assume $α ∉ FV_σ(π)$ and $β ∉ FV_σ(π)$ up to renaming.
\end{proof}
\end{thm}
\begin{thm}
For every $ξ₁$, $ξ₂ ∈ Π$ and $t ∈ Λ$ we have
$\t("[ξ₁][ξ₂]t") ≡_{≻} \t("[ξ₂]t")$.
\begin{proof}
As we have $\p("[ξ₁][ξ₂]t ∗ π") ≻ \p("[ξ₂]t ∗ ξ₁") ≻ \p("t ∗ ξ₂")$ and
$\p("[ξ₂]t ∗ π") ≻ \p("t ∗ ξ₂")$ for all $π$ we can use \lemRef("redequiv").
\end{proof}
\end{thm}

Finaly, we provide two last equivalences allowing the simplification of
terms involving $μ$-abstractions. For instance, if the variable bound by
a $μ$-abstraction does not occur in its body, then it can be removed.
Similarly, it is not useful to restore a stack right after it has been
saved.
\begin{thm}
For every $α ∈ \cal{V}_σ$ and $t ∈ Λ$ such that $α ∉ FV_σ(t)$ we have
$\t("μα t") ≡_{≻} t$.
\begin{proof}
As we have $\p("μα t ∗ π") ≻ \p("t[α≔π] ∗ π") = \p("t ∗ π")$ we can use
\lemRef("redtosame").
\end{proof}
\end{thm}
\begin{thm}
For every $α ∈ \cal{V}_σ$ and $t ∈ Λ$ we have $\t("μα[α]t") ≡_{≻} \t("μαt")$.
\begin{proof}
As $\p("μα [α]t ∗ π") ≻ \p("[π]t[α≔π] ∗ π") = \p("t[α≔π] ∗ π")$ and
$\p("μα t ∗ π") ≻ \p("t[α≔π] ∗ π")$ for all $π$ we can use
\lemRef("redequiv").
\end{proof}
\end{thm}
Note that we can compose the previous two theorems to obtain
$\t("μα [α]t") ≡ t$ in the case where $α ∉ FV_σ(t)$. This can
be seen as a form of $η$-equivalence for $μ$-abstraction, as
remarked by Michel Parigot in \cite("Parigot1992").

=<

=> Inequivalences from counter-examples

\todo (* TODO from here *)
\begin{thm}\label("consnequiv")
Let $C ∈ \cal{C}$ and $D ∈ \cal{C}$ be two constructors and $v ∈ Λ_ι$
and $w ∈ Λ_ι$ be two values. If $C ≠ D$ then
$\v("C[v]") \nequiv_{≻} \v("D[w]")$.
\begin{proof}
If we take $π = \s("[λx [x | C[y] → y]]ε")$ and $ρ = ∅$ then we have
${\p("(C[v])ρ ∗ π")} {⇓}_{≻}$ since
$\p("(C[v])ρ ∗ π") ≻ \p("λx [x | C[y] → y] ∗ C[v] · ε") ≻
\p("[C[v] | C[y] → y] ∗ ε") ≻ \p("v ∗ ε")$. Moreover, we have
${\p("(D[w])ρ ∗ π")} {⇑}_{≻}$ since
$\p("(D[v])ρ ∗ π") ≻ \p("λx [x | C[y] → y] ∗ D[w] · ε") ≻
\p("[D[w] | C[y] → y] ∗ ε")$ and $\p("[D[w] | C[y] → y] ∗ ε")$ is stuck.
\end{proof}
\end{thm}
\begin{thm}\label("injconst")
Let $C ∈ \cal{C}$ be a constructors and $v ∈ Λ_ι$ and $w ∈ Λ_ι$ be
two values. We have $\v("C[v]") ≡_{≻} \v("C[w]")$ if and only if $v ≡_{≻} w$.
\begin{proof}
Let us first show that if $\v("C[v]") ≡_{≻} \v("C[w]")$ then $v ≡_{≻} w$. We
are going to show the contrapositive so we assume $v \nequiv_{≻} w$ and we
show $\v("C[v]") \nequiv_{≻} \v("C[w]")$. By definition, there is a stack
$π ∈ Π$ and a substitution $ρ$ such that ${\p("vρ∗π")} {⇓}_{≻}$ and
${\p("wρ∗π")} {⇑}_{≻}$ (up to symmetry). We need to find $π₀ ∈ Π$ and $ρ$
such that ${\p("(C[v])ρ₀∗π₀")} {⇓}_{≻}$ and ${\p("(C[w])ρ₀∗π₀")} {⇑}_{≻}$.
We can take $ρ₀ = ρ$ and $π₀ = \s("[λx [x|C[y]→y]]π")$ as we have
$$
  \p("(C[v])ρ₀∗π₀") ≻ \p("λx [x|C[y]→y] ∗ C[vρ₀]·π")
                    ≻ \p("[C[vρ₀]|C[y]→y] ∗ π")
                    ≻ {\p("vρ₀ ∗ π")} {⇓}_{≻}
$$
and similarly $\p("(C[w])ρ₀∗π₀") ≻^{∗} {\p("wρ₀ ∗ π")} {⇑}_{≻}$.

Let us now show that if $v ≡_{≻} w$ then $\v("C[v]") ≡_{≻} \v("C[w]")$.
We are again going to show the contrapositive so we assume
$\v("C[v]") \nequiv_{≻} \v("C[w]")$ and we show $v \nequiv_{≻} w$. By
definition, there is a stack $π ∈ Π$ and a substitution $ρ$ such that
${\p("C[vρ]∗π")} {⇓}_{≻}$ and ${\p("C[wρ]∗π")} {⇑}_{≻}$ (up to symmetry).
We need to find $π₀ ∈ Π$ and $ρ$ such that ${\p("vρ₀∗π₀")} {⇓}_{≻}$ and
${\p("wρ₀∗π₀")} {⇑}_{≻}$. We can take $ρ₀ = ρ$ and $π₀ = \s("[λx C[x]]π")$
as we have
$\p("vρ₀∗π₀") ≻ \p("λx C[w] ∗ vρ₀·π") ≻ {\p("C[vρ₀] ∗ π")} {⇓}_{≻}$
and similarly $\p("wρ₀∗π₀") ≻^{∗} {\p("C[wρ₀] ∗ π")} {⇑}_{≻}$.
\end{proof}
\end{thm}

\begin{lem}\label("equivcounterex")
Let $t$ and $u$ be two terms. If there is a stack $π ∈Π$ and a substitution
$ρ$ such that ${\p("tρ ∗ π")} {⇓}_{≻}p$ and ${\p("uρ ∗ π")} {⇑}_{≻}p$ then
$t \nequiv_{≻} u$.
\begin{proof}
Immediate by definition.
\end{proof}
\end{lem}
\begin{cor}\label("stackcounterex")
Let $t$ and $u$ be two terms. If there is a stack $π ∈Π$ such that
${\p("t ∗ π")} {⇓}_{≻}p$ and ${\p("u ∗ π")} {⇑}_{≻}p$ then
$t \nequiv_{≻} u$.
\begin{proof}
Immediate consequence of \lemRef("equivcounterex") using an empty
substitution.
\end{proof}
\end{cor}

\begin{thm}\label("nequivlamcons")
If $x ∈ \cal{V}_ι$ is a $λ$-variable, $t ∈ Λ$ is a term, $C ∈ \cal{C}$ is
a constructor and $v ∈ Λ_ι$ is a value, then we have
$\t("λx t") \nequiv_{≻} \t("C[v]")$.
\begin{proof}
We can apply \corRef("stackcounterex") using the stack
$π = \s("[λy [y|C[z]→{}]]ε")$. Indeed, using $π$ we have
$\p("λx t ∗ π") ≻ \p("λy [y|C[z]→z] ∗ λx t · ε") ≻
{\p("[λx t|C[z]→z] ∗ ε")} {⇑}_{≻}$ (which is stuck), and 
$\p("C[v] ∗ π") ≻ \p("λy [y|C[z]→z] ∗ C[v] · ε") ≻
\p("[C[v]|C[z]→z] ∗ ε") ≻ {\p("v ∗ ε")} {⇓}_{≻}$.
\end{proof}
\end{thm}
\begin{thm}\label("nequiv")
If $x ∈ \cal{V}_ι$ is a $λ$-variable, $t ∈ Λ$ is a term, $I$ is a finite
set of index such that for all $i∈I$ we have $l_i ∈ \cal{L}$ and
$v_i ∈ Λ_ι$, then we have $\t("λx t") \nequiv_{≻} \t("{(li = vi) i∈I}")$.
\begin{proof}
If $I = ∅$ then we can apply \corRef("stackcounterex") using the stack
$π = \s("[λx U(x)]ε")$. Otherwise, we have $k ∈ I$, and we proceed
similarly with the stack $π = \s("[λx x.lk]ε")$ if $k ∈ I$.
\end{proof}
\end{thm}
\begin{thm}\label("consneqrec")
If $C ∈ \cal{C}$ is a constructor, $v ∈ Λ_ι$ is a value and $I$ is a
finite set of index such that for all $i∈I$ we have $l_i ∈ \cal{L}$ and
$v_i ∈ Λ_ι$, then we have $\t("C[v]") \nequiv_{≻} \t("{(li = vi) i∈I}")$.
\begin{proof}
As for \thmRef("nequivlamcons") we can apply \corRef("stackcounterex") with
$π = \s("[λy [y|C[z]→{}]]ε")$.
\end{proof}
\end{thm}

=<

=> Variables and canonical values

\begin{thm}\label("subsneq")
Let $t∈Λ$ and $u∈Λ$ be two terms. If there is a substitution $ρ$ such that
$\t("tρ") \nequiv_{≻} \t("uρ")$ then $\t("t") \nequiv_{≻} \t("u")$.
\begin{proof}
By definition we have a stack $π₀∈Π$ and a substitution $ρ₀$ such that
${\p("(tρ)ρ₀ ∗ π")} {⇓}_{≻}$ and ${\p("(uρ)ρ₀ ∗ π")} {⇑}_{≻}$ (up to
symmetry). We can hence show $\t("t") \nequiv_{≻} \t("u")$ using the stack
$π₀$ and the substitution $ρ₀ \circ ρ$.
\end{proof}
\end{thm}
\begin{cor}
Let $t∈Λ$ and $u∈Λ$ be two terms. If $\t("t") ≡_{≻} \t("u")$ then for every
substitution $ρ$ we have $\t("tρ") ≡_{≻} \t("uρ")$.
\begin{proof}
Immediate consequence of {\thmRef("subsneq")} (contrapositive).
\end{proof}
\end{cor}
\begin{thm}\label("varequiv")
Let $x ∈ \cal{V}_ι$ be a $λ$-variable and $v ∈ Λ_ι$ be a value. The
equivalence $x ≡_{≻} v$ holds if and only if $v = x$.
\begin{proof}
If $v = x$ then we obviously have $v ≡_{≻} x$ by reflexivity. We will now
show that for every other possible value $v$ we have $x \nequiv_{≻} v$.
In each case we only need to find a substitution $ρ$ such that
$\t("xρ") \nequiv_{≻} \t("vρ")$ as we can then conclude using
\thmRef("subsneq").
\begin{itemize}
\item If there is $λ$-variable $y ∈ \cal{V}_ι$ such that $v = y$ and $y ≠ x$
      then we consider the substitution $ρ = \subs("[x≔C[{}]][y≔D[{}]]")$
      where $C∈\cal{C}$ and $D∈\cal{C}$ are two distinct constructors. We have
      $\t("xρ") = \t("C[{}]") \nequiv_{≻} \t("D[{}]") = \t("yρ")$ according
      to \thmRef("subsneq").
\item If there is a $λ$-variable $y ∈ \cal{V}_ι$ and a term $t∈Λ$ such that
      $v = \v("λy t")$ then we consider the substitution $ρ=\subs("[x≔{}]")$.
      We have $\t("xρ") = \t("{}") \nequiv_{≻} \t("λy tρ")$ according to
      \thmRef("nequiv").
\item If there is constructor $C ∈ \cal{C}$ and a value $w ∈ Λ_ι$ such
      that $v = \v("C[w]")$ then we consider the substitution
      $ρ=\subs("[x≔{}]")$. We have
      $\t("xρ") = \t("{}") \nequiv_{≻} \t("C[vρ]")$ according to
      \thmRef("consneqrec").
\item If there is a set of index $I$ and for all $i∈I$ a label
      $l_i ∈ \cal{L}$ and a value $v_i ∈ Λ_ι$ such that
      $v = \v("{(li = vi) i∈I}")$ then we consider the substitution
      $ρ=\subs("[x≔C[{}]]")$ where $C∈\cal{C}$ is a constructor.
      We have $\t("xρ") = \t("C[{}]") \nequiv_{≻} \t("{(li = viρ) i∈I}")$
      according to \thmRef("consneqrec").
\end{itemize}
\end{proof}
\end{thm}
\begin{thm}
Let $C ∈ \cal{C}$ be a constructor and $v ∈ Λ_ι$ and $w₀ ∈ Λ_ι$ be
two values. The equivalence $\v("C[v]") ≡_{≻} w₀$ holds if and only if
$w₀ = \v("C[w]")$ for some $w ∈ Λ_ι$ such that $w ≡_{≻} v$.
\begin{proof}
If it is the case that $w₀ = \v("C[w]")$ and $w ≡_{≻} v$ then we indeed
have $\v("C[v]") ≡_{≻} w₀$ according to \thmRef("injconst"). This theorem
also tells us that if $w₀ = \v("C[w]")$ and $w \nequiv_{≻} v$ then we
$\v("C[v]") \nequiv_{≻} w₀$. Now if $w₀ = \v("D[w]")$ for some constructor
$D∈\cal{C}$ such that $C ≠ D$ then we have $\v("C[v]") \nequiv_{≻} w₀$ by
\thmRef("consnequiv"). All the remaining cases can be handled immediatly
using \thmRef("varequiv"), \thmRef("nequivlamcons") and \thmRef("consneqrec")
respectively.
\end{proof}
\end{thm}
\begin{thm}
Let $I$ be a finite set of index such that $l_i ∈ \cal{L}$ and
$v_i ∈ Λ_ι$ for all $i∈I$, and let $w₀ ∈ Λ_ι$ be a value.
The equivalence $\v("{(li = vi) i∈I}") ≡_{≻} w₀$ holds if and only if
we have $w₀ = \v("{(li = wi) i∈I}")$ for some values $wi ∈ Λ_ι$
such that $\v("wi") ≡_{≻} \v("vi")$ for all $i∈I$.
\begin{proof}
... (* TODO *)
\end{proof}
\end{thm}

=<

=> Extentionality

(* TODO relecture. *)
To be able to work with the equivalence relation $({≡})_{≻}$, we need to
check that it is extensional. In other words, we need to be able to replace
equals by equals at any place in terms without changing their observed
behaviour. This property is summarized in the following two theorems.
\begin{thm}\label("sextval")
Let $v₁ ∈ Λ_ι$ and $v₂ ∈ Λ_ι$ be values, $t ∈ Λ$ be a term and
$x ∈ \cal{V}_ι$ be a $λ$-variable. If $v₁ ≡_{≻} v₂$ then
$\t("t[x≔v₁]") ≡_{≻} \t("t[x≔v₂]")$.
\begin{proof}
We are going to prove the contrapositive so we suppose
$\t("t[x≔v₁]") \nequiv_{≻} \t("t[x≔v₂]")$ and we show $v₁ \nequiv_{≻} v₂$.
By definition, there is a stack $π$ and a substitution $ρ$ such that we
have ${\p("(t[x≔v₁])ρ ∗ π")} {⇓}_{≻}$ and ${\p("(t[x≔v₂])ρ ∗ π")} {⇑}_{≻}$
(up to symmetry). As $x$ is bound we can rename it so that
$\t("(t[x≔v₁])ρ") = \t("tρ[x≔v₁ρ]")$ and
$\t("(t[x≔v₂])ρ") = \t("tρ[x≔v₂ρ]")$. To finish the proof, we need to find
a stack $π₀$ and a substitution $ρ₀$ such that ${\p("v₁ρ₀ ∗ π₀")} {⇓}_{≻}$
and ${\p("v₂ρ₀ ∗ π₀")} {⇑}_{≻}$ (up to symmetry). We can take
$π₀ = \s("[λx tρ]π")$ and $ρ₀ = ρ$ since by definition we know that
${\p("v₁ρ ∗ [λx tρ]π")} ≻^2 {\p("tρ[x≔v₁ρ] ∗ π")} {⇓}_{≻}$ and
${\p("v₂ρ ∗ [λx tρ]π")} ≻^2 {\p("tρ[x≔v₂ρ] ∗ π")} {⇑}_{≻}$.
\end{proof}
\end{thm}
\begin{lem}\label("sexttermaux")
Let $p ∈ Λ×Π$ be a process, $a ∈ \cal{V}_τ$ be a term variable and $t$ be
a term such that ${\p("p[a≔t]")} {⇓}_{≻}$. Either there is a value
$v ∈ Λ_ι$ such that $p ≻^{∗} \p("v ∗ ε")$ or there is a stack $π ∈ Π$
such that $p ≻^{∗} \p("a ∗ π")$.
\begin{proof}
There must be a blocked process $q$ such that $p ≻^{∗} q$. If it were not
the case $p$ would be non-termination, and hence $\p("p[a≔t]")$ would also
be non-termination according to \lemRef("redstable"). This would hence
contradict the hypothesis that ${\p("p[a≔t]")} {⇓}_{≻}$. Since
$\p("p") ≻^{∗} \p("q")$ we obtain $\p("p[a≔t]") ≻^{∗} \p("q[a≔t]")$ by
\thmRef("redcompatall") and hence ${\p("q[a≔t]")} {⇓}_{≻}$. We then
proceed by case analysis according to \lemRef("possibilities"). If $q$ is
not of the form $\p("v ∗ ε")$ or $\p("a ∗ π")$ then $\p("q[a≔t]")$ cannot
be reduced, which contradicts ${\p("q[a≔t]")} {⇓}_{≻}$.
\end{proof}
\end{lem}
\begin{thm}\label("sextterm")
Let $u₁ ∈ Λ$, $u₂ ∈ Λ$ and $t ∈ Λ$ be three terms and $a ∈ \cal{V}_τ$ be a
term variable. If $u₁ ≡_{≻} u₂$ then $\t("t[a≔u₁]") ≡_{≻} \t("t[a≔u₂]")$.

\begin{proof}
Let us suppose $u₁ ≡_{≻} u₂$ and show $\t("t[a≔u₁]") ≡_{≻} \t("t[a≔u₂]")$.
We take a stack $π$, a substitution $ρ$ and we show
${{\p("(t[a≔u₁])ρ ∗ π")} {⇓}_{≻}} ⇔ {{\p("(t[a≔u₂])ρ ∗ π")} {⇓}_{≻}}$. As we
are free to rename $a$ we may assume $\t("(t[a≔u₁])ρ") = \t("tρ[a≔u₁ρ]")$,
$\t("(t[a≔u₂])ρ") = \t("tρ[a≔u₂ρ]")$ and $a ∉ FV(π)$. Consequently our goal
is now ${{\p("tρ[a≔u₁ρ] ∗ π")} {⇓}_{≻}} ⇔ {{\p("tρ[a≔u₂ρ] ∗ π")} {⇓}_{≻}}$.
By symmetry we can suppose that ${\p("tρ[a≔u₁ρ] ∗ π")} {⇓}_{≻}$ and show
${\p("tρ[a≔u₂ρ] ∗ π")} {⇓}_{≻}$. Let us now consider the reduction of the
process $\p("tρ ∗ π")$. According to \lemRef("sexttermaux") there are two
possibilities.
\begin{itemize}
\item If $\p("tρ ∗ π") ≻^{∗} \p("v ∗ ε")$ for some value $v ∈ Λ_ι$ then
  $\p("(tρ ∗ π)[a≔u₂]") ≻^{∗} \p("(v ∗ ε)[a≔u₂]")$ by \thmRef("redcompatall").
  This rewrites to $\p("tρ[a≔u₂] ∗ π") ≻^{∗} \p("v[a≔u₂] ∗ ε")$ as
  $a ∉ FV(π)$, and hence we obtain ${\p("tρ[a≔u₂] ∗ π")} {⇓}_{≻}$.
\item If $\p("tρ ∗ π") ≻^{∗} \p("a ∗ π₀")$ for some stack $π₀ ∈ Π$ then
  $\p("(tρ ∗ π)[a≔u₁]") ≻^{∗} \p("(a ∗ π₀)[a≔u₁]")$ and
  $\p("(tρ ∗ π)[a≔u₂]") ≻^{∗} \p("(a ∗ π₀)[a≔u₂]")$ by
  \thmRef("redcompatall"). As a consequence, it is enough to show
  ${{\p("(a ∗ π₀)[a≔u₁]")} {⇓}_{≻}} ⇒ {{\p("(a ∗ π₀)[a≔u₂]")} {⇓}_{≻}}$.
  We assume ${\p("(a ∗ π₀)[a≔u₁]")} {⇓}_{≻}$ and show
  ${\p("(a ∗ π₀)[a≔u₂]")} {⇓}_{≻}$. We are going to build a sequence of
  stacks $(π_i)_{i≤n}$, starting with $π₀$, such that
  $\p("(a ∗ πi)[a≔u₁]") ≻^{+} \p("(a ∗ πi+1)[a≔u₁]")$ for all $i<n$. Note
  that the sequence has to be finite, otherwise the reduction of
  $\p("(a ∗ π₀)[a≔u₁]")$ would be infinite and this would contradict
  ${\p("(a ∗ π₀)[a≔u₁]")} {⇓}_{≻}$. To define $π_{i+1}$ we consider
  $\p("u₁ ∗ πi")$. By transitivity
  $\p("(a ∗ π₀)[a≔u₁]") ≻^{∗} \p("(a ∗ πi)[a≔u₁]") = \p("(u₁ ∗ πi)[a≔u₁]")$
  and hence ${\p("(u₁ ∗ πi)[a≔u₁]")} {⇓}_{≻}$. According to
  \lemRef("sexttermaux") there are two possibilities for the reduction of
  $\p("u₁ ∗ πi")$. Either $\p("u₁ ∗ πi") ≻^{∗} \p("v ∗ ε")$ for some value
  $v$ and the sequence ends with $n = i$, or
  $\p("u₁ ∗ πi") ≻^{∗} \p("a ∗ ρ")$ for some stack $ρ$ and we define
  $π_{i+1} = ρ$.
  
  To end the proof, we will now show ${\p("(a ∗ πi)[a≔u₂]")} {⇓}_{≻}$ for all
  $i ≤ n$. For $i = 0$ this will give us ${\p("(a ∗ π₀)[a≔u₂]")} {⇓}_{≻}$
  which is the expected result. For $i = n$ we know that
  $\p("u₁ ∗ πn") ≻^{∗} {\p("v ∗ ε")} {⇓}_{≻}$, and hence
  ${\p("u₂ ∗ πn")} {⇓}_{≻}$ since $u₁ ≡_{≻} u₂$. As a consequence, we obtain
  that ${\p("(a ∗ πn)[a≔u₂]")} = {\p("(u₂ ∗ πn)[a≔u₂]")} {⇓}_{≻}$ by
  \lemRef("redstable"). Let us now suppose that we have
  ${\p("(a ∗ πi+1)[a≔u₂]")} = {\p("u₂ ∗ πi+1[a≔u₂]")} {⇓}_{≻}$ for some
  $i<n$ and show that
  ${\p("(a ∗ πi)[a≔u₂]")} = {\p("u₂ ∗ πi[a≔u₂]")} {⇓}_{≻}$. Since we know
  $u₁ ≡_{≻} u₂$ we can deduce that ${\p("u₁ ∗ πi+1[a≔u₂]")} {⇓}_{≻}$.
  Moreover, since $\p("u₁ ∗ πi") ≻^{∗} \p("a ∗ πi+1")$ we may use
  \thmRef("redcompatall") to obtain
  $\p("u₁ ∗ πi[a≔u₂]") = \p("(u₁ ∗ πi)[a≔u₂]") ≻^{∗} \p("(a ∗ πi+1)[a≔u₂]")
  = \p("u₂ ∗ πi+1[a≔u₂]")$. As a consequence, we have
  ${\p("u₁ ∗ πi[a≔u₂]")} {⇓}_{≻}$ from which we obtain
  ${\p("u₂ ∗ πi[a≔u₂]")} {⇓}_{≻}$ since $u₁ ≡_{≻} u₂$.
\end{itemize}
\end{proof}
\end{thm}

It is not enough for our equivalence relation to be extentional. As we want
to identify programs with the same computational behaviour, we expect
equivalence to be preserved by evaluation.

=<

=<
