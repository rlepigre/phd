\Caml(open Diagrams)
\Include{Macros}

This chapter introduces the formalisms of type theory and classical
realizability. These theories are used here to account for the syntax
and the semantics of a functional programming language commonly known
as \sc{ml}. Its type-system will be built upon in the following
chapters to incorporate the author's original contributions.

=> The pure $λ$-calculus

In this thesis, we consider a programming language of the \sc{ml}
family similar to \sc{Caml} or \sc{sml}. Like every other functional
language, its syntax is base on the $λ$-calculus. Introduced by
Alonzo Church in the Thirties, the $λ$-calculus \cite("Church41") is
a formalism for representing computable functions, which include
reccursive functions. In particular, Alan Turing showed in 1937 that
the $λ$-calculus and turing machines are equivalent models of
computation \cite("Turing37").

\begin{def}
We suppose given a countable alphabet $\cal{V}_λ = \{x,y,z, ...\}$ of
variables (also called $λ$-variables). The set of the terms of the
$λ$-calculus (also called $λ$-terms) is the smallest set $Λ$ such that:
\begin{itemize}
\item if $x ∈ \cal{V}_λ$ then $x ∈ Λ$ (e.g. $\cal{V}_λ ⊆ Λ$),
\item if $x ∈ \cal{V}_λ$ and $t ∈ Λ$ then ${λx t} ∈ Λ$,
\item if $t ∈ Λ$ and $u ∈ Λ$ then ${(t) u} ∈ Λ$.
\end{itemize}
A term of the form $λx t$ is called a $λ$-abstractions (or simply
abstractions).
\end{def}
The set of the $λ$-terms can be defined, in an equivalent way, as
the language recognised by the following \sc{bnf} grammar
(Backus-Naur form).
\begin{center}
$t,u ::= {x} \| {λx t} \| {(t) u}$
\end{center}
This method has the advantage of exposing the structure of terms in an
explicit way. Indeed, a term of the $λ$-calculus is either a
$λ$-variable, a $λ$-abstraction or an application (i.e. a term of the
form $(t) u$).

Intuitively, a $λ$-abstraction $λx t$ forms a fonction binding the
variable $x$ in the term $t$. This is more usually denoted $x |-> t$.
Variable binding and the associated notion of free variable hence play
an important role.
\begin{def}
Given a term $t$, we denote by $FV_λ(t)$ the set of its free
$λ$-variables and $BV_λ(t)$ the set of its bound $λ$-variables. These
sets are defined inductively on the structure of $t$.
\begin{center}
\diagram(
let contents = two_cols
 [ [<$ FV_λ(x) $>    ; <$ = $>; <$ \{x\} $>                   ]
 ; [<$ FV_λ(λx t) $> ; <$ = $>; <$ FV_λ(t) \setminus \{x\} $> ]
 ; [<$ FV_λ((t) u) $>; <$ = $>; <$ FV_λ(t) ∪ FV_λ(u) $>       ]
 ; [<$ BV_λ(x) $>    ; <$ = $>; <$ ∅ $>                       ]
 ; [<$ BV_λ(λx t) $> ; <$ = $>; <$ BV_λ(t) ∪ \{x\} $>         ]
 ; [<$ BV_λ((t) u) $>; <$ = $>; <$ BV_λ(t) ∪ BV_λ(u) $>       ] ]
let _ = array [`East; `Main; `West; `East; `Main; `West] contents
          ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\end{def}
\begin{rem}
Nothing prevents a $λ$-variable to be bound and free in a term. In
$t = λx (y) λy (x) y$, the first occurence of $y$ is free while its
second occurence is bound. Indeed, $y ∈ FV_λ(t) = \{y\}$ and
$y ∈ BV_λ(t) = \{x, y\}$.
\end{rem}

When a $λ$-abstraction (i.e. a function) is applied to an argument, we
obtain a term of the form $(λx t) u$, called a $β$-redex. The reduction
of such $β$-redexes is essential for computation. Intuitively, the
réduction of the $β$-redex $(λx t) u$ will be performed by substituting
$x$ by $u$ in the term $t$. This operation, called substitution, is
formally defined as follows.
(* TODO *)

(*
\begin{def}
Soit $t ∈ Λ$ et $u ∈ Λ$ deux termes, et $x ∈ \cal{V}_λ$ une $λ$-variable.
On dénote $t[x := u]$ le terme $t$ dans lequel toute occurrence libre de
$x$ a été remplacée par $u$. Cette opération est définie par induction sur
la structure du terme $t$.
\begin{center}
\diagram(
let contents = two_cols
 [ [<$ x[x := u] $>        ; <$ = $>; <$ u $>                       ]
 ; [<$ y[x := u] $>        ; <$ = $>; <$ y $>                       ]
 ; [<$ (λx t)[x := u] $>   ; <$ = $>; <$ λx t $>                    ]
 ; [<$ (λy t)[x := u] $>   ; <$ = $>; <$ λy t[x := u] $>            ]
 ; [<$ ((t₁) t₂)[x := u] $>; <$ = $>; <$ (t₁[x := u]) t₂[x := u] $> ]
 ]
let _ =
  array [`East; `Main; `West; `East; `Main; `West] contents
    ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\end{def}
Une subtilité subsiste au niveau de la notion de substitution~: la capture.
Considérons par exemple le terme $t = λx λy x$ correspondant à une fonction
avec un argument $x$, et retournant une fonction constante de valeur $x$.
Appliquons maintenant la substitution $[x := y]$ à $t$. Par cette opération,
on obtient le terme $λy y$ qui n'est plus une fonction constante, mais la
fonction identité. Pour remédier à ce problème, il convient de s'assurer
lors d'une substitution $t[x := u]$ qu'aucune variable libre de $u$ n'est
liée dans $t$. Bien qu'on ne puisse pas renommer les variables libres de
$u$, il est tout à fait possible de renommer les variables liées de $t$.
En effet, il est clair que le choix du nom d'une variable liée n'a pas
d'importance, de la même manière que l'on considère généralement les sommes
$\sum_{i=1}^n i$ et $\sum_{j=1}^n j$ identiques bien que $i$ et $j$ soient
deux noms différents.
*)

(*
Pour former une fonction de deux argument (ou plus), il est nécessaire de la
Curryfier~: les arguments de la fonction sont donnés l'un après l'autre et
non simultanément.
En effet, le terme $(t) u$ correspondant au calcul de la «~fonction~» $t$ au
«~point~» $u$ (qui est en général noté $t(u)$) ...
*)

(* TODO *)

=<
=> Krivine machine and $λμ$-calculus

... (* TODO *)

=<
=> Simple types and classical logic

... (* TODO *)

=<
=> On call-by-value and soundness

... (* TODO *)

=<
=> Call-by-value realisability model

... (* TODO *)

=<
=> Sums and products

... (* TODO *)

=<
=> Higher-order logic

... (* TODO *)

=<
