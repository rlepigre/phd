\Caml(open Diagrams open ProofTree)
\Include{Macros}

=> Computational effects and $λμ$-calculus

We are now going to extend the calculus and our abstract machine with
operations allowing the manipulation of the stack. More precisely, we
will provide a way to save the stack (i.e. the evaluation context or the
continuation), so that it can be restored at a later stage. A natural
way to extend our language is to use the syntax of Michel Parigot's
$λμ$-calculus \cite("Parigot1992"). We hence introduce a new binder $μα t$
capturing the current stack in the $μ$-variable $α$. It can then be
restored in $t$ using the syntax $[α]u$.
\begin{def}
Let $\cal{V}_μ = \{α, β, γ...\}$ be a countable set of $μ$-variables (or
stack variables) disjoint from $\cal{V}_λ$. Value, terms, stacks and
processes are now generated by the following grammars. The names of the
corresponding sets are displayed on the right.
\begin{center}
\linesBefore(6)
\diagram(
let _ = array [`East ; `East ; `West; `West]
  ~horizontal_padding:(function 3 -> 20.0 | _ -> 1.0)
  [ [<$v,w$>; <$::=$>; <$ x \| {λx t} $>                   ; <$(Λ_{val})$>]
  ; [<$t,u$>; <$::=$>; <$ v \| {(t) u} \| {μα t} \| [π]t $>; <$(Λ)$>      ]
  ; [<$π,ρ$>; <$::=$>; <$ ε \| α \| {v ⋅ π} \| [t] π $>    ; <$(Π)$>      ]
  ; [<$p,s$>; <$::=$>; <$ t ∗ π $>                         ; <$(Λ × Π)$>  ] ]
)
\end{center}
\end{def}
Note that terms of the form $[π]t$ will only be available to the user if
$π$ is a stack variable. Allowing arbitrary stacks allow us to substitute
$μ$-variables by stacks during computation. Like with $λ$-variable, we will
need to be careful and avoid variable capture. However, we will not give
the full details this time.
\begin{def}
Given a value, term, stack or process $ψ$, we denote $FV_λ(ψ)$ (resp.
$BV_λ(ψ)$) the set of its free (resp. bound) $λ$-variables and $FV_μ(ψ)$
(resp. $BV_μ(ψ)$) the set of its free (resp. bound) $μ$-variables. These
sets are defined inductively in a similar way to \defRef("freelvars").
\end{def}
\begin{def}
Let $t ∈ Λ$ be a term, $π ∈ Π$ be a stack and $α ∈ \cal{V}_μ$ be a
$μ$-variable. We denote $t[α := π]$ the (capture-avoiding) substitution of
$α$ by $π$ in $t$.
\end{def}
\begin{def}
The reduction relation $({\succ})$ is extended with two new reduction rules.
\begin{center}
\linesBefore(7)
\diagram(
let _ = array [`East ; `Main ; `West]
  ~horizontal_padding:(function _ -> 5.0)
  [ [ <${(t) u} ∗ π$>   ; <$\succ$>; <$u ∗ {[t]π}$>       ]
  ; [ <$v ∗ {[t] π}$>   ; <$\succ$>; <$t ∗ {v·π}$>        ]
  ; [ <$λx t ∗ {v · π}$>; <$\succ$>; <${t[x := v]} ∗ π$>  ]
  ; [ <$μα t ∗ π$>      ; <$\succ$>; <${t[α := π]} ∗ π$>  ]
  ; [ <$[ρ]t ∗ π$>      ; <$\succ$>; <$t ∗ ρ$>            ] ]
)
\end{center}
\end{def}
Now, when the abstract machine encounters a $μ$-abstraction $μα t$, the
current stack $π$ is substituted to the $μ$-variables $α$. As a consequence,
every subterm of the form $[α]u$ in $t$ becomes $[π]u$. When the machine
then reaches a state of the form $[π]u ∗ ρ$, the current stack $ρ$ is erased,
and computation resumes with the stored stack $π$. For example, the processus
$λx μα Ω_x [α]x ∗ v · ε$ where $Ω_x$ is an arbitrary term and $v$ is an
arbitrary value reduces as follows.
$$
  {{λx μα Ω_x [α]x} ∗ {v · ε}}
  \succ
  {{μα Ω_v [α]v} ∗ ε}
  \succ
  {{Ω_v [ε]v} ∗ ε}
  \succ
  {{[ε]v} ∗ {[Ω_v] ε}}
  \succ
  {v ∗ ε}
$$
Note that when a stack is erased, arbitrary terms might be erased. In
particular, we could have chosed $Ω_x = Ω = (λx x x) λx x x$ in the
previous example, although the reduction of this term does not terminate.
Indeed, we have
$$
  {Ω ∗ π}
  \succ
  {{λx x x} ∗ {[λx x x] π}}
  \succ
  {{λx x x} ∗ {{λx x x} · π}}
  \succ
  {Ω ∗ π}
$$
for every possible stack $π$.

=<
