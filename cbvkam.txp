\Caml(open Diagrams open ProofTree)
\Include{Macros}

=> Call-by-value Krivine machine and effects

In the previous section, we explicited the syntax of the $λ$-calculus and
the evaluation of $λ$-terms. We will now reformulate these definition in
terms of a call-by-value Krivine abstract machine \cite("Krivine2007").
Our presentation will differ from the original machine, which is usually
call-by-name. Although call-by-value Krivine machines have rarely been
published, they are well-known among classical realizability experts.

\begin{def}
Value, terms, stacks and processes are generated by the following four
\sc{bnf} grammars. The names of the corresponding sets are displayed on
the right.
\begin{center}
\linesBefore(6)
\diagram(
let _ = array [`East ; `East ; `West; `West]
  ~horizontal_padding:(function 3 -> 20.0 | _ -> 1.0)
  [ [ <$v,w$>; <$::=$>; <$ x \| {λx t} $>          ; <$(Λ_{val})$> ]
  ; [ <$t,u$>; <$::=$>; <$ v \| {t u} $>           ; <$(Λ)$>       ]
  ; [ <$π,ρ$>; <$::=$>; <$ ε \| {v ⋅ π} \| [t] π $>; <$(Π)$>       ]
  ; [ <$p,s$>; <$::=$>; <$ t ∗ π $>                ; <$(Λ × Π)$>   ] ]
)
\end{center}
\end{def}
The syntactic distinction between terms and values is specific to the
call-by-value presentation, they would be collapsed in call-by-name.
Intuitively, a stack can be thought of as an evaluation context represented
as a list of terms and values. The values are to be considered as arguments
to be fed to the term in the context, and the terms are to be considered as
functions to which the term in the context will be applied. The symbol $ε$
is used to denote an empty stack. A process $t ∗ π$ is to be considered as
the state of our abstract machine. Its reduction will consist in the
interaction between the term $t$ and its evaluation context encoded into
a stack $π$.

As we are considering a call-by-value calculus, only values are (and should
be) substituted to $λ$-variables during evaluation. From now on, we will
hence work with the following definition of substitution. In particular,
a substitution of the form $t[x := u]$ will be forbidden if $u$ is not a
syntactic value.
\begin{def}
Let $t ∈ Λ$ be a term, $x ∈ \cal{V}_λ$ be a $λ$-variable and $v \in Λ_{val}$
be a value. We denote $t[x := v]$ the capture-avoiding substitution of $x$
by $v$ in $t$.
\end{def}
\begin{def}
The reduction relation $({\succ}) ⊆ (Λ×Π) × (Λ×Π)$ is defined as the smallest
relation satisfying the following rules. We will denote $({\succ}^{∗})$ its
reflexive and transitive closure.
\begin{center}
\linesBefore(4)
\diagram(
let _ = array [`East ; `Main ; `West]
  ~horizontal_padding:(function _ -> 5.0)
  [ [ <${t u} ∗ π$>     ; <$\succ$>; <$u ∗ {[t]π}$>       ]
  ; [ <$v ∗ {[t] π}$>   ; <$\succ$>; <$t ∗ {v·π}$>        ]
  ; [ <$λx t ∗ {v · π}$>; <$\succ$>; <${t[x := v]} ∗ π$>  ] ]
)
\end{center}
\end{def}
Three reduction rules are used to handle call-by-value evaluation. When an
application is encountered, the function is stored in a stack-frame in order
to evaluate its argument first. Once the argument has been completely
computed, a value faces the stack-frame containing the function. At this
point the function can be evaluated and the value is stored in the stack
ready to be consumed by the function as soon as it evaluates to a
$λ$-abstraction. A capture-avoiding substitution can then be performed to
effectively apply the argument to the function. For example, the process
${(λx x y) λx x} ∗ ε$ reduces in the following way.
$$
  {{(λx x y) λz z} ∗ ε}
  \succ
  {{λz z} ∗ {[λx x y]ε}}
  \succ
  {{λx x y} ∗ {{λz z} · ε}}
  \succ
  {{(λz z) y} ∗ ε}
  \succ
  {y ∗ ε}
$$
\begin{rem}
The choice of right-to-left call-by-value allows for a simpler abstract
machine. Indeed, an additional stack constructor and reduction rule would
be required to implement the more usual left-to-right evaluation.
\end{rem}

We are now going to extend the calculus and our abstract machine with
operations allowing the manipulation of the stack. More precisely, we
will provide a way to save the stack (i.e. the evaluation context or the
continuation), so that it can be restored at a later stage. A natural
way to extend our language is to use the syntax of Michel Parigot's
$λμ$-calculus \cite("Parigot1992"). We hence introduce a new binder $μα t$
capturing the current stack in the $μ$-variable $α$. It can then be
restored in $t$ using the syntax $[α]u$.
\begin{def}
Let $\cal{V}_μ = \{α, β, γ...\}$ be a countable set of $μ$-variables (or
stack variables) disjoint from $\cal{V}_λ$. Value, terms, stacks and
processes are now generated by the following grammars. The names of the
corresponding sets are displayed on the right.
\begin{center}
\linesBefore(6)
\diagram(
let _ = array [`East ; `East ; `West; `West]
  ~horizontal_padding:(function 3 -> 20.0 | _ -> 1.0)
  [ [<$v,w$>; <$::=$>; <$ x \| {λx t} $>                   ; <$(Λ_{val})$>]
  ; [<$t,u$>; <$::=$>; <$ v \| {(t) u} \| {μα t} \| [π]t $>; <$(Λ)$>      ]
  ; [<$π,ρ$>; <$::=$>; <$ ε \| α \| {v ⋅ π} \| [t] π $>    ; <$(Π)$>      ]
  ; [<$p,s$>; <$::=$>; <$ t ∗ π $>                         ; <$(Λ × Π)$>  ] ]
)
\end{center}
\end{def}
Note that terms of the form $[π]t$ will only be available to the user if
$π$ is a stack variable. Allowing arbitrary stacks allow us to substitute
$μ$-variables by stacks during computation. Like with $λ$-variable, we will
need to be careful and avoid variable capture. However, we will not give
the full details this time.
\begin{def}
Let $t ∈ Λ$ be a term, $π ∈ Π$ be a stack and $α ∈ \cal{V}_μ$ be a
$μ$-variable. We denote $t[α := π]$ the (capture-avoiding) substitution of
$α$ by $π$ in $t$.
\end{def}
\begin{def}
The reduction relation $({\succ})$ is extended with two new reduction rules.
\begin{center}
\linesBefore(7)
\diagram(
let _ = array [`East ; `Main ; `West]
  ~horizontal_padding:(function _ -> 5.0)
  [ [ <${(t) u} ∗ π$>   ; <$\succ$>; <$u ∗ {[t]π}$>       ]
  ; [ <$v ∗ {[t] π}$>   ; <$\succ$>; <$t ∗ {v·π}$>        ]
  ; [ <$λx t ∗ {v · π}$>; <$\succ$>; <${t[x := v]} ∗ π$>  ]
  ; [ <$μα t ∗ π$>      ; <$\succ$>; <${t[α := π]} ∗ π$>  ]
  ; [ <$[ρ]t ∗ π$>      ; <$\succ$>; <$t ∗ ρ$>            ] ]
)
\end{center}
\end{def}
Now, when the abstract machine encounters a $μ$-abstraction $μα t$, the
current stack $π$ is substituted to the $μ$-variables $α$. As a consequence,
every subterm of the form $[α]u$ in $t$ becomes $[π]u$. When the machine
then reaches a state of the form $[π]u ∗ ρ$, the current stack $ρ$ is erased,
and computation resumes with the stored stack $π$. For example, the processus
$λx μα Ω_x [α]x ∗ v · ε$ where $Ω_x$ is an arbitrary term and $v$ is an
arbitrary value reduces as follows.
$$
  {{λx μα Ω_x [α]x} ∗ {v · ε}}
  \succ
  {{μα Ω_v [α]v} ∗ ε}
  \succ
  {{Ω_v [ε]v} ∗ ε}
  \succ
  {{[ε]v} ∗ {[Ω_v] ε}}
  \succ
  {v ∗ ε}
$$
Note that when a stack is erased, arbitrary terms might be erased. In
particular, we could have chosed $Ω_x = Ω = (λx x x) λx x x$ in the
previous example, although the reduction of this term does not terminate.
Indeed, we have
$$
  {Ω ∗ π}
  \succ
  {{λx x x} ∗ {[λx x x] π}}
  \succ
  {{λx x x} ∗ {{λx x x} · π}}
  \succ
  {Ω ∗ π}
$$
for every possible stack $π$.

=<
