\Caml(open Diagrams open ProofTree)
\Include{Macros}

=> Call-by-value Krivine machine

In the previous section, we explicited the syntax of the $λ$-calculus and
the evaluation of $λ$-terms. We will now reformulate these definition in
terms of a call-by-value Krivine abstract machine \cite("Krivine2007").
Our presentation will differ from the original machine, which is usually
call-by-name. Although call-by-value Krivine machines have rarely been
published, they are well-known among classical realizability experts.

\begin{def}
Value, terms, stacks and processes are generated by the following four
\sc{bnf} grammars. The names of the corresponding sets are displayed on
the right.
\begin{center}
\linesBefore(6)
\diagram(
let _ = array [`East ; `East ; `West; `West]
  ~horizontal_padding:(function 3 -> 20.0 | _ -> 1.0)
  [ [ <$v,w$>; <$::=$>; <$ x \| {λx t} $>          ; <$(Λ_{val})$> ]
  ; [ <$t,u$>; <$::=$>; <$ v \| {t u} $>           ; <$(Λ)$>       ]
  ; [ <$π,ρ$>; <$::=$>; <$ ε \| {v ⋅ π} \| [t] π $>; <$(Π)$>       ]
  ; [ <$p,s$>; <$::=$>; <$ t ∗ π $>                ; <$(Λ × Π)$>   ] ]
)
\end{center}
\end{def}
The syntactic distinction between terms and values is specific to the
call-by-value presentation, they would be collapsed in call-by-name.
Intuitively, a stack can be thought of as an evaluation context represented
as a list of terms and values. The values are to be considered as arguments
to be fed to the term in the context, and the terms are to be considered as
functions to which the term in the context will be applied. The symbol $ε$
is used to denote an empty stack. A process $t ∗ π$ is to be considered as
the state of our abstract machine. Its reduction will consist in the
interaction between the term $t$ and its evaluation context encoded into
a stack $π$.

As we are considering a call-by-value calculus, only values are (and should
be) substituted to $λ$-variables during evaluation. From now on, we will
hence work with the following definition of substitution. In particular,
a substitution of the form $t[x := u]$ will be forbidden if $u$ is not a
syntactic value.
\begin{def}
Let $t ∈ Λ$ be a term, $x ∈ \cal{V}_λ$ be a $λ$-variable and $v \in Λ_{val}$
be a value. We denote $t[x := v]$ the capture-avoiding substitution of $x$
by $v$ in $t$.
\end{def}
\begin{def}
The reduction relation $({\succ}) ⊆ (Λ×Π) × (Λ×Π)$ is defined as the smallest
relation satisfying the following rules. We will denote $({\succ}^{∗})$ its
reflexive and transitive closure.
\begin{center}
\linesBefore(4)
\diagram(
let _ = array [`East ; `Main ; `West]
  ~horizontal_padding:(function _ -> 5.0)
  [ [ <${t u} ∗ π$>     ; <$\succ$>; <$u ∗ {[t]π}$>       ]
  ; [ <$v ∗ {[t] π}$>   ; <$\succ$>; <$t ∗ {v·π}$>        ]
  ; [ <$λx t ∗ {v · π}$>; <$\succ$>; <${t[x := v]} ∗ π$>  ] ]
)
\end{center}
\end{def}
Three reduction rules are used to handle call-by-value evaluation. When an
application is encountered, the function is stored in a stack-frame in order
to evaluate its argument first. Once the argument has been completely
computed, a value faces the stack-frame containing the function. At this
point the function can be evaluated and the value is stored in the stack
ready to be consumed by the function as soon as it evaluates to a
$λ$-abstraction. A capture-avoiding substitution can then be performed to
effectively apply the argument to the function. For example, the process
${(λx x y) λz z} ∗ ε$ reduces in the following way.
$$
  {{(λx x y) λz z} ∗ ε}
  \succ
  {{λz z} ∗ {[λx x y]ε}}
  \succ
  {{λx x y} ∗ {{λz z} · ε}}
  \succ
  {{(λz z) y} ∗ ε}
  \succ
  {y ∗ ε}
$$
\begin{rem}
The choice of right-to-left call-by-value allows for a simpler abstract
machine. Indeed, an additional stack constructor and reduction rule would
be required to implement the more usual left-to-right evaluation.
\end{rem}

=<
