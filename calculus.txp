\Caml(
open Diagrams
open ProofTree

module KAM =
  struct
    open Decap

    type vari = string * int option

    type valu =
      | VVari of vari               (* x, y   *)
      | VMeta of vari               (* v, w   *)
      | VLAbs of vari * term        (* λx t   *)
    and  term =
      | TVari of vari               (* a, b   *)
      | TMeta of vari               (* t, u   *)
      | TValu of valu
      | TGrou of term               (* (t)    *)
      | TAppl of term * term        (* t u    *)
      | TSave of vari * term        (* μα t   *)
      | TRest of stac * term        (* [π]t   *)
      | TCtxt of ctxt * term        (* E[t]   *)
      | TVSub of term * (vari * bool * valu) (* t[x≔v] of t[x←v] *)
      | TSSub of term * (vari * bool * stac) (* t[α≔π] of t[α←π] *)
    and  ctxt =
      | CHole                       (* [-]    *)
      | CPlug of ctxt * ctxt        (* E[F]   *)
      | CMeta of vari               (* E, F   *)
      | CGrou of ctxt               (* (E)    *)
      | CLAbs of vari * ctxt        (* λx E   *)
      | CAppL of ctxt * term        (* E t    *)
      | CAppR of term * ctxt        (* t E    *)
    and  stac =
      | SEmpt                       (* ε      *)
      | SVari of vari               (* α, β   *)
      | SMeta of vari               (* π, ρ   *)
      | SPush of valu * stac        (* v.π    *)
      | SFram of term * stac        (* [t]π   *)
    and  proc =
      | PMeta of vari               (* p, q   *)
      | PProc of term * stac        (* t ∗ π  *)

    let parser index =
      | "₀" -> 0 | "₁" -> 1 | "₂" -> 2 | "₃" -> 3 | "₄" -> 4
      | "₅" -> 5 | "₆" -> 6 | "₇" -> 7 | "₈" -> 8 | "₉" -> 9

    let parser vari p = x:p i:index? _:relax
    let vari ns = vari (alternatives (List.map (fun n -> string n n) ns))

    let vvari = vari ["x"; "y"; "z"]
    let vmeta = vari ["v"; "w"]
    let tvari = vari ["a"; "b"; "c"]
    let tmeta = vari ["t"; "u"; "Ω"]
    let cmeta = vari ["E"; "F"]
    let svari = vari ["α"; "β"; "γ"]
    let smeta = vari ["π"; "ρ"]
    let pmeta = vari ["p"; "q"]

    let appl = List.fold_left (fun t u -> TAppl(t,u))

    type prio = Atom | Subs | Appl

    let parser valu =
      | x:vvari                                         -> VVari(x)
      | v:vmeta                                         -> VMeta(v)
      | "λ" x:vvari t:(term Appl)                       -> VLAbs(x,t)
    and        term prio =
      | a:tvari                        when prio = Atom -> TVari(a)
      | t:tmeta                        when prio = Atom -> TMeta(t)
      | v:valu                         when prio = Atom -> TValu(v)
      | '(' t:(term Appl) ')'          when prio = Atom -> TGrou(t)
      | t:(term Subs) ts:(term Subs)*$ when prio = Appl -> appl t ts
      | "μ" a:svari t:(term Appl)      when prio = Atom -> TSave(a,t)
      | '[' s:stac ']' t:(term Appl)   when prio = Atom -> TRest(s,t)
      | t:(term Atom) '[' x:vvari s:{"≔" -> true | "←" -> false} v:valu ']'
                                       when prio = Subs -> TVSub(t,(x,s,v))
      | t:(term Atom) '[' x:svari s:{"≔" -> true | "←" -> false} pi:stac ']'
                                       when prio = Subs -> TSSub(t,(x,s,pi))
      | c:(ctxt Atom) '[' t:(term Appl) ']'
                                       when prio = Atom -> TCtxt(c,t)
      | t:(term Atom)                  when prio = Subs -> t
    and        ctxt prio =
      | "[]"                           when prio = Atom -> CHole
      | e:(ctxt Atom) '[' f:(ctxt Appl) ']'
                                       when prio = Atom -> CPlug(e,f)
      | e:cmeta                        when prio = Atom -> CMeta(e)
      | '(' e:(ctxt Appl) ')'          when prio = Atom -> CGrou(e)
      | "λ" x:vvari e:(ctxt Appl)      when prio = Atom -> CLAbs(x,e)
      | e:(ctxt Subs) t:(term Atom)    when prio = Appl -> CAppL(e,t)
      | t:(term Atom) e:(ctxt Subs)    when prio = Appl -> CAppR(t,e)
      | e:(ctxt Atom)                  when prio = Subs -> e
      | e:(ctxt Subs)                  when prio = Appl -> e
    and        stac =
      | "ε"                                             -> SEmpt
      | a:svari                                         -> SVari(a)
      | s:smeta                                         -> SMeta(s)
      | v:valu '.' s:stac                               -> SPush(v,s)
      | '[' t:(term Appl) ']' s:stac                    -> SFram(t,s)
    and        proc =
      | p:pmeta                                         -> PMeta(p)
      | t:(term Appl) "∗" s:stac                        -> PProc(t,s)

    let term = term Appl
    let ctxt = ctxt Appl

    let parse g =
      let parse = parse_string g (blank_regexp ''[ ]*'') in
      handle_exception parse

    let parse_valu = parse valu
    let parse_term = parse term
    let parse_ctxt = parse ctxt
    let parse_stac = parse stac
    let parse_proc = parse proc

    let str s = [Maths.Ordinary (Maths.node (Maths.glyphs s))]

    let vari2m (s, io) =
      match io with
      | None   -> str s
      | Some i -> let n = Maths.node (Maths.glyphs s) in
                  let subscript_right = str (string_of_int i) in
                  let n = { n with subscript_right } in
                  [Maths.Ordinary n]

    let rec v2m : valu -> Maths.math list = function
      | VVari(x)   -> vari2m x
      | VMeta(v)   -> vari2m v
      | VLAbs(x,t) -> (str "λ") @ (vari2m x) @ (str ".") @ (t2m t)
    and     t2m : term -> Maths.math list = function
      | TVari(a)   -> vari2m a
      | TMeta(t)   -> vari2m t
      | TValu(v)   -> v2m v
      | TGrou(t)   -> (str "(") @ (t2m t) @ (str ")")
      | TAppl(t,u) -> (t2m t) @ (str " ") @ (t2m u)
      | TSave(a,t) -> (str "μ") @ (vari2m a) @ (str ".") @ (t2m t)
      | TRest(s,t) -> (str "[") @ (s2m s) @ (str "]") @ (t2m t)
      | TVSub(t,s) -> let (x,s,v) = s in
                      let sub l r =
                        let b =
                          if s then MathFonts.asana "\\defeq" 798
                          else Maths.glyphs "←"
                        in
                        [bin 2 (Normal(false, Maths.node b,false)) l r]
                      in
                      let sub = sub (vari2m x) (v2m v) in
                      (t2m t) @ (str "[") @ sub @ (str "]")
      | TSSub(t,s) -> let (x,s,pi) = s in
                      let sub l r =
                        let b =
                          if s then MathFonts.asana "\\defeq" 798
                          else Maths.glyphs "←"
                        in
                        [bin 2 (Normal(false, Maths.node b,false)) l r]
                      in
                      let sub = sub (vari2m x) (s2m pi) in
                      (t2m t) @ (str "[") @ sub @ (str "]")
      | TCtxt(e,t) -> (c2m e) @ (str "[") @ (t2m t) @ (str "]")
    and     c2m : ctxt -> Maths.math list = function
      | CHole      -> (str "[") @ <$\wc$> @ (str "]")
      | CPlug(e,f) -> (c2m e) @ (str "[") @ (c2m f) @ (str "]")
      | CMeta(e)   -> vari2m e
      | CGrou(e)   -> (str "(") @ (c2m e) @ (str ")")
      | CLAbs(x,e) -> (str "λ") @ (vari2m x) @ (str ".") @ (c2m e)
      | CAppL(e,t) -> (c2m e) @ (str " ") @ (t2m t)
      | CAppR(t,e) -> (t2m t) @ (str " ") @ (c2m e)
    and     s2m : stac -> Maths.math list = function
      | SEmpt      -> <$ε$>
      | SVari(a)   -> vari2m a
      | SMeta(s)   -> vari2m s
      | SPush(v,s) -> let sym = Maths.node (Maths.glyphs "·") in
                      [bin 2 (Normal(false, sym, false)) (v2m v) (s2m s)]
      | SFram(t,s) -> (str "[") @ (t2m t) @ (str "]") @ (s2m s)
    and     p2m : proc -> Maths.math list = function
      | PMeta(p)   -> vari2m p
      | PProc(t,s) -> let sym = Maths.node (Maths.glyphs "∗") in
                      [bin 2 (Normal(false, sym, false)) (t2m t) (s2m s)]

    let valu : string -> Maths.math list = fun s -> v2m (parse_valu s)
    let term : string -> Maths.math list = fun s -> t2m (parse_term s)
    let ctxt : string -> Maths.math list = fun s -> c2m (parse_ctxt s)
    let stac : string -> Maths.math list = fun s -> s2m (parse_stac s)
    let proc : string -> Maths.math list = fun s -> p2m (parse_proc s)
end

let v = KAM.valu
let t = KAM.term
let c = KAM.ctxt
let s = KAM.stac
let p = KAM.proc

module LambdaCalculus =
  struct
    open Decap

    type vari = string * int option

    type term =
      | Var of vari
      | Abs of vari * term
      | App of term * term
      | Par of term
      | Sub of term * (vari * bool * term)
      | Ctx of ctxt * term
    and ctxt =
      | Hole of vari option
      | CPar of ctxt
      | CAbs of vari * ctxt
      | LApp of ctxt * term
      | RApp of term * ctxt

    type stac =
      | Alp of string
      | Psh of term * stac
      | Frm of term * stac

    let build_app = List.fold_left (fun t u -> App(t,u))
    let build_sub t = function
      | None   -> t
      | Some s -> Sub(t,s)

    type prio = Atom | Subs | Appl
    let parser lvar = ''[a-z]'' - {"₀" -> 0 | "₁" -> 1 | "₂" -> 2 | "₃" -> 3
      | "₄" -> 4 | "₅" -> 5}? _:relax
    let parser cvar = ''[A-Z]'' - {"₀" -> 0 | "₁" -> 1 | "₂" -> 2 | "₃" -> 3
      | "₄" -> 4 | "₅" -> 5}? _:relax

    let parser lterm prio =
      | x:lvar                             when prio = Atom -> Var(x)
      | '(' t:(lterm Appl) ')'             when prio = Atom -> Par(t)
      | "λ" x:lvar t:(lterm Appl)          when prio = Atom -> Abs(x,t)
      | t:(lterm Subs) ts:(lterm Subs)*$   when prio = Appl -> build_app t ts
      | t:(lterm Atom) s:{'[' subst ']'}?$ when prio = Subs -> build_sub t s
      | e:(lctxt Atom) '[' t:(lterm Appl) ']' when prio = Atom -> Ctx(e,t)
    and subst =
      | x:lvar s:{"←" -> false | "≔" -> true} u:(lterm Appl)
    and lctxt prio =
      | "[]"                          when prio = Atom -> Hole(None)
      | e:cvar                        when prio = Atom -> Hole(Some e)
      | '(' e:(lctxt Appl) ')'        when prio = Atom -> CPar(e)
      | "λ" x:lvar e:(lctxt Appl)     when prio = Atom -> CAbs(x,e)
      | e:(lctxt Subs) t:(lterm Atom) when prio = Appl -> LApp(e,t)
      | t:(lterm Atom) e:(lctxt Subs) when prio = Appl -> RApp(t,e)
      | e:(lctxt Atom)                when prio = Subs -> e
      | e:(lctxt Subs)                when prio = Appl -> e

    let parser mvar = "ε" -> "ε" | "α" -> "α" | "β" -> "β" | "γ" -> "γ"
      | "π" -> "π" | "ρ" -> "ρ"

    let parser stack =
      | a:mvar                          -> Alp(a)
      | t:(lterm Appl) "." pi:stack     -> Psh(t,pi)
      | '[' t:(lterm Appl) ']' pi:stack -> Frm(t,pi)

    let parser proc =
      | t:(lterm Appl) "∗" pi:stack

    let lterm = lterm Appl
    let lctxt = lctxt Appl

    let parse_term =
      let parse = parse_string lterm (blank_regexp ''[ ]*'') in
      handle_exception parse

    let parse_ctxt =
      let parse = parse_string lctxt (blank_regexp ''[ ]*'') in
      handle_exception parse

    let parse_stac =
      let parse = parse_string stack (blank_regexp ''[ ]*'') in
      handle_exception parse

    let parse_proc =
      let parse = parse_string proc (blank_regexp ''[ ]*'') in
      handle_exception parse

    let str s = [Maths.Ordinary (Maths.node (Maths.glyphs s))]

    let v2m (s, io) =
      match io with
      | None   -> str s
      | Some i -> let n = Maths.node (Maths.glyphs s) in
                  let subscript_right = str (string_of_int i) in
                  let n = { n with subscript_right } in
                  [Maths.Ordinary n]

    let rec t2m = function
      | Var(x)   -> v2m x
      | Abs(x,t) -> (str "λ") @ (v2m x) @ (str ".") @ (t2m t)
      | App(t,u) -> (t2m t) @ (str " ") @ (t2m u)
      | Par(t)   -> (str "(") @ (t2m t) @ (str ")")
      | Sub(t,s) -> let (x, s, u) = s in
                    let sub l r =
                      let b =
                        if s then MathFonts.asana "\\defeq" 798
                        else Maths.glyphs "←";
                      in
                      [bin 2 (Normal(false, Maths.node b,false)) l r]
                    in
                    (t2m t) @ (str "[") @ (sub (v2m x) (t2m u)) @ (str "]")
      | Ctx(e,t) -> (c2m e) @ (str "[") @ (t2m t) @ (str "]")
    and c2m = function
      | Hole(None)   -> (str "[") @ <$\wc$> @ (str "]")
      | Hole(Some e) -> v2m e
      | CPar(e)      -> (str "(") @ (c2m e) @ (str ")")
      | CAbs(x,e)    -> (str "λ") @ (v2m x) @ (str ".") @ (c2m e)
      | LApp(e,t)    -> (c2m e) @ (str " ") @ (t2m t)
      | RApp(t,e)    -> (t2m t) @ (str " ") @ (c2m e)

    let rec s2m = function
      | Alp(a)    -> [Maths.Ordinary (Maths.node (Maths.glyphs a))]
      | Psh(v,pi) -> let sym = Maths.node (Maths.glyphs "·") in
                     [bin 2 (Normal(false, sym, false)) (t2m v) (s2m pi)]
      | Frm(t,pi) -> (str "[") @ (t2m t) @ (str "]") @ (s2m pi)

    let p2m (t,pi) =
      let sym = Maths.glyphs "∗" in
      let sym = Maths.node sym in
      [bin 2 (Normal(false, sym, false)) (t2m t) (s2m pi)]

    let lctxt s = c2m (parse_ctxt s)
    let lterm s = t2m (parse_term s)
    let stack s = s2m (parse_stac s)
    let proc  s = p2m (parse_proc s)
  end

let lterm = LambdaCalculus.lterm
let lctxt = LambdaCalculus.lctxt
let stack = LambdaCalculus.stack
let proc  = LambdaCalculus.proc

let lmcalc =
  let lm = [Maths.Ordinary (Maths.node (Maths.glyphs "λμ"))] in
  << $\lm$-calculus >>
)
\Include{Macros}

=> Untyped calculus and abstract machine \label("calculus")

In this chapter, we introduce the programming language that will be
considered throughout this thesis. Its operational semantics is expressed
in terms of an abstract machine, which will allow us to account for
computational effects.

=> The pure $λ$-calculus

In this thesis, we consider a programming language of the ML family, similar
to OCaml or SML. Like every functional language, its syntax is based on the
$λ$-calculus. Introduced by Alonzo Church in the Thirties, the $λ$-calculus
\cite("Church1941") is a formalism for representing computable functions, and
in particular recursive functions. As shown by Alan Turing, the $λ$-calculus
is a //universal model of computation// \cite("Turing1937").

(* The language of λ-terms. *)
\begin{def}\label("deflambda")
The terms of the $λ$-calculus (or $λ$-terms) are built from a countable
alphabet of variables (or $λ$-variables) denoted $\cal{V}_λ=\{x,y,z...\}$.
The set of all the $λ$-terms is denoted $Λ$ and is defined as the language
recognised by the following ||bnf|| grammar.
\Caml(
let _ = sidenote
  << $t,u ::= x \| \t("λx t") \| \t("t u")$ >>
  << $x ∈ \cal{V}_λ$ >>
)
A term of the form $\t("λx t")$ is called an abstraction (or
$λ$-abstractions) and a term of the form $\t("t u")$ is called an
application.
\end{def}
Intuitively, a $λ$-abstraction $\t("λx t")$ forms a function by binding
the variable $x$ in the term $t$. This would be denoted $x ↦ t$ in common
mathematics. Similarly, a term of the form $\t("t u")$ denotes the
application of (the function) $t$ to (the argument) $u$. This would be
denoted $t(u)$ in common mathematics. 
\begin{rem}
As $λ$-terms have a tree-like structure, parenthesis are sometimes required
for disambiguation. For example, the term $\t("λx t u")$ can be read both
as $\t("(λx t) u")$ and as $\t("λx (t u)")$. To lighten the notations
we will consider application to be left-associative and abstraction to bind
stronger that application. As a consequence, we will always read the term
$\t("λx t x u")$ as $\t("λx ((t x) u)")$.
\end{rem}
\begin{rem}
The syntax of the $λ$-calculus only allows for one-place functions. To form
a function of two arguments (or more) one must rely on Curryfication.
Indeed, a function of two arguments can be seen as a function of one
argument returning a function. Following this scheme, the multiple arguments
of the function are given in turn, and not simultaneously. As an example,
the function $(x,y) ↦ x$ can be encoded as $\t("λx λy x")$.
\end{rem}

Although this is not reflected explicitly in the syntax of $λ$-terms,
a $λ$-variable may play two very different roles. It can be used either as
a constant, like $y$ in the constant function $\t("λx y")$, or as a
reference to a binder, like $x$ in the identity function $\t("λx x")$.
Variable binding and the associated notions of free and bound variable are
hence essential.
\begin{def}\label("freelvars")
Given a term $t$, we denote by $FV_λ(t)$ the set of its free $λ$-variables
and $BV_λ(t)$ the set of its bound $λ$-variables. These sets are defined
inductively on the structure of the term $t$.
\begin{center}
\linesBefore(4)
\diagram(
let contents = two_cols
 [ [ <$ FV_λ(x) $>
   ; <$ = $>; <$ \{x\} $> ]
 ; [ <$ FV_λ(\t("λx t")) $>
   ; <$ = $>; <$ FV_λ(t) \setminus \{x\} $> ]
 ; [ <$ FV_λ(\t("t u")) $>
   ; <$ = $>; <$ FV_λ(t) ∪ FV_λ(u) $> ]
 ; [ <$ BV_λ(x) $>
   ; <$ = $>; <$ ∅ $> ]
 ; [ <$ BV_λ(\t("λx t")) $>
   ; <$ = $>; <$ BV_λ(t) ∪ \{x\} $> ]
 ; [ <$ BV_λ(\t("t u")) $>
   ; <$ = $>; <$ BV_λ(t) ∪ BV_λ(u) $> ] ]
let _ = array [`East; `Main; `West; `East; `Main; `West] contents
          ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\end{def}
\begin{rem}
Nothing prevents a $λ$-variable to have both free and bound occurrences in
a term. For example, in $t = \t("λx y λy x y")$ the first occurrence of
$y$ is free while its second occurrence is bound.
We have $y ∈ FV_λ(t) = \{y\}$ and $y ∈ BV_λ(t) = \{x, y\}$.
\end{rem}

(* Substitution, α-equivalence and β-reduction. *)
When a $λ$-abstraction (i.e. a function) is applied to an argument, we
obtain a term of the form $\t("(λx t) u")$, called a $β$-redex. The
reduction of such $β$-redexes plays an essential role in computation.
Intuitively, the reduction of the $β$-redex $\t("(λx t) u")$ will be
performed by replacing every occurrence of the bound variable $x$ by $u$ in
the term $t$. This operation, called substitution, is formally defined as
follows.
\begin{def}
Let $t ∈ Λ$ and $u ∈ Λ$ be two $λ$-terms, and $x ∈ \cal{V}_λ$ be a
$λ$-variable. We denote $\lterm("t[x ← u]")$ the term $t$ in which every
free occurrence of $x$ has been replaced by $u$. This operation is defined
inductively on the structure of $t$.
\begin{center}
\linesBefore(5)
\diagram(
let contents =
  let line l r = [ <$ \lterm(l) $> ; <$ = $> ; <$ \lterm(r) $> ] in
  let data =
    [ line "x[x ← u]"       "u"
    ; line "y[x ← u]"       "y"
    ; line "(λx t)[x ← u]"  "λx t"
    ; line "(λy t)[x ← u]"  "λy t[x ← u]"
    ; line "(t₁ t₂)[x ← u]" "t₁[x ← u] t₂[x ← u]" ]
  in two_cols data

let _ =
  array [`East; `Main; `West; `East; `Main; `West] contents
    ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\end{def}
Substitution is a subtle notion, and care should be taken to avoid capture
of variables. For example, let us consider the function $\lterm("λx λy x")$
which takes an argument $x$ and returns a constant function with value $x$.
If we apply this function to $y$, the expected result is a constant function
with value $y$. However, if we blindly substitute $x$ with $y$ in
$\lterm("λy x")$ we obtain the identity function $\lterm("λy y")$. Indeed,
the free variable $y$ has been captured and now references a binder that had
(coincidentally) the same name.

To solve this problem, we need to make sure that whenever a substitution
$\lterm("t[x ← u]")$ is performed, no free variable of $u$ is bound in $t$
(i.e. $FV_λ(u) ∩ BV_λ(t) = ∅$). Although we cannot rename the free variables
of $u$, it is possible to rename the bound variables of $t$. Indeed, changing
the name of a bound variable has no effect on the computational behaviour of
a term. Two terms that are equivalent up to the names of their bound
variables are said to be $α$-equivalent.
\begin{def}
The $α$-equivalence relation $({≡}_α) ⊆ Λ×Λ$ is defined, like in
\cite("Krivine1990"), as the smallest relation such that:
\begin{itemize}
\item if $x ∈ \cal{V}_λ$ then $x ≡_α x$,
\item if $t₁ ≡_α t₂$ and $u₁ ≡_α u₂$ then
      $\lterm("t₁ u₁") ≡_α \lterm("t₂ u₂")$,
\item if $\lterm("t₁[x₁ ← y]") \nequiv_α \lterm("t₂[x₂ ← y]")$ for only
      finitely many $y ∈ \cal{V}_λ$ then
      $\lterm("λx₁ t₁") ≡_α \lterm("λx₂ t₂")$.
\end{itemize}
\end{def}
\begin{lem}\label("alphalem")
Given a term $t ∈ Λ$ and a finite set of variables $V ⊆ \cal{V}_λ$, it is
always possible to find a term $t₀ ∈ Λ$ such that $t₀ ≡_α t$ and
$BV_λ(t₀) ∩ V = ∅$.
\begin{proof}
A full proof is available in \id(dcite "Krivine1990" "Lemma 1.11").
\end{proof}
\end{lem}
\begin{def}
Let $t ∈ Λ$ and $u ∈ Λ$ be two $λ$-terms, and $x ∈ \cal{V}_λ$ be a
$λ$-variable. We denote $\lterm("t[x ≔ u]")$ the capture-avoiding
substitution of $x$ by $u$ in $t$. It is defined as $\lterm("t₀[x ← u]")$
where $t₀ ∈ Λ$ is a term such that $t₀ ≡_α t$ and $BV_λ(t₀) ∩ FV(u) = ∅$.
Such a term exists according to \lemRef("alphalem").
\end{def}

=<

=> Evaluation contexts and reduction

To define the most general notion of reduction over $λ$-terms, we
need to be able to refer to any $β$-redex. To this aim, we
introduce the notion of evaluation context. Intuitively, a context will
consist in a term with a hole (i.e. a place-holder for a subterm) and it
will allow us to focus on any particular subterm of a term.
\begin{def}
The set of evaluation contexts $[Λ]$ is defined as the language recognised
by the following ||bnf|| grammar.
\Caml(
let _ = sidenote
  << $E, F ::= \lctxt("[]") \| \lctxt("λx E") \| \lctxt("E t") \|
     \lctxt("t E")$ >>
  << $x∈\cal{V}_λ$, $t∈Λ$ >>
)
\end{def}
\begin{def}
Given a term $u ∈ Λ$ and an evaluation context $E ∈ [Λ]$, we denote
$\lterm("E[u]")$ the term formed by putting $u$ into the hole of the
evaluation context $E$. It is defined by induction on the structure of
$E$ as follows.
\begin{center}
\diagram(
let contents =
  let line l r = [ <$ \lterm(l) $> ; <$ = $> ; <$ \lterm(r) $> ] in
  let data =
    [ line "[][u]"     "u"
    ; line "(λx E)[u]" "λx E[u]"
    ; line "(E t)[u]"  "E[u] t"
    ; line "(t E)[u]"  "t E[u]" ]
  in two_cols data
let _ =
  array [`East; `Main; `West; `East; `Main; `West] contents
    ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\end{def}
\begin{def}
Given a set of evaluation context $C ⊆ [Λ]$, we denote $\cal{R}(C) ⊆ Λ×Λ$
the $β$-reduction relation induced by $C$. It is defined as the smallest
relation such that for every evaluation context $E ∈ C$, for every terms
$t ∈ Λ$ and $u ∈ Λ$, and for every variable $x ∈ \cal{V}_λ$ we have the
following.
$$ (\lterm("E[(λx t) u]"), \lterm("E[t[x ≔ u]]")) ∈ \cal{R}(C) $$
\end{def}
\begin{def}\label("generalbeta")
The general $β$-reduction $({→}_β) ⊆ Λ×Λ$ is defined as $\cal{R}([Λ])$. We
say that the term $t ∈ Λ$ is in $β$-normal-form if there is no $u ∈ Λ$ such
that $t →_β u$. We denote $({→}_β^{∗})$ the reflexive, transitive closure of
$({→}_β)$.
\end{def}

The general $β$-reduction relation $({→}_β)$ is non-deterministic. Indeed,
given a term $t$, there might be two (different) terms $u₁$ and $u₂$ such
that $t →_β u₁$ and $t →_β u₂$. For example, the term
$\lterm("((λx₁ x₁) λx₂ x₂) ((λx₃ x₃) λx₄ x₄)")$ can either reduce to
$\lterm("(λx₂ x₂) ((λx₃ x₃) λx₄ x₄)")$ or to
$\lterm("((λx₁ x₁) λx₂ x₂) (λx₄ x₄)")$. Indeed, we can focus on the $β$-redex
$\lterm("(λx₁ x₁) λx₂ x₂")$ using the evaluation context
$\lctxt("[] ((λx₃ x₃) λx₄ x₄)")$, or on the $β$-redex
$\lterm("(λx₃ x₃) λx₄ x₄")$ using the evaluation context
$\lctxt("((λx₁ x₁) λx₂ x₂) []")$.
Although it is non-deterministic, the general $β$-reduction relation
$({→}_β)$ has the Church-Rosser property \cite("Church1936").
\begin{thm}
Let $t ∈ Λ$ be a term. If there are $u₁ ∈ Λ$ and $u₂ ∈ Λ$ such that
$t →_β u₁$ and $t →_β u₂$, then there must be $u ∈ Λ$ such that
${u₁ →_β u}^{∗}$ and ${u₂ →_β u}^{∗}$.
\begin{proof}
A full proof is available in \cite("Church1936").
\end{proof}
\end{thm}
Intuitively, the Church-Rosser property enforces a weak form of determinism.
Indeed, it implies that a program can only compute one particular result,
even if it can be attained in several different ways.

In the following, we are going to consider an effectful language, that does
not have the Church-Rosser property. As a consequence, we will need to
restrict ourselves to a deterministic subset of the general $β$-reduction
relation. If we were to work with a completely non-deterministic reduction
relation, it would be extremely difficult to reason about our language.
Programs would not only compute different possible results, but also
terminate in a non-deterministic way. Moreover, it would be silly to
implement a non-deterministic evaluation procedure for a programming
language.

The choice of the order in which $β$-redexes are reduced is called an
//evaluation strategy//. The two evaluation strategies that are the most
widely used in practice are called //call-by-name// and //call-by-value//.
They both reduce outermost $β$-redexes first, and do not reduce $β$-redexes
that are contained in the body of a $λ$-abstraction. This means that the
term $\lterm("λx (λy y) x")$ is considered to be in normal form and cannot
be evaluated further. In call-by-name, terms that are in function position
are reduced first, and the computation of their arguments is delayed to the
time of their effective use. In call-by-value, both arguments and functions
are evaluated before performing the $β$-reduction. One way to formalize
these evaluation strategies is to restrict the notion of evaluation context,
to only allow focusing on the $β$-redex that is going to be reduced next.
\begin{def}
The set of call-by-name evaluation contexts $[N] ⊆ [Λ]$ is defined as the
language recognised by the following ||bnf|| grammar.
\Caml(
let _ = sidenote
  << $E, F ::= \lctxt("[]") \| \lctxt("E t") $ >>
  << $t∈Λ$ >>
)
The call-by-name reduction relation $({→}_N) ⊆ Λ×Λ$ is defined as
$\cal{R}([N])$.
\end{def}

In call-by-value, both the function and its argument need to be fully
evaluated before the application can be performed. Consequently, two
different call-by-value strategies can be defined: left-to-right and
right-to-left call-by-value evaluation. The former fully evaluates the
terms that are in function position first and the latter evaluates the
terms that are in argument position first. Although left-to-right
call-by-value evaluation is most widely used, some practical languages
like OCaml use right-to-left evaluation. In this thesis, we make the
same choice and only consider right-to-left call-by-value evaluation.
\begin{def}
A term $t$ is said to be a value if it is either a $λ$-variable or a
$λ$-abstraction. The set $Λ_{val} ⊆ Λ$ of all the values is generated by the
following ||bnf|| grammar.
\Caml(
let _ = sidenote
  << $v,w ::= x \| \lterm("λx t") $ >>
  << $x ∈ \cal{V}_λ$ >>
)
\end{def}
\begin{def}
The set of right-to-left call-by-value evaluation contexts $[V] ⊆ [Λ]$ is
defined as the language recognised by the following ||bnf|| grammar.
\Caml(
let _ = sidenote
  << $E, F ::= \lctxt("[]") \| \lctxt("E v") \| \lctxt("t E") $ >>
  << $v∈Λ_{val}$, $t∈Λ$ >>
)
The right-to-left call-by-value reduction relation $({→}_V) ⊆ Λ×Λ$ is
defined as $\cal{R}([V])$.
\end{def}
\begin{rem}
Left-to-right call-by-value evaluation can be defined using evaluation
contexts generated by the following ||bnf|| grammar.
\Caml(
let _ = sidenote
  << $E, F ::= \lctxt("[]") \| \lctxt("E t") \| \lctxt("v E") $ >>
  << $t∈Λ$, $v∈Λ_{val}$ >>
)
\end{rem}

A given term of the $λ$-calculus may reduce in a very different way with
different evaluation strategies. For example, the evaluation of the term
$\lterm("(λy z) ((λx x x) (λx x x))")$ stops in one step in call-by-name
$$ \lterm("(λy z) ((λx x x) (λx x x))") →_N \lterm("z") $$
and it goes into a loop in call-by-value.
$$ \lterm("(λy z) ((λx x x) (λx x x))") →_V
   \lterm("(λy z) ((λx x x) (λx x x))") $$

\begin{rem}
Our reduction relations can be alternatively defined using a deduction rule
system. A deduction rule is formed using premisses $\{P_i\}_{1≤i≤n}$ and
a conclusion $C$ separated by an horizontal bar.
$$ \ternaryR{P₁}{...}{P_n}{C} $$
The meaning of such a rules is that the conclusion $C$ can be deduced when
all the premisses $P_i$ are true. In particular, if there is no premise then
the conclusion can be deduced immediately. Using this formalism, the
call-by-value reduction corresponds to the smallest relation satisfying the
following two rules.
$$
  \axiomR{\lterm("(λx t) u") →_N \lterm("t[x ≔ u]")}
  \hspace(6.0)
  \unaryR{\lterm("t₁") →_N \lterm("t₂")}{\lterm("t₁ u") →_N \lterm("t₂ u")}
$$
Similarly, the right-to-left call-by-value reduction relation $({→}_V)$
corresponds to the smallest relation satisfying the following three rules.
$$
  \axiomR{\lterm("(λx t) v") →_V \lterm("t[x ≔ v]")}
  \hspace(4.0)
  \unaryR{\lterm("u₁") →_V \lterm("u₂")}{\lterm("t u₁") →_V \lterm("t u₂")}
  \hspace(4.0)
  \unaryR{\lterm("t₁") →_V \lterm("t₂")}{\lterm("t₁ v") →_V \lterm("t₂ v")}
$$
\end{rem}

In this thesis, $λ$-terms and programs in general will be evaluated in an
abstract machine called a Krivine machine \cite("Krivine2007"). This
machine will emulate the right-to-left evaluation relation $({→}_V)$. It
will provide us with a computational framework in which programs and their
evaluation contexts can be manipulated easily.

=<

=> Call-by-value Krivine machine

In the previous section, we introduced the syntax of the $λ$-calculus and
the evaluation of $λ$-terms. We will now reformulate these definition in
terms of a call-by-value Krivine abstract machine \cite("Krivine2007").
Our presentation will differ from the original machine, which is
call-by-name. Although call-by-value Krivine machines have rarely been
published, they are well-known in the classical realizability community.

The main idea behind the Krivine abstract machine is to think of a term
$\t("t₀") ∈ Λ$ as a couple $(\t("t"),\c("E")) ∈ Λ × [V]$ such that
$\t("t₀") = \t("E[t]")$ (the term $\t("t")$ is said to be in head position).
Using this reprensentation, $β$-reduction proceeds in two steps. First, the
machine state $(\t("t"), \c("E"))$ is transformed into a state of the form
$(\t("(λx u) v"), \c("F"))$, in such a way that
$\t("E[t]") = \t("F[(λx u) v]")$. The $β$-redex can then be reduced to
obtain the state $(\t("u[x ≔ v]"), \c("F"))$. This behaviour can be attained
using the following reduction rules, which are obtained naturally from the
definition of right-to-left call-by-value evaluation.
\begin{center}
\diagram(
let _ =
  let line (t1,c1) (t2,c2) n =
    [ <$(\t(t1), \c(c1))$> ; <$→$>; <$(\t(t2), \c(c2))$>; n ]
  in
  array [`East ; `Main ; `West; `West] ~horizontal_padding:(function _ -> 5.0)
    [ line ("t u"     , "E"      ) ("u"       , "E[t []]")
      <$rhen \hspace(0.4) u∉Λ_{val}$>
    ; line ("v"       , "E[t []]") ("t v"     , "E"      )
      []
    ; line ("t v"     , "E"      ) ("t"       , "E[[] v]")
      <$when \hspace(0.4) t∉Λ_{val}$>
    ; line ("v"       , "E[[] w]") ("v w"     , "E"      )
      []
    ; line ("(λx t) v", "E"      ) ("t[x ≔ v]", "E"      )
      [] ]
)
\linesAfter(2)
\end{center}
The four first rules are responsible for bringing the next $β$-redex
(according to our reduction strategy) in head position, and the last
rule performs the $β$-reduction. Note that the first four rules do not
change the represented term, and only move arguments or functions between
the term and the evaluation context. Our set of reduction rule can be
simplified to the following, by composing the last two pairs of rules.
\begin{center}
\linesBefore(5)
\diagram(
let _ =
  let line (t1,c1) (t2,c2) =
    [ <$(\t(t1), \c(c1))$> ; <$→$>; <$(\t(t2), \c(c2))$> ]
  in
  array [`East ; `Main ; `West] ~horizontal_padding:(function _ -> 5.0)
    [ line ("t u" , "E"      ) ("u"       , "E[t []]")
    ; line ("v"   , "E[t []]") ("t"       , "E[[] v]")
    ; line ("λx t", "E[[] v]") ("t[x ≔ v]", "E"      ) ]
)
\linesAfter(2)
\end{center}
The first rule is used to focus on the argument of an application, to compute
it first. When the argument has been evaluated to a value, the second rule
can be used to swap the argument with the unevaluated function. The
computation can then continue with the evaluation of the function, which
should (hopefully) evaluate to a $λ$-abstraction. If it is the case, the
third rule can be applied to actually perform the $β$-reduction.

The state of the abstract machine can be seen as a zipper \cite("Huet1997")
on the tree structure of a term. Indeed, the term that is in head position
is the subterm on which the machine is focusing. It is also worth noting
that the machine manipulates evaluation contexts from the inside out, which
results in a heavy syntax. However, it is possible to represent right-to-left
call-by-value evaluation contexts using a stack of functions (i.e. terms)
and argument (i.e. values). We will take this approach in the following.
\begin{def}
Values, terms, stacks and processes are generated by the following four
||bnf|| grammars. The names of the corresponding sets are displayed on
the left.
\Caml(
let _ = bnfs
  [ ( << $(Λ_{val})$ >>
    , << $v, w$ >>
    , << $\v("x") \| \v("λx t")$ >>
    , << $x∈\cal{V}_λ$ >> )
  ; ( << $(Λ)$ >>
    , << $t, u$ >>
    , << $\t("v") \| \t("t u")$ >>
    , [] )
  ; ( << $(Π)$ >>
    , << $π, ρ$ >>
    , << $\s("ε") \| \s("v.π") \| \s("[t]π")$ >>
    , [] )
  ; ( << $(Λ × Π)$ >>
    , << $p, q$ >>
    , << $\p("t ∗ π")$ >>
    , [] ) ]
)
\end{def}
The syntactic distinction between terms and values is specific to the
call-by-value presentation, they would be collapsed in call-by-name.
Intuitively, a stack can be thought of as an evaluation context represented
as a list of terms and values. The values are to be considered as arguments
to be fed to the term in the context, and the terms are to be considered as
functions to which the term in the context will be applied. The symbol $ε$
is used to denote an empty stack. A process $\p("t ∗ π")$ is to be considered
as the state of our abstract machine. Its reduction will consist in the
interaction between the term $t$ and its evaluation context encoded into a
stack $π$.

As we are considering a call-by-value calculus, only values are (and should
be) substituted to $λ$-variables during evaluation. From now on, we will
hence work with the following definition of substitution. In particular, a
substitution of the form $\lterm("t[x ≔ u]")$ will be forbidden if $u$ is not
a syntactic value.
\begin{def}
Let $t ∈ Λ$ be a term, $x ∈ \cal{V}_λ$ be a $λ$-variable and $v ∈ Λ_{val}$
be a value. We denote $\t("t[x ≔ v]")$ the capture-avoiding substitution
of $x$ by $v$ in $t$.
\end{def}
\begin{def}
The reduction relation $({≻}) ⊆ (Λ×Π) × (Λ×Π)$ is defined as the smallest
relation satisfying the following rules. We will denote $({≻}^{∗})$ its
reflexive and transitive closure.
\begin{center}
\linesBefore(4)
\diagram(
let _ =
  let line l r = [ <$\p(l)$> ; <$≻$>; <$\p(r)$> ] in
  array [`East ; `Main ; `West] ~horizontal_padding:(function _ -> 5.0)
    [ line "t u ∗ π"    "u ∗ [t]π"
    ; line "v ∗ [t] π"  "t ∗ v.π"
    ; line "λx t ∗ v.π" "t[x ≔ v] ∗ π" ]
)
\end{center}
\end{def}
Three reduction rules are used to handle call-by-value evaluation. When an
application is encountered, the function is stored in a stack-frame in order
to evaluate its argument first. Once the argument has been completely
computed, a value faces the stack-frame containing the function. At this
point the function can be evaluated and the value is stored in the stack,
ready to be consumed by the function as soon as it evaluates to a
$λ$-abstraction. A capture-avoiding substitution can then be performed to
effectively apply the argument to the function. As an example, the process
$\p("(λx x y) λz z ∗ ε")$ reduces to $\p("y ∗ ε")$ in the following way, and
cannot evaluate further.
\begin{center}
\linesBefore(7)
\diagram(
let _ =
  let line s = [ []; <$≻$>; <$\p(s)$> ] in
  array [`East ; `East ; `West]
  [ [ <$\p("(λx x y) λz z ∗ ε")$>; <$≻$>; <$\p("λz z ∗ [λx x y]ε")$> ]
  ; line "λx x y ∗ λz z . ε"
  ; line "(λz z) y ∗ ε"
  ; line "y ∗ [λz z] ε"
  ; line "λz z ∗ y . ε"
  ; line "y ∗ ε" ]
)
\end{center}

\begin{rem}
A left-to-right call-by-value machine could be defined in a similar way, but
the roles of terms and values would be swapped in stacks. Stack frames would
contain values, and terms would be pushed on the stack. The resulting
reduction relation would be the following.
\begin{center}
\diagram(
let _ =
  let line l r = [ <$\proc(l)$> ; <$≻_{RL}$>; <$\proc(r)$> ] in
  array [`East ; `Main ; `West] ~horizontal_padding:(function _ -> 5.0)
    [ line "t u ∗ π"     "t ∗ u.π"
    ; line "v ∗ u.π"     "u ∗ [v]π"
    ; line "v ∗ [λx t]π" "t[x ≔ v] ∗ π" ]
)
\end{center}
\end{rem}

The state of our abstract machine contains two parts: a term being evaluated
(i.e. the term in head position) and its evaluation context (i.e. the stack).
As a consequence, it is possible to define reduction rules that manipulate
the stack (i.e. the evaluation context) as a first class object. Such
reduction rules produce computational effects.

=<

=> Computational effects and \lmcalc

We are now going to extend the calculus and our abstract machine with
operations allowing the manipulation of the stack. More precisely, we
will provide a way to save the stack (i.e. the evaluation context or the
continuation), so that it can be restored at a later stage. A natural
way to extend our language is to use the syntax of Michel Parigot's
\lmcalc \cite("Parigot1992"). We hence introduce a new binder $\t("μα t")$
capturing the current stack in the $μ$-variable $α$. The stack can then be
restored in $t$ using the syntax $\t("[α]u")$.
\begin{def}
Let $\cal{V}_μ = \{α, β, γ...\}$ be a countable set of $μ$-variables (or
stack variables) disjoint from $\cal{V}_λ$. Value, terms, stacks and
processes are now generated by the following grammars. The names of the
corresponding sets are displayed on the left.
\pagesBefore(1) (* hack *)
\Caml(
let _ = bnfs
  [ ( << $(Λ_{val})$ >>
    , << $v, w$ >>
    , << $\v("x") \| \v("λx t")$ >>
    , << $x∈\cal{V}_λ$ >> )
  ; ( << $(Λ)$ >>
    , << $t, u$ >>
    , << $\t("v") \| \t("t u") \| \t("μα t") \| \t("[α]t")$ >>
    , [] )
  ; ( << $(Π)$ >>
    , << $π, ρ$ >>
    , << $\s("ε") \| \s("α") \| \s("v.π") \| \s("[t]π")$ >>
    , << $α∈\cal{V}_μ$ >> )
  ; ( << $(Λ × Π)$ >>
    , << $p, q$ >>
    , << $\p("t ∗ π")$ >>
    , [] ) ]
)
\end{def}
Note that terms of the form $\t("[π]t")$ will only be available to the user
if $π$ is a stack variable. Allowing arbitrary stacks allow us to substitute
$μ$-variables by stacks during computation. Like with $λ$-variable, we will
need to be careful and avoid variable capture. However, we will not give
the full details this time.
\begin{def}
Given a value, term, stack or process $ψ$, we denote $FV_λ(ψ)$ (resp.
$BV_λ(ψ)$) the set of its free (resp. bound) $λ$-variables and $FV_μ(ψ)$
(resp. $BV_μ(ψ)$) the set of its free (resp. bound) $μ$-variables. These
sets are defined in a similar way to \defRef("freelvars").
\end{def}
\begin{def}
Let $t ∈ Λ$ be a term, $π ∈ Π$ be a stack and $α ∈ \cal{V}_μ$ be a
$μ$-variable. We denote $\t("t[α ≔ π]")$ the (capture-avoiding) substitution
of $α$ by $π$ in $t$.
\end{def}
\begin{def}
The reduction relation $({≻})$ is extended with two new reduction rules.
\begin{center}
\linesBefore(7)
\diagram(
let _ =
  let line l r = [ <$\p(l)$> ; <$≻$>; <$\p(r)$> ] in
  array [`East ; `Main ; `West] ~horizontal_padding:(function _ -> 5.0)
    [ line "t u ∗ π"    "u ∗ [t]π"
    ; line "v ∗ [t] π"  "t ∗ v.π"
    ; line "λx t ∗ v.π" "t[x ≔ v] ∗ π"
    ; line "μα t ∗ π"   "t[α ≔ π] ∗ π"
    ; line "[ρ]t ∗ π"   "t ∗ ρ" ]
)
\end{center}
\end{def}
Now, when the abstract machine encounters a $μ$-abstraction $\t("μα t")$, the
current stack $π$ is substituted to the $μ$-variables $α$. As a consequence,
every subterm of the form $\t("[α]u")$ in $t$ becomes $\t("[π]u")$. When the
machine then reaches a state of the form $\p("[π]u ∗ ρ")$, the current stack
$ρ$ is erased, and computation resumes with the stored stack $π$. For
example, the process $\p("λx μα t [α]x ∗ v.ε")$ where $t$ is an arbitrary
term and $v$ is an arbitrary value reduces as follows.
\begin{center}
\linesBefore(5)
\diagram(
let _ =
  let line s = [ []; <$≻$>; <$\p(s)$> ] in
  array [`East ; `East ; `West]
  [ [ <$\p("λx μα t [α]x ∗ v.ε")$>; <$≻$>; <$\p("μα t[x ≔ v] [α]v ∗ ε")$> ]
  ; line "t[x ≔ v] [ε]v ∗ ε"
  ; line "[ε]v ∗ [t[x ≔ v]]ε"
  ; line "v ∗ ε" ]
)
\end{center}
Note that when a stack is erased, arbitrary terms might be erased. In
particular, we could have chose $t = Ω = \t("(λx x x) λx x x")$ in the
previous example, although the reduction of this term does not terminate.
Indeed, we have
\begin{center}
\linesBefore(4)
\diagram(
let _ =
  let line s = [ []; <$≻$>; <$\p(s)$> ] in
  array [`East ; `East ; `West]
  [ [ <$\p("Ω ∗ π")$>; <$≻$>; <$\p("λx x x ∗ [λx x x] π")$> ]
  ; line "λx x x ∗ λx x x . π"
  ; line "Ω ∗ π" ]
)
\end{center}
for every possible stack $π$.
(* TODO from here. *)

=<

=> Full syntax and operational semantics

The programming language that is considered in this thesis is expressed in
terms of a //Krivine Abstract Machine// \cite("Krivine2007"). It is formed
using four syntactic entities: values, terms, stacks and processes. The
distinction between terms and values is specific to our call-by-value
presentation, they would be collapsed in call-by-name.
\begin{def}
We require three distinct, countable sets of variables:
$\cal{V}_λ = \{x, y, z...\}$ for $λ$-variables,
$\cal{V}_μ = \{α, β, γ...\}$ for $μ$-variables and
$\cal{V}_ι = \{a, b, c...\}$ for term variables.
We also require a countable set $\cal{L} = \{l, l₁, l₂...\}$ of labels to
name record fields and a countable set $\cal{C} = \{C, C₁, C₂...\}$ for
naming constructors.
\end{def}
\begin{def}
Value, terms, stacks and processes are mutually inductively defined as the
languages recognised by the following grammars. The names of the
corresponding sets are displayed on the right.
\Caml(
let _ = bnfs
  [ ( << $(Λ_{val})$ >>
    , << $v, w$ >>
    , << $\v("x") \| \v("λx t")$ >>
    , << $x∈\cal{V}_λ$ >> )
  ; ( << $(Λ)$ >>
    , << $t, u$ >>
    , << $\t("a") \| \t("v") \| \t("t u") \| \t("μα t") \| \t("[α]t")$ >>
    , << $a∈\cal{V}_ι$ >> )
  ; ( << $(Π)$ >>
    , << $π, ρ$ >>
    , << $\s("ε") \| \s("α") \| \s("v.π") \| \s("[t]π")$ >>
    , << $α∈\cal{V}_μ$ >> )
  ; ( << $(Λ × Π)$ >>
    , << $p, q$ >>
    , << $\p("t ∗ π")$ >>
    , [] ) ]
)
\begin{center}
\linesBefore(6)
\diagram(
let _ = array [`East ; `East ; `West; `West]
  ~horizontal_padding:(function 3 -> 10.0 | _ -> 1.0)
  [ [ <$v,w$> ; <$::=$>
    ; <$ x \| {λx t} \| \{(l_i = v_i)_{i∈I}\} \| {C[v]} $>
    ; <$(Λ_{val})$> ]
  ; [ <$t,u$> ; <$::=$>
    ; <$a \| v \| {t u} \| {μα t} \| {[π]t} \| {v{.}l} \|
       {[v \| (C_i → t_i)_{i∈I}]} \| {Y_{t,v}} \| {{unit}_v} $>
    ; <$(Λ)$> ]
  ; [ <$π,ρ$> ; <$::=$>
    ; <$ ε \| α \| {v⋅π} \| {[t]π} $>
    ; <$(Π)$> ]
  ; [ <$p,s$> ; <$::=$>
    ; <$ t ∗ π $>
    ; <$(Λ × Π)$> ] ]
)
\end{center}
\end{def}
Terms and values form a variation of the \lmcalc \cite("Parigot1992"),
enriched with ML-like constructs (i.e. records and variants). One may note
that values are terms. A stack can be either the empty stack $ε$, a stack
variable, a value pushed on top of a stack, or a stack frame containing a
term on top of a stack. These two constructors are specific to the
call-by-value presentation, only one would be required in call-by-name.
\begin{rem}
We enforce values in constructors, record fields, projection and case
analysis. This makes the calculus simpler because only $β$-reduction will
manipulate the stack. We can define syntactic sugars such as the following
to hide the restriction from the programmer.
$$ t.l ≔ (λx x.l) t \hspace(2.0) C[t] ≔ (λx C[x]) t $$
\end{rem}
\begin{def}
Given a value, term, stack or process $ψ$ we denote $FV_λ(ψ)$ (resp.
$FV_μ(ψ)$, $TV(ψ)$) the set of free $λ$-variables (resp. free $μ$-variables,
term variables) contained in $ψ$. We say that $ψ$ is closed if it does not
contain any free variable of any kind. The set of closed values and the set
of closed terms are denoted $Λ_{val}^{∗}$ and $Λ^{∗}$ respectively.
\end{def}

Processes form the internal state of our abstract machine. They are to be
thought of as a term put in some evaluation context represented using a
stack. Intuitively, the stack $π$ in the process $t ∗ π$ contains the
arguments to be fed to $t$. Since we are in call-by-value the stack also
handles the storing of functions while their arguments are being evaluated.
This is why we need stack frames (i.e. stacks of the form $[t]π$). The
operational semantics of our language is given by a relation $({≻})$ over
processes.
\begin{def}
The relation $({≻}) ⊆ (Λ×Π)²$ is defined as the smallest relation
satisfying the following reduction rules.
\begin{center}
\diagram(
let _ = array [`East ; `Main ; `West]
  ~horizontal_padding:(function _ -> 5.0)
  [ [ <${t u} ∗ π$>
    ; <$≻$>; <$u ∗ {[t]π}$> ]
  ; [ <$v ∗ {[t] π}$>
    ; <$≻$>; <$t ∗ {v·π}$> ]
  ; [ <$λx t ∗ {v · π}$>
    ; <$≻$>; <${t[x ≔ v]} ∗ π$> ]
  ; [ <$μα t ∗ π$>
    ; <$≻$>; <${t[α ≔ π]} ∗ π$> ]
  ; [ <$[ρ]t ∗ π$>
    ; <$≻$>; <$t ∗ ρ$> ]
  ; [ <$\{(l_i = v_i)_{i∈I}\}.l_k ∗ π$>
    ; <$≻$>; <$v_k ∗ π \hspace(2.6) when \hspace(0.4) k∈I$> ]
  ; [ <$[C_k[v] \| (C_i → t_i)_{i∈I}] ∗ π$>
    ; <$≻$>; <$t_k v ∗ π \hspace(2.) when \hspace(0.4) k∈I$> ]
  ; [ <$Y_{t,v} ∗ π$>
    ; <$≻$>; <$t ∗ {{λx Y_{t,x}}·v·π}$> ]
  ; [ <${unit}_{\{\id([])\}} ∗ π$>
    ; <$≻$>; <$\{\id([])\} ∗ π$> ]
  ]
)
\end{center}
We will denote $({≻}^{+})$ its transitive closure, $({≻}^{∗})$ its
reflexive-transitive closure and $({≻}^k)$ its $k$-fold application.
\end{def}
The first three rules are those that handle $β$-reduction. When the abstract
machine encounters an application, the function is stored in a stack-frame in
order to evaluate its argument first. Once the argument has been completely
computed, a value faces the stack-frame containing the function. At this
point the function can be evaluated and the value is stored in the stack
ready to be consumed by the function as soon as it evaluates to a
$λ$-abstraction. A capture-avoiding substitution can then be performed to
effectively apply the argument to the function. The fourth and fifth rules
rules handle the classical part of computation. When a $μ$-abstraction is
reached, the current stack (i.e. the current evaluation context) is captured
and substituted for the corresponding $μ$-variable. Conversely, when a
process is reached, the current stack is thrown away and evaluation resumes
with the process. The last two rules perform projection and case analysis in
the expected way.

\begin{lem}\label{redcompatall}
The reduction relation $({≻})$ is compatible with substitutions of variables
of any kind. More formally, if $p$ and $q$ are processes such that $p ≻ q$
then:
\begin{itemize}
\item for all $x ∈ \cal{V}_λ$ and $v ∈ Λ_{val}$, $p[x ≔ v] ≻ q[x ≔ v]$,
\item for all $α ∈ \cal{V}_μ$ and $π ∈ Π$, $p[α ≔ π] ≻ q[α ≔ π]$,
\item for all $a ∈ \cal{V}_ι$ and $t ∈ Λ$, $p[a ≔ t] ≻ q[a ≔ t]$.
\end{itemize}
Consequently, if $σ$ is a substitution for variables of any kind and if
$p ≻ q$ (resp. $p ≻^{∗} q$, $p ≻^{+} q$, $p ≻^k q$) then $pσ ≻ qσ$ (resp.
$pσ ≻^{∗} qσ$, $pσ ≻^{+} qσ$, $pσ ≻^k qσ$).
\begin{proof}
Immediate case analysis on the reduction rules.
\end{proof}
\end{lem}

We are now going to give the vocabulary that will be used to describe some
specific classes of processes. In particular we need to identify processes
that are to be considered as the evidence of a successful computation, and
those that are to be recognised as expressing failure.
\begin{def}
A process $p ∈ Λ×Π$ is said to be:
\begin{itemize}
\item //final// if there is a value $v ∈ Λ_{val}$ such that $p = v ∗ α$,
\item //blocked// if there is no $q ∈ Λ×Π$ such that $p ≻ q$,
\item //stuck// if it is not final and if for every substitution $σ$, $pσ$
      is blocked,
\item //non-terminating// if there is no blocked process $q ∈ Λ×Π$ such that
      $p ≻^{∗} q$.
\end{itemize}
\end{def}

\begin{lem}\label("redstable")
Let $p$ be a process and $σ$ be a substitution for variables of any kind.
If $p$ is stuck (resp. non-terminating) then $pσ$ is also stuck (resp.
non-terminating).
\begin{proof}
Immediate by definition.
\end{proof}
\end{lem}

\begin{lem}\label("remark")
A stuck state is of one of the following forms, where $k ∉ I$.
$$
{C[v].l ∗ π}
\hspace(2.0)
{(λx t).l ∗ π}
\hspace(2.0)
{C[v] ∗ w · π}
\hspace(2.0)
{\{(l_i = v_i)_{i∈I}\} ∗ v · π}
$$

$$
{[λx t | (C_i → t_i)_{i∈I}] ∗ π}
\hspace(4.0)
{[\{(l_i = v_i)_{i∈I}\} | (C_j → t_j)_{i∈J}] ∗ π}
$$

$$
[C_k[v] | (C_j → t_j)_{i∈J}] ∗ π
\hspace(4.0)
\{(l_i = v_i)_{i∈I}\}.l_k ∗ π
$$
\begin{proof}
  Simple case analysis.
\end{proof}
\end{lem}

\begin{lem}\label("possibilities")
A blocked process $p ∈ Λ×Π$ is either stuck, final or of one of the following
forms.
$$
{x.l ∗ π}
\hspace(2.0)
{x ∗ v · π}
\hspace(2.0)
{[x | (C_i → t_i)_{i ∈ I}] ∗ π}
\hspace(2.0)
{a ∗ π}
$$
\begin{proof}
Straight-forward case analysis using lemma \lemRef("remark").
\end{proof}
\end{lem}

=<

=<
