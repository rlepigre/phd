\Caml(
  open ProofTree
  open Diagrams
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\mathsize{3.}{\wbox}$>
  let bbox = <$\mathsize{3.}{\bbox}$>
)
\Include{Macros}

\Caml(
let r11 =
  <<$\binaryRN{⇒_i}{Ξ ⊢ \t("λx t") ∈ \f("A ⇒ B") ⊂ C}
    {Ξ ⊢ \t("t[x ≔ εx∈A(t∉B)]") : \f("B")}{Ξ ⊢ \t("λx t") : C}$>>

let r12 =
  <<$\binaryRN{⇒_e}{Ξ ⊢ \t("t") : \f("A ⇒ B")}
    {Ξ ⊢ \t("u") : \f("A")}{Ξ ⊢ \t("t u") : \f("B")}$>>

let r21 =
  <<$\unaryRN{Ax}{Ξ ⊢ ε_{x∈A}(t∉B) ∈ A ⊂ C}{Ξ ⊢ ε_{x∈A}(t∉B) : C}$>>

let r22 =
  <<$\ternaryRN{⇒_{e,{∈}}}{Ξ ⊢ \t("t") : \f("u∈A ⇒ B")}
    {Ξ ⊢ \t("u") : \f("A")}{Ξ ⊢ ∃v, v ≡ u}{Ξ ⊢ \t("t u") : \f("B")}$>>

let r21' =
  <<$\unaryRN{μ}{Ξ ⊢ \t("t[α ≔ εα∈A(t∉A)]") : A}{Ξ ⊢ \t("μα t") : \f("A")}$>>

let r22' =
  <<$\binaryRN{[\wc]}{Ξ ⊢ u : A}{Ξ ⊢ π : ¬A}{Ξ ⊢ \t("[π]u") : \f("B")}$>>

let r23' =
  <<$\unaryRN{Ax^⊥}{Ξ ⊢ A ⊂ B}{Ξ ⊢ \s("εα∈A(t∉A)") : ¬B}$>>

let r2a =
  <<$\ternaryRN{\wc·\wc}{Ξ ⊢ v : A}{Ξ ⊢ π : ¬B}{Ξ ⊢ \f("A⇒B") ⊂ C}
    {Ξ ⊢ \s("v·π") : ¬C}$>>

let r2b =
  <<$\binaryRN{[\wc]\wc}{Ξ ⊢ t : \f("A⇒B")}{Ξ ⊢ π : ¬B}
    {Ξ ⊢ \s("[t]π") : ¬A}$>>

let r31 =
  <<$\binaryRN{+_e}{Ξ ⊢ \t("v") : \f("[(Ci : Ai) i∈I]")}
    {(Ξ, \t("v") ≡ \t("Ci[εxi∈Ai(ti∉C)]") ⊢
      \t("ti[xi ≔ εxi∈Ai(ti∉C)]") : \f("C"))_{i∈I}}
    {Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : \f("C")}$>>

let r32 =
  <<$\unaryRN{×_e}{Ξ ⊢ \t("v") : \f("{l : A}")} {Ξ ⊢ \t("v.l") : A}$>>

let r33 =
  <<$\axiomRN{Ax_{⊂}}{Ξ ⊢ \t("t") : A ⊂ A}$>>

let r41 =
  <<$\binaryRN{+_i}{Ξ ⊢ \t("v") : \f("A")}
    {Ξ ⊢ \t("C[v]") ∈ \f("[C : A]") ⊂ \f("B")}{Ξ ⊢ \t("C[v]") : B}$>>

let r42 =
  <<$\binaryRN{×_i}{Ξ ⊢ \t("{(li = vi) i∈I}") ∈ \f("{(li : Ai) i∈I}") ⊂ C}
    {(Ξ ⊢ \t("vi") : \f("Ai"))_{i∈I}}{Ξ ⊢ \t("{(li = vi) i∈I}") : C}$>>

let r51 =
  <<$\binaryRN{⇒}{Ξ ⊢ \t("εx∈A₂(t x ∉ B₂)") ∈ \f("A₂") ⊂ \f("A₁")}
    {Ξ ⊢ \t("t εx∈A₂(t x ∉ B₂)") ∈ \f("B₁") ⊂ \f("B₂")}
    {Ξ ⊢ \t("t") ∈ \f("A₁ ⇒ B₁") ⊂ \f("A₂ ⇒ B₂")}$>>

let r61 =
  <<$\binaryRN{+}{I₁ ⊂ I₂}
    {(Ξ ⊢ \t("(λx [x | Ci[xi] → xi]) t") ∈ \f("Ai") ⊂ \f("Bi"))_{i∈I₁}}
    {Ξ ⊢ \t("t") ∈ \f("[(Ci : Ai) i∈I₁]") ⊂ \f("[(Ci : Bi) i∈I₂]")}$>>

let r62 =
  <<$\binaryRN{×}{I₂ ⊂ I₁}
    {(Ξ ⊢ \t("(λx x.li) t") ∈ \f("Ai") ⊂ \f("Bi"))_{i∈I₂}}
    {Ξ ⊢ \t("t") ∈ \f("{(li : Ai) i∈I₁}") ⊂ \f("{(li : Bi) i∈I₂}")}$>>

let r71 =
  <<$\unaryRN{∀_l}
    {Ξ ⊢ \t("t") ∈ \f("A[χ≔C]") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("∀χ^s A") ⊂ \f("B")}$>>

let r72 =
  <<$\binaryRN{∀_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B[χ ≔ εχ∈s(t∉B)]")}
    {Ξ ⊢ ∃v, v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("∀χ^s B")}$>>

let r81 =
  <<$\unaryRN{∃_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B[χ≔C]")}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("∃χ^s B")}$>>

let r82 =
  <<$\binaryRN{∃_l}
    {Ξ ⊢ \t("t") ∈ \f("A[χ ≔ εχ∈s(t∈A)]") ⊂ \f("B")}
    {Ξ ⊢ ∃v, v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("∃χ^s A") ⊂ \f("B")}$>>

let r91 =
  <<$\unaryRN{\restriction_l}
    {Ξ, u₁ ≡ u₂ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("A ∧ u₁ ≡ u₂") ⊂ \f("B")}$>>

let r92 =
  <<$\binaryRN{\restriction_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ u₁ ≡ u₂}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B ∧ u₁ ≡ u₂")}$>>

let rA1 =
  <<$\unaryRN{∈_l}
    {Ξ, t ≡ u ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("u ∈ A") ⊂ \f("B")}$>>

let rA2 =
  <<$\ternaryRN{∈_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ t ≡ u}
    {Ξ ⊢ ∃v, v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("u ∈ B")}$>>

let rs env =
  let env = resize_env 3.2 env in
  let rs =
    [ [ r11 ; r12 ]
    ; [ r21 ; r22 ]
    ; [ r21'; r22'; r23']
    ; [ r2a ; r2b ]
    ; [ r32 ; r42 ]
    ; [ r31 ]
    ; [ r41 ; r33 ]
    ; [ r51 ]
    ; [ r61 ; r62 ]
    (* quantifiers. *)
    ; [ r71 ; r72 ]
    ; [ r81 ; r82 ]
    (* restriction and membership. *)
    ; [ r91 ; r92 ]
    ; [ rA1 ; rA2 ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let subrules () =
  figure_here ~name:"subrules"
    ~caption:[tT "Typing and subtyping rules."] (dr rs)
)

=> Introducing subtyping into the system \label("subtyping")

In this chapter, we reformulate the definition of our system to account for
subtyping. The main idea is to transform the typing rules that do not have
algorithmic contents into subtyping rules. For instance, quantifiers,
fixpoints, membership types and equality types will be handled using
subtyping.

=> Interests of subtyping

There is no denying that polymorphism and type abstraction are essential
features for programming in a generic way. They lead to programs that are
shorter, more modular, easier to understand and hence more reliable.
Although subtyping also provides similar perspectives, it is considerably
less widespread among programming languages. Practical languages only rely
on limited forms of subtyping for their module system \cite("MacQueen1984"),
or for the use of polymorphic variants \cite("Garrigue1998"). Overall,
subtyping is useful for both product types (e.g. records or modules) and
sum types (e.g. polymorphic variants). It provides canonical injections
between a type and its subtypes. For example, unary natural numbers may
be defined as a subtype of unary integers.

The downside of subtyping is that it is difficult to incorporate in
complex systems like //Haskell// or ||OCaml||. For example, ||OCaml||
provides polymorphic variants \cite("Garrigue1998") for which complex
annotated types are inferred. For instance, one would expect the
following ||OCaml|| function to be given the type ##[`T | `F] -> [`T | `F]##.
### OCaml
  let neg = function
    | `T -> `F
    | `F -> `T
###
Indeed, the variance of the arrow type conveys enough information: ##neg##
can be applied to elements of any subtype of ##[`T | `F]## (e.g. ##[`T]##)
and produces elements of any supertype of ##[`T | `F]## (e.g.
##[`T | `F | `M]##). ||OCaml|| infers the type ##[<`T | `F] -> [>`T | `F]##
in which subtypes and supertypes are explicitly tagged. This is not very
natural and hides a complex mechanism involving polymorphic type variables.
More discussion on the limitations of ||OCaml||'s polymorphic variants, can
be found in \cite("Castagna2016"), for example.

In this thesis, we will show that it is possible to design a practical
type system based on subtyping for our language. It allows for a rather
straight-forward implementation using standard unification techniques
following the typing and subtyping rules that will be given in the
following sections. In particular, the typing and subtyping procedures
never have to backtrack since they are directed by the syntax of terms
and types respectively. The ideas presented here were introduced in a
joint work of Christophe Raffalli and the author \cite("Lepigre2017").

=<

=> Symbolic witnesses and local subtyping

Several related technical innovations are required to include subtyping
into our system. In particular, we will need to generalise the usual
subtyping relation $A ⊂ B$ (meaning "$A$ is a subtype of $B$") using a
//local subtyping// relation $t ∈ A ⊂ B$. It will be interpreted as
"if $t$ has type $A$ then it also has type $B$". Usual subtyping is then
recovered using choice operators inspired from //Hilbert's Epsilon and
Tau functions// \cite("Hilbert1968"). In our system, the choice operator
$\v("εx∈A(t∉B)")$ denotes a value $v$ of type $A$ such that $\t("t[x≔v]")$
does not have type $B$. If no such term exists, then an arbitrary term
of type $A$ can be chosen. We can then take $\v("εx∈A(x∉B)") ∈ A ⊂ B$ as
a definition of $A ⊂ B$.
\begin{rem}
Of course, for the choice operator $\v("εx∈A(t∉B)")$ to be well-defined
we will need the interpretation of every type to non-empty. It is the
case in \cite("Lepigre2017") as the model is based on Girard's
reducibility candidates \mcite(["Girard1972"; "Girard1989"]).
\end{rem}

Choice operators can be used to replace the notion of free variables,
and hence suppress the need for typing contexts. Intuitively,
$\v("εx∈A(t∉B)")$ denotes a counterexample to the fact that $\t("λx t")$
has type $\f("A⇒B")$. Consequently, we will use the rule of the form
\begin{center}
$ \unaryR{Ξ ⊢ \t("t[x≔εx∈A(t∉B)]") : B}
    {Ξ ⊢ \t("λxt") : \f("A⇒B")} $
\end{center}
for typing $λ$-abstractions. It can be read as a proof by contradiction
as its premise is only valid when there is no value $v$ of type $A$ such
that $\t("t[x≔v]")$ does not have type $B$. The axiom rule is then
replaced by the following typing rule for choice operators.
\begin{center}
$ \axiomR{Ξ ⊢ \t("εx∈A(t∉B)") : A} $
\end{center}
Obviously, the same trick can be used for $μ$-variables and
$μ$-abstractions. As for choice operators for values, choice
operators for stack will need to always be well-defined. As
a consequence, we will need to make sure that the set of stacks
associated to each type contain at least one element.

The use of choice operators and the elimination of typing contexts
will plays an essential role in the definition of our type system
with subtyping. Indeed, they will allow us to handle quantifiers
using our local subtyping relation only. This will allow us to work
with syntax-directed typing rules only, and most of the work will
be done using subtyping.

Choice operators will also be used for the handling of quantifiers.
We will thus introduce two new type constructors $\f("εX(t∈A)")$ and
$\f("εX(t∉A)")$ corresponding to choice operators for picking a type
satisfying the denoted properties. For example, $\f("εX(t∉B)")$ is a
type such that the term $t$ does not have type $\f("B[X≔εX(t∉B)]")$.
Intuitively, $\f("εX(t∉B)")$ is a counter-example to the judgment
"$t$ has type $\f("∀X B")$". Hence, to show that $t$ has type
$\f("∀X B")$, it will be enough to show that it has type
$\f("B[X≔εX(t∉B)]")$. As a consequence, the usual typing rule for
universal quantifier introduction is subsumed by the following local
subtyping rule.
\begin{center}
$ \binaryR{Ξ ⊢ t ∈ A ⊂ \f("B[X≔εX(t∉B)]")}{Ξ ⊢ t ≡ v}
          {Ξ ⊢ t ∈ A ⊂ \f("∀X B")} $
\end{center}
Note that the rule include a premise stating the term $t$ carried by
the judgments should be equivalent to a value. This corresponds to
the semantical value restriction condition in our new system with
subtyping.

In conjunction with local subtyping, choice operators allow the
derivation of many valid permutations of quantifiers and connectors.
For instance, Mitchell's containment axiom \cite("Mitchell1991")
$$ \f("∀X (A ⇒ B)") ⊂ \f("(∀X A) ⇒ (∀X B)")$$
can be easily derived. Consequently, our type system mostly
contains typing and subtyping rules that are syntax-directed.
In particular, we do not have a transitivity rule for subtyping.
It is not a problem since such a rule cannot be implemented.
Indeed, it would require the system to guess an intermediate
type. Transitivity is generally admissible in subtyping systems.
In our system however, it is an open problem whether a form of
transitivity is admissible.

=<
=> Typing and subtyping rules

We will now give the formal definition of our new type system
with subtyping. We will reuse some of the formalism given in
\chapter("typeSystem"), but modifications will be required. For
instance, we will need to extend the language of values, stacks
and formulas to include choice operators.
\begin{def}
We will extend the language of formulas $\cal{F}$ with two new
constructors $\f("εχ∈s(t∈A)")$ and $\f("εχ∈s(t∉A)")$ representing
choice operators. They will be made available in the syntax, and
will provide an alternative presentation of quantifiers. Note that
our system needs to be extended with the following two sorting
rules.
$$
  \binaryR{Σ ⊢ t : τ}{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
  \hspace(4.0)
  \binaryR{Σ ⊢ t : τ}{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("εχ∈s(t∉A)") : ο}
$$
\end{def}

To introduce value and stack witnesses into our system, we will
need to make a distinction between values, terms, stacks and
formulas that may contain value and stack witnesses and those
that may not.
\begin{def}
We extend the syntax of values with a new constructor
$\v("εx∈A(t∉B)")$, where $x∈\cal{V}_ι$ is a $λ$-variables,
$t∈Λ$ is a term and $A$, $B∈\cal{F}$ are propositions.
Similarly, the syntax of stacks is extended with a new
constructor $\s("εα∈A(t∉A)")$, where $α∈\cal{V}_σ$ is a
$μ$-variable, $t∈Λ$ is a term and $A∈\cal{F}$ is a
proposition. Note that our system needs to be extended
with the following two sorting rules.
$$
  \ternaryR{Σ ⊢ A : ο}{Σ, x : ι ⊢ t : τ}{Σ ⊢ B : ο}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
  \hspace(4.0)
  \binaryR{Σ ⊢ A : ο}{Σ, α : σ ⊢ t : τ}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
$$
\end{def}
Note that our extension of the syntax of values and the syntax
of stacks propagates to the terms and formulas in general.
\begin{def}
We will refer to values, terms and stacks that may contain value
and stack witnesses as //raw// values, //raw// terms and //raw//
stacks. The corresponding sets will be denoted $Λ^{+}_ι$, $Λ^{+}$
and $Π^{+}$ respectively.
\end{def}

Before giving the new typing and subtyping rules of our system,
we need to consider two (and in fact three) new forms of
judgments.
\begin{def}
A //general typing judgment// is a triple of an equational context
$Ξ$, a raw term $t∈Λ^+$ and a formula $A ∈ \cal{F}$ that is denoted
$Ξ ⊢ t : A$. A //pointed subtyping judgment// is a quadruple of an
equational context $Ξ$, a raw term $t∈Λ^{+}$ and two formulas
$A$, $B ∈ \cal{F}$ that is denoted $Ξ ⊢ t ∈ A ⊂ B$. We will use the
notation $Ξ ⊢ A ⊂ B$ when the term $t$ is of the form
$\v("εx∈A(x∉B)")$.
\end{def}
\begin{def}
A general typing judgment or a pointed subtyping judgment is said to
be correct if it is derivable using the deduction rules of
\figRef("subrules").
\end{def}

With the implementation in mind, it is important for our general typing
rules to be directed by the syntax. This means that we should be able
to select which rule to apply by looking at the surface constructor of
the term we want to type-check. The general typing rules given in
\figRef("subrules") can all be implemented as a syntax-directed procedure,
with the exception of the ($⇒_e$) and ($⇒_{e,{∈}}$) rules (which form
a critical pair). However, this is not really a problem since we can
choose to apply the ($⇒_{e,{∈}}$) rule whenever possible, and fallback
to the ($⇒_e$) rule. It is always safe to do so thanks to the following
lemma.
\Caml(let _ = subrules ()) (* NOTE can be moved *)

\begin{lem}
If a typing judgment $Ξ ⊢ \t("t u") : \f("B")$ has a typing proof starting
with the ($⇒_e$) rule, and if the judgment $Ξ ⊢ ∃v, v≡u$ is provable, then
$Ξ ⊢ \t("t u") : \f("B")$ also has a typing proof starting with the
($⇒_{e,{∈}}$) rule.
\begin{proof}
Blah bla bla.
\end{proof}
\end{lem}

=<
=> Semantics of subtyping

We will now adapt our model to work with our new typing and subtyping
rules. The main problem that we need to solve is the interpretation of
raw terms, values and stacks. In particular, we need a way to interpret
our choice operators for values and for stacks. In \cite("Lepigre2017"),
choice operators for values are interpreted using neutral terms (i.e.
members of the smallest candidate). Here we cannot use the same trick
as there is no guarantee for the interpretation of a type to contain
a value. We will thus introduce a special symbol $\daimon$ that will be
used to denote an undefined witness in terms, values and stacks.

\begin{def}
We extend the syntax of values and the syntax of stacks with the symbol
$\daimon$ denoting an "undefined" object. Given a value, term, starck or
process $ψ$, we will write $\daimon ∈ ψ$ if $ψ$ contains $\daimon$, and
$\daimon ∉ ψ$ otherwise.
\end{def}
\begin{lem}
Let $p ∈ Λ×Π$ be a process such that $\daimon ∉ p$. If there is $q ∈ Λ×Π$
such that $p ↠ q$ then $\daimon ∉ q$.
\begin{proof}
Most of the reduction rules of $({↠})$ only build a new process by moving
around pieces of syntax appearing in $p$. As a consequence, every such
rule cannot make $\daimon$ appear. All the remaining rules are related to
binders, and obviously if $t$, $v$ and $π$ do not contain $\daimon$, then
neither $\f("t[x≔v]")$ nor $\f("t[α≔π]")$ do.
\end{proof}
\end{lem}

In the semantics, raw values, raw terms and raw stacks will be interpreted
using values, terms and stacks with the same structure. The underlying
choice operators will thus be replaced by elements of the corresponding
syntactic category.
\begin{def}
Given a raw value $v ∈ Λ_ι^{+}$ (resp. raw term $t ∈ Λ^{+}$, raw stack
$π ∈ Π^+$), we denote $⟦v⟧ ∈ Λ_ι$ (resp. $⟦t⟧ ∈ Λ$, $⟦π⟧ ∈ Π$) its
semantical interpretation. It is defined inductively as follows.
\begin{center}
\linesBefore(4)
\diagram(
let contents =
  let line syn s1 s2 = [<$ \syn(s1) $> ; <$ = $> ; <$ \syn(s2) $>] in
  let spec syn s  n = [<$ \syn(s) $> ; <$ = $> ; n] in
  [ line v "⟦x⟧"                  "x"
  ; line v "⟦λx t⟧"               "λx ⟦t⟧"
  ; line v "⟦C[v]⟧"               "C[⟦v⟧]"
  ; line v "⟦{(li=vi)i∈I}⟧"       "{(li=⟦vi⟧)i∈I}"
  ; spec v "⟦εx∈A(t∉B)⟧"          <$ v∈⟦A⟧ \st \t("t[x≔v]")∉⟦B⟧^{⊥⊥} $>
  ; spec v "⟦εx∈A(t∉B)⟧"          <$ ⊥ \hspace(0.4) otherwise $>
  ; line t "⟦a⟧"                  "a"
  ; line t "⟦t u⟧"                "⟦t⟧ ⟦u⟧"
  ; line t "⟦μα t⟧"               "μα ⟦t⟧"
  ; line t "⟦[π]t⟧"               "[⟦π⟧] ⟦t⟧"
  ; line t "⟦v.lk⟧"               "⟦v⟧.lk"
  ; line t "⟦[v|(Ci[xi]→ti)i∈I]⟧" "[⟦v⟧|(Ci[xi]→⟦ti⟧)i∈I]"
  ; line t "⟦Y(t,v)⟧"             "Y(⟦t⟧,⟦v⟧)"
  ; line t "⟦U(v)⟧"               "U(⟦v⟧)"
  ; line t "⟦δ(v,w)⟧"             "δ(⟦v⟧,⟦w⟧)"
  ; line s "⟦ε⟧"                  "ε"
  ; line s "⟦α⟧"                  "α"
  ; line s "⟦v·π⟧"                "⟦v⟧·⟦π⟧"
  ; line s "⟦[t]π⟧"               "[⟦t⟧]⟦π⟧"
  ; spec s "⟦εα∈A(t∉A)⟧"          <$ π∈⟦A⟧^⊥ \st \t("t[α≔π]")∉⟦B⟧^{⊥⊥} $>
  ; spec s "⟦εα∈A(t∉A)⟧"          <$ ⊥ \hspace(0.4) otherwise $> ]
let _ = array [`East; `Main; `West] contents
          ~horizontal_padding:(fun n -> 1.0)
)
\end{center}

\end{def}

\begin{thm}
Let $Ξ$ be an equational context, $A$, $B ∈ \cal{F}$ be closed types and
$t ∈ Λ^{+}$ be a raw term. If $ρ_{id} ⊩ Ξ$ then we have:
\begin{itemize}
\item if $Ξ ⊢ t : A$ is valid then we have $⟦t⟧ ∈ ⟦A⟧^{\bot\bot}$,
\item if $Ξ ⊢ t ∈ A ⊆ B$ is valid and if $⟦t⟧ ∈ ⟦A⟧^{\bot\bot}$ then
      $⟦t⟧ ∈ ⟦B⟧^{\bot\bot}$.
\end{itemize}
\begin{proof}
We do a proof by induction on the structure of the proof of $Ξ ⊢ t : A$ and
$Ξ ⊢ t ∈ A ⊆ B$ respectively. We consider the last rules used in the proof.
\begin{itemize}
\item In the case of ...
\end{itemize}
\end{proof}
\end{thm}

=<

=<
