\Caml(
  open ProofTree
  open Diagrams
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\mathsize{3.}{\wbox}$>
  let bbox = <$\mathsize{3.}{\bbox}$>
)
\Include{Macros}

\Caml(
let r11 =
  <<$\binaryRN{⇒_i}{Ξ ⊢ \t("λx t") ∈ \f("A ⇒ B") ⊂ C}
    {Ξ ⊢ \t("t[x ≔ εx∈A(t∉B)]") : \f("B")}{Ξ ⊢ \t("λx t") : C}$>>

let r12 =
  <<$\binaryRN{⇒_e}{Ξ ⊢ \t("t") : \f("A ⇒ B")}
    {Ξ ⊢ \t("u") : \f("A")}{Ξ ⊢ \t("t u") : \f("B")}$>>

let r21 =
  <<$\unaryRN{Ax}{Ξ ⊢ ε_{x∈A}(t∉B) ∈ A ⊂ C}{Ξ ⊢ ε_{x∈A}(t∉B) : C}$>>

let r22 =
  <<$\ternaryRN{⇒_{e,{∈}}}{Ξ ⊢ \t("t") : \f("u∈A ⇒ B")}
    {Ξ ⊢ \t("u") : \f("A")}{Ξ ⊢ ∃v, v ≡ u}{Ξ ⊢ \t("t u") : \f("B")}$>>

let r21' =
  <<$\unaryRN{μ}{Ξ ⊢ \t("t[α ≔ εα∈A(t∉A)]") : A}{Ξ ⊢ \t("μα t") : \f("A")}$>>

let r22' =
  <<$\binaryRN{[\wc]}{Ξ ⊢ u : A}{Ξ ⊢ π : ¬A}{Ξ ⊢ \t("[π]u") : \f("B")}$>>

let r23' =
  <<$\unaryRN{Ax^⊥}{Ξ ⊢ A ⊂ B}{Ξ ⊢ \s("εα∈A(t∉A)") : ¬B}$>>

let r2a =
  <<$\ternaryRN{\wc·\wc}{Ξ ⊢ v : A}{Ξ ⊢ π : ¬B}{Ξ ⊢ \f("A⇒B") ⊂ C}
    {Ξ ⊢ \s("v·π") : ¬C}$>>

let r2b =
  <<$\binaryRN{[\wc]\wc}{Ξ ⊢ t : \f("A⇒B")}{Ξ ⊢ π : ¬B}
    {Ξ ⊢ \s("[t]π") : ¬A}$>>

let r31 =
  <<$\binaryRN{+_e}{Ξ ⊢ \t("v") : \f("[(Ci : Ai) i∈I]")}
    {(Ξ, \t("v") ≡ \t("Ci[εxi∈Ai(ti∉C)]") ⊢
      \t("ti[xi ≔ εxi∈Ai(ti∉C)]") : \f("C"))_{i∈I}}
    {Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : \f("C")}$>>

let r32 =
  <<$\unaryRN{×_e}{Ξ ⊢ \t("v") : \f("{l : A}")} {Ξ ⊢ \t("v.l") : A}$>>

let r33 =
  <<$\axiomRN{Ax_{⊂}}{Ξ ⊢ \t("t") : A ⊂ A}$>>

let r41 =
  <<$\binaryRN{+_i}{Ξ ⊢ \t("v") : \f("A")}
    {Ξ ⊢ \t("C[v]") ∈ \f("[C : A]") ⊂ \f("B")}{Ξ ⊢ \t("C[v]") : B}$>>

let r42 =
  <<$\binaryRN{×_i}{Ξ ⊢ \t("{(li = vi) i∈I}") ∈ \f("{(li : Ai) i∈I}") ⊂ C}
    {(Ξ ⊢ \t("vi") : \f("Ai"))_{i∈I}}{Ξ ⊢ \t("{(li = vi) i∈I}") : C}$>>

let r51 =
  <<$\binaryRN{⇒}{Ξ ⊢ \t("εx∈A₂(t x ∉ B₂)") ∈ \f("A₂") ⊂ \f("A₁")}
    {Ξ ⊢ \t("t εx∈A₂(t x ∉ B₂)") ∈ \f("B₁") ⊂ \f("B₂")}
    {Ξ ⊢ \t("t") ∈ \f("A₁ ⇒ B₁") ⊂ \f("A₂ ⇒ B₂")}$>>

let r61 =
  <<$\binaryRN{+}{I₁ ⊂ I₂}
    {(Ξ ⊢ \t("(λx [x | Ci[xi] → xi]) t") ∈ \f("Ai") ⊂ \f("Bi"))_{i∈I₁}}
    {Ξ ⊢ \t("t") ∈ \f("[(Ci : Ai) i∈I₁]") ⊂ \f("[(Ci : Bi) i∈I₂]")}$>>

let r62 =
  <<$\binaryRN{×}{I₂ ⊂ I₁}
    {(Ξ ⊢ \t("(λx x.li) t") ∈ \f("Ai") ⊂ \f("Bi"))_{i∈I₂}}
    {Ξ ⊢ \t("t") ∈ \f("{(li : Ai) i∈I₁}") ⊂ \f("{(li : Bi) i∈I₂}")}$>>

let r71 =
  <<$\unaryRN{∀_l}
    {Ξ ⊢ \t("t") ∈ \f("A[χ≔C]") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("∀χ^s A") ⊂ \f("B")}$>>

let r72 =
  <<$\binaryRN{∀_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B[χ ≔ εχ∈s(t∉B)]")}
    {Ξ ⊢ ∃v, v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("∀χ^s B")}$>>

let r81 =
  <<$\unaryRN{∃_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B[χ≔C]")}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("∃χ^s B")}$>>

let r82 =
  <<$\binaryRN{∃_l}
    {Ξ ⊢ \t("t") ∈ \f("A[χ ≔ εχ∈s(t∈A)]") ⊂ \f("B")}
    {Ξ ⊢ ∃v, v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("∃χ^s A") ⊂ \f("B")}$>>

let r91 =
  <<$\unaryRN{\restriction_l}
    {Ξ, u₁ ≡ u₂ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("A ∧ u₁ ≡ u₂") ⊂ \f("B")}$>>

let r92 =
  <<$\binaryRN{\restriction_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ u₁ ≡ u₂}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B ∧ u₁ ≡ u₂")}$>>

let rA1 =
  <<$\unaryRN{∈_l}
    {Ξ, t ≡ u ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("u ∈ A") ⊂ \f("B")}$>>

let rA2 =
  <<$\ternaryRN{∈_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ t ≡ u}
    {Ξ ⊢ ∃v, v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("u ∈ B")}$>>

let rs env =
  let env = resize_env 3.2 env in
  let rs =
    [ [ r11 ; r12 ]
    ; [ r21 ; r22 ]
    ; [ r21'; r22'; r23']
    ; [ r2a ; r2b ]
    ; [ r32 ; r42 ]
    ; [ r31 ]
    ; [ r41 ; r33 ]
    ; [ r51 ]
    ; [ r61 ; r62 ]
    (* quantifiers. *)
    ; [ r71 ; r72 ]
    ; [ r81 ; r82 ]
    (* restriction and membership. *)
    ; [ r91 ; r92 ]
    ; [ rA1 ; rA2 ] ]
  in List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let subrules () =
  figure_here ~name:"subrules"
    ~caption:[tT "Typing and subtyping rules."] (dr rs)
)

=> Introducing subtyping into the system \label("subtyping")

In this chapter, we reformulate the definition of our system to account for
subtyping. The main idea is to transform the typing rules that do not have
algorithmic contents into subtyping rules. For instance, quantifiers,
fixpoints, membership types and equality types will be handled using
subtyping.

=> Interests of subtyping

There is no denying that polymorphism and type abstraction are essential
features for programming in a generic way. They lead to programs that are
shorter, more modular, easier to understand and hence more reliable.
Although subtyping also provides similar perspectives, it is considerably
less widespread among programming languages. Practical languages only rely
on limited forms of subtyping for their module system \cite("MacQueen1984"),
or for the use of polymorphic variants \cite("Garrigue1998"). Overall,
subtyping is useful for both product types (e.g. records or modules) and
sum types (e.g. polymorphic variants). It provides canonical injections
between a type and its subtypes. For example, unary natural numbers may
be defined as a subtype of unary integers.

The downside of subtyping is that it is difficult to incorporate in
complex systems like //Haskell// or ||OCaml||. For example, ||OCaml||
provides polymorphic variants \cite("Garrigue1998") for which complex
annotated types are inferred. For instance, one would expect the
following ||OCaml|| function to be given the type ##[`T | `F] -> [`T | `F]##.
### OCaml
  let neg = function
    | `T -> `F
    | `F -> `T
###
Indeed, the variance of the arrow type conveys enough information: ##neg##
can be applied to elements of any subtype of ##[`T | `F]## (e.g. ##[`T]##)
and produces elements of any supertype of ##[`T | `F]## (e.g.
##[`T | `F | `M]##). ||OCaml|| infers the type ##[<`T | `F] -> [>`T | `F]##
in which subtypes and supertypes are explicitly tagged. This is not very
natural and hides a complex mechanism involving polymorphic type variables.
More discussion on the limitations of ||OCaml||'s polymorphic variants, can
be found in \cite("Castagna2016"), for example.

In this thesis, we will show that it is possible to design a practical
type system based on subtyping for our language. It allows for a rather
straight-forward implementation using standard unification techniques
following the typing and subtyping rules that will be given in the
following sections. In particular, the typing and subtyping procedures
never have to backtrack since they are directed by the syntax of terms
and types respectively. The ideas presented here were introduced in a
joint work of Christophe Raffalli and the author \cite("Lepigre2017").

=<

=> Symbolic witnesses and local subtyping

Several related technical innovations are required to include subtyping
into our system. In particular, we will need to generalise the usual
subtyping relation $A ⊂ B$ (meaning "$A$ is a subtype of $B$") using a
//local subtyping// relation $t ∈ A ⊂ B$. It will be interpreted as
"if $t$ has type $A$ then it also has type $B$". Usual subtyping is then
recovered using choice operators inspired from //Hilbert's Epsilon and
Tau functions// \cite("Hilbert1968"). In our system, the choice operator
$\v("εx∈A(t∉B)")$ denotes a value $v$ of type $A$ such that $\t("t[x≔v]")$
does not have type $B$. If no such term exists, then an arbitrary term
of type $A$ can be chosen. We can then take $\v("εx∈A(x∉B)") ∈ A ⊂ B$ as
a definition of $A ⊂ B$.
\begin{rem}
Of course, for the choice operator $\v("εx∈A(t∉B)")$ to be well-defined
we will need the interpretation of every type to non-empty. It is the
case in \cite("Lepigre2017") as the model is based on Girard's
reducibility candidates \mcite(["Girard1972"; "Girard1989"]).
\end{rem}

Choice operators can be used to replace the notion of free variables,
and hence suppress the need for typing contexts. Intuitively,
$\v("εx∈A(t∉B)")$ denotes a counterexample to the fact that $\t("λx t")$
has type $\f("A⇒B")$. Consequently, we will use the rule of the form
\begin{center}
$ \unaryR{Ξ ⊢ \t("t[x≔εx∈A(t∉B)]") : B}
    {Ξ ⊢ \t("λxt") : \f("A⇒B")} $
\end{center}
for typing $λ$-abstractions. It can be read as a proof by contradiction
as its premise is only valid when there is no value $v$ of type $A$ such
that $\t("t[x≔v]")$ does not have type $B$. The axiom rule is then
replaced by the following typing rule for choice operators.
\begin{center}
$ \axiomR{Ξ ⊢ \t("εx∈A(t∉B)") : A} $
\end{center}
Obviously, the same trick can be used for $μ$-variables and
$μ$-abstractions. As for choice operators for values, choice
operators for stack will need to always be well-defined. As
a consequence, we will need to make sure that the set of stacks
associated to each type contain at least one element.

The use of choice operators and the elimination of typing contexts
will plays an essential role in the definition of our type system
with subtyping. Indeed, they will allow us to handle quantifiers
using our local subtyping relation only. This will allow us to work
with syntax-directed typing rules only, and most of the work will
be done using subtyping.

Choice operators will also be used for the handling of quantifiers.
We will thus introduce two new type constructors $\f("εX(t∈A)")$ and
$\f("εX(t∉A)")$ corresponding to choice operators for picking a type
satisfying the denoted properties. For example, $\f("εX(t∉B)")$ is a
type such that the term $t$ does not have type $\f("B[X≔εX(t∉B)]")$.
Intuitively, $\f("εX(t∉B)")$ is a counter-example to the judgment
"$t$ has type $\f("∀X B")$". Hence, to show that $t$ has type
$\f("∀X B")$, it will be enough to show that it has type
$\f("B[X≔εX(t∉B)]")$. As a consequence, the usual typing rule for
universal quantifier introduction is subsumed by the following local
subtyping rule.
\begin{center}
$ \binaryR{Ξ ⊢ t ∈ A ⊂ \f("B[X≔εX(t∉B)]")}{Ξ ⊢ t ≡ v}
          {Ξ ⊢ t ∈ A ⊂ \f("∀X B")} $
\end{center}
Note that the rule include a premise stating the term $t$ carried by
the judgments should be equivalent to a value. This corresponds to
the semantical value restriction condition in our new system with
subtyping.

In conjunction with local subtyping, choice operators allow the
derivation of many valid permutations of quantifiers and connectors.
For instance, Mitchell's containment axiom \cite("Mitchell1991")
$$ \f("∀X (A ⇒ B)") ⊂ \f("(∀X A) ⇒ (∀X B)")$$
can be easily derived. Consequently, our type system mostly
contains typing and subtyping rules that are syntax-directed.
In particular, we do not have a transitivity rule for subtyping.
It is not a problem since such a rule cannot be implemented.
Indeed, it would require the system to guess an intermediate
type. Transitivity is generally admissible in subtyping systems.
In our system however, it is an open problem whether a form of
transitivity is admissible.

=<
=> Typing and subtyping rules

We will now give the formal definition of our new type system
with subtyping. We will reuse some of the formalism given in
\chapter("typeSystem"), but modifications will be required. For
instance, we will need to extend the language of values, stacks
and formulas to include choice operators.
\begin{def}
We will extend the language of formulas $\cal{F}$ with two new
constructors $\f("εχ∈s(t∈A)")$ and $\f("εχ∈s(t∉A)")$ representing
choice operators. They will be made available in the syntax, and
will provide an alternative presentation of quantifiers. Note that
our system needs to be extended with the following two sorting
rules.
$$
  \binaryR{Σ ⊢ t : τ}{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
  \hspace(4.0)
  \binaryR{Σ ⊢ t : τ}{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("εχ∈s(t∉A)") : ο}
$$
\end{def}

To introduce value and stack witnesses into our system, we will
need to make a distinction between values, terms, stacks and
formulas that may contain value and stack witnesses and those
that may not.
\begin{def}
We extend the syntax of values with a new constructor
$\v("εx∈A(t∉B)")$, where $x∈\cal{V}_ι$ is a $λ$-variables,
$t∈Λ$ is a term and $A$, $B∈\cal{F}$ are propositions.
Similarly, the syntax of stacks is extended with a new
constructor $\s("εα∈A(t∉A)")$, where $α∈\cal{V}_σ$ is a
$μ$-variable, $t∈Λ$ is a term and $A∈\cal{F}$ is a
proposition. Note that our system needs to be extended
with the following two sorting rules.
$$
  \ternaryR{Σ ⊢ A : ο}{Σ, x : ι ⊢ t : τ}{Σ ⊢ B : ο}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
  \hspace(4.0)
  \binaryR{Σ ⊢ A : ο}{Σ, α : σ ⊢ t : τ}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
$$
\end{def}
Note that our extension of the syntax of values and the syntax
of stacks propagates to the terms and formulas in general.
\begin{def}
We will refer to values, terms and stacks that may contain value
and stack witnesses as //raw// values, //raw// terms and //raw//
stacks. The corresponding sets will be denoted $Λ^{+}_ι$, $Λ^{+}$
and $Π^{+}$ respectively.
\end{def}

Before giving the new typing and subtyping rules of our system,
we need to consider two (and in fact three) new forms of
judgments.
\begin{def}
A //general typing judgment// is a triple of an equational context
$Ξ$, a raw term $t∈Λ^+$ and a formula $A ∈ \cal{F}$ that is denoted
$Ξ ⊢ t : A$. A //pointed subtyping judgment// is a quadruple of an
equational context $Ξ$, a raw term $t∈Λ^{+}$ and two formulas
$A$, $B ∈ \cal{F}$ that is denoted $Ξ ⊢ t ∈ A ⊂ B$. We will use the
notation $Ξ ⊢ A ⊂ B$ when the term $t$ is of the form
$\v("εx∈A(x∉B)")$.
\end{def}
\begin{def}
A general typing judgment or a pointed subtyping judgment is said to
be correct if it is derivable using the deduction rules of
\figRef("subrules").
\end{def}

With the implementation in mind, it is important for our general typing
rules to be directed by the syntax. This means that we should be able
to select which rule to apply by looking at the surface constructor of
the term we want to type-check. The general typing rules given in
\figRef("subrules") can all be implemented as a syntax-directed procedure,
with the exception of the ($⇒_e$) and ($⇒_{e,{∈}}$) rules (which form
a critical pair). However, this is not really a problem since we can
choose to apply the ($⇒_{e,{∈}}$) rule whenever possible, and fallback
to the ($⇒_e$) rule. It is always safe to do so thanks to the following
lemma.
\Caml(let _ = subrules ()) (* NOTE can be moved *)

\begin{lem}
If a typing judgment $Ξ ⊢ \t("t u") : \f("B")$ has a typing proof starting
with the ($⇒_e$) rule, and if the judgment $Ξ ⊢ ∃v, v≡u$ is provable, then
$Ξ ⊢ \t("t u") : \f("B")$ also has a typing proof starting with the
($⇒_{e,{∈}}$) rule.
\begin{proof}
Blah bla bla.
\end{proof}
\end{lem}

=<
=> Semantics of subtyping

We have values, terms, stacks, processes and types extended with sets of
terms.

\begin{center}
\diagram(
let _ = array [`East ; `East ; `West] [
  [<$v,w$>; <$::=$>; <$x \| {λx t} \| {ε_{x∈A}(t∉B)} \| \id(wbox)$>];
  [<$t,u$>; <$::=$>; <$v \| {(t) u} \| {μα t} \| p$>];
  [<$π,ρ$>; <$::=$>; <$α \| {v⋅π} \| {[t]π} \| {ε_{α∈¬Α}(t∉A)} \| \id(bbox)$>];
  [<$p,s$>; <$::=$>; <$t ∗ π$>];
  [<$A,B$>; <$::=$>; <$X \| {A ⇒ B} \| {∀X A} \| {ε_X(t∉A)} \| Φ$>];
])
\end{center}

The types are interpreted using sets of values containing $\id(wbox)$ and
closed under $({≡})$. The set of every such type interpretation is denoted
$⟦\cal{F}⟧$ and is defined as follows.
$$⟦\cal{F}⟧ = \{Φ ⊆ Λ_{val} \| \id(wbox) ∈ Φ \land ∀{v∈Φ}, v≡w ⇒ w∈Φ\}$$
Values, terms, stacks, processes are interpreted as values, terms, stacks,
processes with no choice operators but with the special value $\id(wbox)$
and the special stack $\id(bbox)$.
\begin{center}
\diagram(
let _ = array [`East ; `East ; `West] [
  [<$⟦Φ⟧$>; <$=$>; <$Φ$>];
  [<$⟦A ⇒ B⟧$>; <$=$>; <$\{λx t \| ∀{v∈⟦A⟧},{t[x := v] ∈ ⟦B⟧^{\bot\bot}}\}
    ∪ \{\id(wbox)\}$>];
  [<$⟦∀X A⟧$>; <$=$>; <$\biginter_{Φ∈⟦\cal{F}⟧}{⟦A[X := Φ]⟧}$>];
  [<$⟦ε_X(t∉A)⟧$>; <$=$>; <$Φ∈⟦\cal{F}⟧ \mt(<<such that>>) ⟦t⟧∈⟦A[X := Φ]⟧
     \mt(<<or>>) \{\id(wbox)\}$>];
])
\end{center}
\begin{center}
\diagram(
let _ = array [`East ; `East ; `West] [
  [<$⟦(t) u⟧$>; <$=$>; <$(⟦t⟧) ⟦u⟧$>];
  [<$⟦μα t⟧$>; <$=$>; <$μα⟦t⟧_α$>];
  [<$⟦λx t⟧$>; <$=$>; <$λx ⟦t⟧_x$>];
  [<$⟦ε_{x∈A}(t∉B)⟧$>; <$=$>; <$v∈⟦A⟧ \mt(<<such that>>)
     t[x := v]∈⟦a⟧^{\bot\bot} \mt(<<or>>) \id(wbox)$>];
  [<$⟦\id(wbox)⟧$>; <$=$>; <$\id(wbox)$>];
])
\end{center}
\begin{center}
\diagram(
let _ = array [`East ; `East ; `West] [
  [<$⟦t ∗ π⟧$>; <$=$>; <$⟦t⟧ ∗ ⟦π⟧$>];
  [<$⟦v⋅π⟧$>; <$=$>; <$⟦v⟧⋅⟦π⟧$>];
  [<$⟦[t]π⟧$>; <$=$>; <$[⟦t⟧]⟦π⟧$>];
  [<$⟦ε_{α∈¬A}(t∉A)⟧$>; <$=$>; <$π∈⟦A⟧^\bot \mt(<<such that>>)
     t[α := π]∈⟦a⟧^{\bot\bot} \mt(<<or>>) \id(bbox)$>];
  [<$⟦\id(bbox)⟧$>; <$=$>; <$\id(bbox)$>];
])
\end{center}

We have two forms of judgements:
\begin{itemize}
\item $t : A$ meaning that the term $t$ has type $A$,
\item $v : A ⊆ B$ meaning that if the value $v$ has type $A$ then it also
      has type $B$.
\end{itemize}
We define $A ⊆ B$ as $ε_{x∈A}(x∉B) : A ⊆ B$.

$$
\axiomRN{ε}{ε_{x \in A}(t ∉ B) : A}
\hspace(3.0)
\unaryRN{{→}_i}{t[x := ε_{x ∈ A}(t ∉ B)] : B}{λx t : A ⇒ B}
\hspace(3.0)
\binaryRN{{→}_e}{t : A ⇒ B}{u : A}{(t) u : B}
$$
$$
\unaryRN{μ}{t[α := ε_{α ∈ ¬A}(t ∉ A)] : A}{μα t : A}
\hspace(3.0)
\unaryRN{∗}{t : A}{t ∗ ε_{α ∈ ¬A}(t ∉ A) : B}
$$
$$
\axiomRN{=}{v : A ⊆ A}
\hspace(3.0)
\unaryRN{∀_l}{v : A[X := C] ⊆ B}{v : ∀X A ⊆ B}
\hspace(3.0)
\unaryRN{∀_r}{v : A ⊆ B[X := ε_X(v ∉ B)]}{v : A ⊆ ∀X B}
$$
$$
\binaryRN{→}{A₂ ⊆ A₁}{B₁ ⊆ B₂}{v : {A₁ ⇒ B₁} ⊆ {A₂ ⇒ B₂}}
\hspace(3.0)
\binaryRN{⊆}{t : A}{A ⊆ B}{t : B}
\hspace(3.0)
\ternaryRN{⊆_{≡}}{t : A}{v : A ⊆ B}{t ≡ v}{t : B}
$$

\begin{thm}
Let $A$ and $B$ be closed types, $v$ be a closed value, and $t$ be a closed
term.
\begin{itemize}
\item If $t : A$ then we have $⟦t⟧ ∈ ⟦A⟧^{\bot\bot}$.
\item If $v : A ⊆ B$ and $⟦v⟧ ∈ ⟦A⟧$ then we have $⟦v⟧ ∈ ⟦B⟧$.
\end{itemize}
\begin{proof}
We do a proof by induction on the structure of the proof of $t : A$ and $v :
A ⊆ B$ respectively. We consider the last rules used in the proof.

\begin{noindent}
\linesBefore(2)
($ε$) We need to show $⟦ε_{x \in A}(t ∉ B)⟧ ∈ ⟦A⟧^{\bot\bot}$. By definition,
we know $⟦ε_{x \in A}(t ∉ B)⟧ ∈ ⟦A⟧$ since $\wbox ∈ ⟦A⟧$. Hence we can
conclude since $⟦A⟧ ⊆ ⟦A⟧^{\bot\bot}$

\linesBefore(2)
($→_i$) We need to show $⟦λx t⟧ ∈ ⟦A ⇒ B⟧^{\bot\bot}$. Since we have $⟦A ⇒ B⟧
⊆ ⟦A ⇒ B⟧^{\bot\bot}$ it is enough to show $⟦λx t⟧ ∈ ⟦A ⇒ B⟧$. If there is
$v ∈ ⟦A⟧$ such that $⟦t[x := v]⟧ ∉ ⟦B⟧^{\bot\bot}$ then we can decide that
$⟦ε_{x∈A}(t∉B)⟧ = v$. This contradicts the induction hypothesis that states
that $⟦t[x := ε_{x∈A}(t∉B)]⟧ = ⟦t[x := v]⟧ ∈ ⟦B⟧^{\bot\bot}$. Hence, it must
be that we have $⟦t[x := v]⟧ ∈ ⟦B⟧^{\bot\bot}$ for all $v ∈ ⟦A⟧$. This exactly
means $⟦λx t⟧ ∈ ⟦A ⇒ B⟧$.

\linesBefore(2)
($→_e$) We need to show $⟦(t) u⟧ ∈ ⟦B⟧^{\bot\bot}$. We take $π ∈ ⟦B⟧^\bot$
and show ${⟦(t) u⟧ ∗ π} ∈ \dbot$. By reduction, it is enough to show
that ${⟦u⟧ ∗ {[⟦t⟧] π}} ∈ \dbot$. By induction hypothesis we know that
$⟦u⟧ ∈ ⟦A⟧^{\bot\bot}$, hence it is enough to show that $[⟦t⟧] π ∈ ⟦A⟧^\bot$.
We take $v ∈ ⟦A⟧$ and show that ${v ∗ {[⟦t⟧] π}} ∈ \dbot$. By reduction, it
is enough to show that ${⟦t⟧ ∗ {v · π}} ∈ \dbot$. By induction hypothesis,
we know that $⟦t⟧ ∈ ⟦A ⇒ B⟧^{\bot\bot}$, hence it only remains to show that
${v · π} ∈ ⟦A ⇒ B⟧^\bot$. We will now pick a value in $w ∈ ⟦A ⇒ B⟧$ and show
that ${w ∗ {v · π}} ∈ \dbot$. If $w = \wbox$, then this is immediate.
Otherwise there is $x$ and $t$ such that $w = λx t$ and for all $v₀ ∈ ⟦A⟧$,
$t[x := v₀] ∈ ⟦B⟧^{\bot\bot}$. In this case we need to show that ${λx t ∗
{v · π}} ∈ \dbot$, which amounts to showing that ${t[x := v] ∗ π} ∈ \dbot$ by
reduction. Since $v ∈ ⟦A⟧$ we know that $t[x := v] ∈ ⟦B⟧^{\bot\bot}$. We
can hence conclude since $π ∈ ⟦B⟧^\bot$.

\linesBefore(2)
($μ$) We need to show $⟦μα t⟧ ∈ ⟦A⟧^{\bot\bot}$ so we take $π ∈ ⟦A⟧^\bot$
and show ${⟦μα t⟧ ∗ π} ∈ \dbot$. By reduction, it is enough to show that
${⟦t[α := π]⟧ ∗ π} ∈ \dbot$. If there is a stack $ρ ∈ ⟦A⟧^\bot$ such that
$⟦t[α := ρ]⟧ ∉ ⟦A⟧^{\bot\bot}$ then we can decide that $⟦ε_{α∈¬A}(t∉A)⟧ = ρ$.
In this case, the induction hypothesis gives us $⟦t[α := ρ]⟧ ∈
⟦A⟧^{\bot\bot}$, which is a contradiction. As a consequence, we know that
for all $ρ ∈ ⟦A⟧^\bot$ we have $⟦t[α := ρ]⟧ ∈ ⟦A⟧^{\bot\bot}$. This is true
in particular for $π$, hence we know that $⟦t[α := π]⟧ ∈ ⟦A⟧^{\bot\bot}$ from
which we can conclude that ${⟦t[α := π]⟧ ∗ π} ∈ \dbot$.

\linesBefore(2)
($∗$) We need to show that $⟦t ∗ ε_{α ∈ ¬A}(t ∉ A)⟧ ∈ ⟦B⟧^{\bot\bot}$ so we
take $π ∈ ⟦B⟧^\bot$ and show ${⟦t ∗ ε_{α ∈ ¬A}(t ∉ A)⟧ ∗ π} ∈ \dbot$. By
reduction, it is enough to show that ${⟦t⟧ ∗ ⟦ε_{α ∈ ¬A}(t ∉ A)⟧} ∈ \dbot$.
By induction hypothesis, we know that $⟦t⟧ ∈ ⟦A⟧^{\bot\bot}$ so we only
have to show that $⟦ε_{α ∈ ¬A}(t ∉ A)⟧ ∈ ⟦A⟧^\bot$. This is true by
definition.

\linesBefore(2)
($=$) The proof is immediate since $⟦v⟧ ∈ ⟦A⟧$ trivially imply $⟦v⟧ ∈ ⟦A⟧$.

\linesBefore(2)
($∀_l$) We suppose that $⟦v⟧ ∈ ⟦∀X A⟧$, and show that $⟦v⟧ ∈ ⟦B⟧$. By
induction hypothesis, it is enough to show that $⟦v⟧ ∈ ⟦A[X := C]⟧$. We
can conclude as $⟦∀X A⟧ ⊆ ⟦A[X := C]⟧$ by definition.

\linesBefore(2)
($∀_r$) We suppose that $⟦v⟧ ∈ ⟦A⟧$, and show that $⟦v⟧ ∈ ⟦∀X B⟧$. Using
the induction hypothesis, we obtain that $⟦v⟧ ∈ ⟦B[X := ε_X(v ∉ B)]⟧$. If
there is $Φ ∈ ⟦\cal{F}⟧$ such that $⟦v⟧ ∉ ⟦B[X := Φ]⟧$ then we can decide
that $⟦ε_X(v ∉ B)⟧ = Φ$. In this case, the induction hypothesis tells us
that $⟦v⟧ ∈ ⟦B[X := Φ]⟧$ since $v ∈ ⟦A⟧$. As we have a contradiction, it
must be that for all $Φ ∈ ⟦\cal{F}⟧$ we have $⟦v⟧ ∈ ⟦B[X := Φ]⟧$. As a
consequence we obtain $⟦v⟧ ∈ \biginter_{Φ∈⟦\cal{F}⟧}{⟦B[X := Φ]⟧} = ⟦∀X B⟧$.

\linesBefore(2)
($→$) We suppose that $⟦v⟧ ∈ ⟦A₁ → B₁⟧$, and show that $⟦v⟧ ∈ ⟦A₂ ⇒ B₂⟧$. If
$⟦v⟧ = \wbox$ then it is trivial, otherwise there is $x$ and $t$ such that
$⟦v⟧ = λx t$. Let us take $w ∈ ⟦A₂⟧$ and show that $t[x := v] ∈ ⟦B₂⟧$. If
there is a value $v ∈ ⟦A₂⟧$ such that $v ∉ ⟦A₁⟧$ then we can suppose that
$⟦ε_{x∈A₂}(x∉A₁)⟧ = v$. In this case, the induction hypothesis tells us that
for all $v₀ ∈ ⟦A₂⟧$, we have $v₀ ∈ ⟦A₁⟧$. In particular, this implies that
$v ∈ ⟦A₁⟧$, which is contradictory. As a consequence, $v₀ ∈ ⟦A₂⟧$ we have
$v₀ ∈ ⟦A₁⟧$. This is true for $w$, and hence we get $w ∈ ⟦A₁⟧$, which implies
$t[x := w] ∈ ⟦B₁⟧^{\bot\bot}$ by definition of $⟦A₁ ⇒ B₁⟧$. It remains to
show that $⟦B₁⟧^{\bot\bot} ⊆ ⟦B₂⟧^{\bot\bot}$, for which it is enough to
show that $⟦B₁⟧ ⊆ ⟦B₂⟧$. If there is a value $v ∈ ⟦B₁⟧$ such that $v ∉ ⟦B₂⟧$
then we can suppose that $⟦ε_{x∈B₁}(x∉B₂)⟧ = v$. In this case, the
induction hypothesis tells us that for all $v₀ ∈ ⟦B₁⟧$, we have $v₀ ∈ ⟦B₂⟧$.
In particular, this implies that $v ∈ ⟦B₂⟧$, which is contradictory. As a
consequence, there cannot be any $v₀ ∈ ⟦B₁⟧$ such that $v ∉ ⟦B₂⟧$. This
exactly means that $⟦B₁⟧ ⊆ ⟦B₂⟧$.

\linesBefore(2)
($⊆$) We need to show that $⟦t⟧ ∈ ⟦B⟧^{\bot\bot}$. By induction hypothesis
$⟦t⟧ ∈ ⟦A⟧^{\bot\bot}$, hence we will show $⟦A⟧^{\bot\bot} ⊆ ⟦B⟧^{\bot\bot}$.
By definition, it is enough to show that $⟦A⟧ ⊆ ⟦B⟧$. If
there is a value $v ∈ ⟦A⟧$ such that $v ∉ ⟦B⟧^{\bot\bot}$ then it must be
that $v ∉ ⟦B⟧$. The induction hypothesis then tells us that $v ∈ ⟦B⟧$ since
$v ∈ ⟦A⟧$, hence we have a contradiction. As a consequence, it must be that
for all $v ∈ ⟦A⟧$ we have $v ∈ ⟦B⟧^{\bot\bot}$ and hence $v ∈ ⟦B⟧$. This
exactly mean that $⟦A⟧ ⊆ ⟦B⟧$.

\linesBefore(2)
($⊆_{≡}$) We need to show that $⟦t⟧ ∈ ⟦B⟧^{\bot\bot}$. By hypothesis we know
that $t ≡ v$, hence we can show $⟦v⟧ ∈ ⟦B⟧^{\bot\bot}$ which is equivalent
to showing $⟦v⟧ ∈ ⟦B⟧$. By induction hypothesis we know that $⟦t⟧ ∈
⟦A⟧^{\bot\bot}$, from which we can deduce $⟦v⟧ ∈ ⟦A⟧^{\bot\bot}$ since
$t ≡ v$ by hypothesis. As a consequence we have $⟦v⟧ ∈ ⟦A⟧$ from which we
can obtain $⟦v⟧ ∈ ⟦B⟧$ using the induction hypothesis.
\end{noindent}
\end{proof}
\end{thm}

=<

=<
