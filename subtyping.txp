\Caml(
  open ProofTree
  open Diagrams
  open Lang

  let sp = <$\mcolor(white){:}|\mcolor(white){:}$>

  let vs a = <$ ⟦\f(a)⟧ $>
  let ss a = <$ ⟦\f(a)⟧^⊥ $>
  let ts a = <$ ⟦\f(a)⟧^{⊥⊥} $>

  let mt = mathsText
  let wbox = <$\mathsize{3.}{\wbox}$>
  let bbox = <$\mathsize{3.}{\bbox}$>
)
\Include{Macros}

\Caml(
let r_arrow_i =
  <$\binaryRN{⇒_i}{Ξ ⊢ \t("λx t") ∈ \f("A ⇒ B") ⊂ C}
    {Ξ ⊢ \t("t[x ≔ εx∈A(t∉B)]") : \f("B")}{Ξ ⊢ \t("λx t") : C}$>

let r_arrow_e =
  <$\binaryRN{⇒_e}{Ξ ⊢ \t("t") : \f("A ⇒ B")}
    {Ξ ⊢ \t("u") : \f("A")}{Ξ ⊢ \t("t u") : \f("B")}$>

let r_ax =
  <$\unaryRN{Ax}{Ξ ⊢ ε_{x∈A}(t∉B) ∈ A ⊂ C}{Ξ ⊢ ε_{x∈A}(t∉B) : C}$>

let r_arrow_ee =
  <$\ternaryRN{⇒_{e,{∈}}}{Ξ ⊢ \t("t") : \f("u∈A ⇒ B")}
    {Ξ ⊢ \t("u") : \f("A")}{Ξ ⊢ v ≡ u}{Ξ ⊢ \t("t u") : \f("B")}$>

let r_mu =
  <$\unaryRN{μ}{Ξ ⊢ \t("t[α ≔ εα∈A(t∉A)]") : A}{Ξ ⊢ \t("μα t") : \f("A")}$>

let r_name =
  <$\binaryRN{[\wc]}{Ξ ⊢ u : A}{Ξ ⊢ π : ¬A}{Ξ ⊢ \t("[π]u") : \f("B")}$>

let r_ax_bot =
  <$\unaryRN{Ax^⊥}{Ξ ⊢ A ⊂ B}{Ξ ⊢ \s("εα∈A(t∉A)") : ¬B}$>

let r_push =
  <$\ternaryRN{\wc·\wc}{Ξ ⊢ v : A}{Ξ ⊢ π : ¬B}{Ξ ⊢ \f("A⇒B") ⊂ C}
    {Ξ ⊢ \s("v·π") : ¬C}$>

let r_fram =
  <$\binaryRN{[\wc]\wc}{Ξ ⊢ t : \f("A⇒B")}{Ξ ⊢ π : ¬B}
    {Ξ ⊢ \s("[t]π") : ¬A}$>

let r_sum_i =
  <$\binaryRN{+_i}{Ξ ⊢ \t("v") : \f("A")}
    {Ξ ⊢ \t("C[v]") ∈ \f("[C : A]") ⊂ \f("B")}{Ξ ⊢ \t("C[v]") : B}$>

let r_sum_e =
  <$\binaryRN{+_e}{Ξ ⊢ \t("v") : \f("[(Ci : Ai) i∈I]")}
    {(Ξ, \t("v") ≡ \t("Ci[εxi∈Ai(ti∉C)]") ⊢
      \t("ti[xi ≔ εxi∈Ai(ti∉C)]") : \f("C"))_{i∈I}}
    {Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : \f("C")}$>

let r_prod_i =
  <$\binaryRN{×_i}{Ξ ⊢ \t("{(li = vi) i∈I}") ∈ \f("{(li : Ai) i∈I}") ⊂ C}
    {(Ξ ⊢ \t("vi") : \f("Ai"))_{i∈I}}{Ξ ⊢ \t("{(li = vi) i∈I}") : C}$>

let r_prod_e =
  <$\unaryRN{×_e}{Ξ ⊢ \t("v") : \f("{l : A}")} {Ξ ⊢ \t("v.l") : A}$>

let r_ax_sub =
  <$\axiomRN{Ax_{⊂}}{Ξ ⊢ \t("t") : A ⊂ A}$>

let r_arrow =
  <$\binaryRN{⇒}{Ξ ⊢ \t("εx∈A₂(t x ∉ B₂)") ∈ \f("A₂") ⊂ \f("A₁")}
    {Ξ ⊢ \t("t εx∈A₂(t x ∉ B₂)") ∈ \f("B₁") ⊂ \f("B₂")}
    {Ξ ⊢ \t("t") ∈ \f("A₁ ⇒ B₁") ⊂ \f("A₂ ⇒ B₂")}$>

let r_sum =
  <$\binaryRN{+}{I₁ ⊂ I₂}
    {(Ξ ⊢ \t("(λx [x | Ci[xi] → xi]) t") ∈ \f("Ai") ⊂ \f("Bi"))_{i∈I₁}}
    {Ξ ⊢ \t("t") ∈ \f("[(Ci : Ai) i∈I₁]") ⊂ \f("[(Ci : Bi) i∈I₂]")}$>

let r_prod =
  <$\binaryRN{×}{I₂ ⊂ I₁}
    {(Ξ ⊢ \t("(λx x.li) t") ∈ \f("Ai") ⊂ \f("Bi"))_{i∈I₂}}
    {Ξ ⊢ \t("t") ∈ \f("{(li : Ai) i∈I₁}") ⊂ \f("{(li : Bi) i∈I₂}")}$>

let r_forall_l =
  <$\unaryRN{∀_l}
    {Ξ ⊢ \t("t") ∈ \f("A[χ≔C]") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("∀χ^s A") ⊂ \f("B")}$>

let r_forall_r =
  <$\binaryRN{∀_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B[χ ≔ εχ∈s(t∉B)]")}
    {Ξ ⊢ v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("∀χ^s B")}$>

let r_exists_r =
  <$\unaryRN{∃_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B[χ≔C]")}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("∃χ^s B")}$>

let r_exists_l =
  <$\binaryRN{∃_l}
    {Ξ ⊢ \t("t") ∈ \f("A[χ ≔ εχ∈s(t∈A)]") ⊂ \f("B")}
    {Ξ ⊢ v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("∃χ^s A") ⊂ \f("B")}$>

let r_rest_l =
  <$\unaryRN{\restriction_l}
    {Ξ, u₁ ≡ u₂ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ \t("t") ∈ \f("A ∧ u₁ ≡ u₂") ⊂ \f("B")}$>

let r_rest_r =
  <$\binaryRN{\restriction_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ u₁ ≡ u₂}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B ∧ u₁ ≡ u₂")}$>

let r_memb_l =
  <$\binaryRN{∈_l}
    {Ξ, t ≡ u ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("u ∈ A") ⊂ \f("B")}$>

let r_memb_r =
  <$\ternaryRN{∈_r}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("B")}
    {Ξ ⊢ t ≡ u}
    {Ξ ⊢ v ≡ t}
    {Ξ ⊢ \t("t") ∈ \f("A") ⊂ \f("u ∈ B")}$>

let rs env =
  let env = resize_env 3.2 env in
  let rs =
    [ [ r_arrow_i ; r_arrow_e ]
    ; [ r_ax ; r_arrow_ee ]
    ; [ r_mu ; r_name ; r_ax_bot ]
    ; [ r_push ; r_fram ]
    ; [ r_prod_e ; r_prod_i ]
    ; [ r_sum_e ]
    ; [ r_sum_i ; r_ax_sub ]
    ; [ r_arrow ]
    ; [ r_sum ; r_prod ]
    (* quantifiers. *)
    ; [ r_forall_l ; r_forall_r ]
    ; [ r_exists_r ; r_exists_l ]
    (* restriction and membership. *)
    ; [ r_rest_l ; r_rest_r ]
    ; [ r_memb_l ; r_memb_r ] ]
  in
  let rs = List.map (List.map (fun cs -> <<$\id(cs)$>>)) rs in
  List.map (List.map (fun cs -> draw_boxes env (boxify_scoped env cs))) rs

let subrules () =
  figure_here ~name:"subrules"
    ~caption:[tT "Typing and subtyping rules."] (dr rs)
)

=> Introducing subtyping into the system \label("subtyping")

In this chapter, we reformulate the definition of our system to account for
subtyping. The main idea is to transform the typing rules that do not have
algorithmic contents into subtyping rules. For instance, quantifiers,
fixpoints, membership types and equality types will be handled using
subtyping.

=> Interests of subtyping

There is no denying that polymorphism and type abstraction are essential
features for programming in a generic way. They lead to programs that are
shorter, more modular, easier to understand and hence more reliable.
Although subtyping also provides similar perspectives, it is considerably
less widespread among programming languages. Practical languages only rely
on limited forms of subtyping for their module system \cite("MacQueen1984"),
or for the use of polymorphic variants \cite("Garrigue1998"). Overall,
subtyping is useful for both product types (e.g. records or modules) and
sum types (e.g. polymorphic variants). It provides canonical injections
between a type and its subtypes. For example, unary natural numbers may
be defined as a subtype of unary integers.

The downside of subtyping is that it is difficult to incorporate in
complex systems like //Haskell// or ||OCaml||. For example, ||OCaml||
provides polymorphic variants \cite("Garrigue1998") for which complex
annotated types are inferred. For instance, one would expect the
following ||OCaml|| function to be given the type ##[`T | `F] -> [`T | `F]##.
### OCaml
  let neg = function
    | `T -> `F
    | `F -> `T
###
Indeed, the variance of the arrow type conveys enough information: ##neg##
can be applied to elements of any subtype of ##[`T | `F]## (e.g. ##[`T]##)
and produces elements of any supertype of ##[`T | `F]## (e.g.
##[`T | `F | `M]##). ||OCaml|| infers the type ##[<`T | `F] -> [>`T | `F]##
in which subtypes and supertypes are explicitly tagged. This is not very
natural and hides a complex mechanism involving polymorphic type variables.
More discussion on the limitations of ||OCaml||'s polymorphic variants, can
be found in \cite("Castagna2016"), for example.

In this thesis, we will show that it is possible to design a practical
type system based on subtyping for our language. It allows for a rather
straight-forward implementation using standard unification techniques
following the typing and subtyping rules that will be given in the
following sections. In particular, the typing and subtyping procedures
never have to backtrack since they are directed by the syntax of terms
and types respectively. The ideas presented here were introduced in a
joint work of Christophe Raffalli and the author \cite("Lepigre2017").

=<

=> Symbolic witnesses and local subtyping

Several related technical innovations are required to include subtyping
into our system. In particular, we will need to generalise the usual
subtyping relation $A ⊂ B$ (meaning "$A$ is a subtype of $B$") using a
//local subtyping// relation $t ∈ A ⊂ B$. It will be interpreted as
"if $t$ has type $A$ then it also has type $B$". Usual subtyping is then
recovered using choice operators inspired from //Hilbert's Epsilon and
Tau functions// \cite("Hilbert1968"). In our system, the choice operator
$\v("εx∈A(t∉B)")$ denotes a value $v$ of type $A$ such that $\t("t[x≔v]")$
does not have type $B$. If no such term exists, then an arbitrary term
of type $A$ can be chosen. We can then take $\v("εx∈A(x∉B)") ∈ A ⊂ B$ as
a definition of $A ⊂ B$.
\begin{rem}
Of course, for the choice operator $\v("εx∈A(t∉B)")$ to be well-defined
we will need the interpretation of every type to non-empty. It is the
case in \cite("Lepigre2017") as the model is based on Girard's
reducibility candidates \mcite(["Girard1972"; "Girard1989"]).
\end{rem}

Choice operators can be used to replace the notion of free variables,
and hence suppress the need for typing contexts. Intuitively,
$\v("εx∈A(t∉B)")$ denotes a counterexample to the fact that $\t("λx t")$
has type $\f("A⇒B")$. Consequently, we will use the rule of the form
\begin{center}
$ \unaryR{Ξ ⊢ \t("t[x≔εx∈A(t∉B)]") : B}
    {Ξ ⊢ \t("λxt") : \f("A⇒B")} $
\end{center}
for typing $λ$-abstractions. It can be read as a proof by contradiction
as its premise is only valid when there is no value $v$ of type $A$ such
that $\t("t[x≔v]")$ does not have type $B$. The axiom rule is then
replaced by the following typing rule for choice operators.
\begin{center}
$ \axiomR{Ξ ⊢ \t("εx∈A(t∉B)") : A} $
\end{center}
Obviously, the same trick can be used for $μ$-variables and
$μ$-abstractions. As for choice operators for values, choice
operators for stack will need to always be well-defined. As
a consequence, we will need to make sure that the set of stacks
associated to each type contain at least one element.

The use of choice operators and the elimination of typing contexts
will plays an essential role in the definition of our type system
with subtyping. Indeed, they will allow us to handle quantifiers
using our local subtyping relation only. This will allow us to work
with syntax-directed typing rules only, and most of the work will
be done using subtyping.

Choice operators will also be used for the handling of quantifiers.
We will thus introduce two new type constructors $\f("εX(t∈A)")$ and
$\f("εX(t∉A)")$ corresponding to choice operators for picking a type
satisfying the denoted properties. For example, $\f("εX(t∉B)")$ is a
type such that the term $t$ does not have type $\f("B[X≔εX(t∉B)]")$.
Intuitively, $\f("εX(t∉B)")$ is a counter-example to the judgment
"$t$ has type $\f("∀X B")$". Hence, to show that $t$ has type
$\f("∀X B")$, it will be enough to show that it has type
$\f("B[X≔εX(t∉B)]")$. As a consequence, the usual typing rule for
universal quantifier introduction is subsumed by the following local
subtyping rule.
\begin{center}
$ \binaryR{Ξ ⊢ t ∈ A ⊂ \f("B[X≔εX(t∉B)]")}{Ξ ⊢ t ≡ v}
          {Ξ ⊢ t ∈ A ⊂ \f("∀X B")} $
\end{center}
Note that the rule include a premise stating the term $t$ carried by
the judgments should be equivalent to a value. This corresponds to
the semantical value restriction condition in our new system with
subtyping.

In conjunction with local subtyping, choice operators allow the
derivation of many valid permutations of quantifiers and connectors.
For instance, Mitchell's containment axiom \cite("Mitchell1991")
$$ \f("∀X (A ⇒ B)") ⊂ \f("(∀X A) ⇒ (∀X B)")$$
can be easily derived. Consequently, our type system mostly
contains typing and subtyping rules that are syntax-directed.
In particular, we do not have a transitivity rule for subtyping.
It is not a problem since such a rule cannot be implemented.
Indeed, it would require the system to guess an intermediate
type. Transitivity is generally admissible in subtyping systems.
In our system however, it is an open problem whether a form of
transitivity is admissible.

=<
=> Typing and subtyping rules

We will now give the formal definition of our new type system
with subtyping. We will reuse some of the formalism given in
\chapter("typeSystem"), but modifications will be required. For
instance, we will need to extend the language of values, stacks
and formulas to include choice operators.
\begin{def}
We will extend the language of formulas $\cal{F}$ with two new
constructors $\f("εχ∈s(t∈A)")$ and $\f("εχ∈s(t∉A)")$ representing
choice operators. They will be made available in the syntax, and
will provide an alternative presentation of quantifiers. Note that
our system needs to be extended with the following two sorting
rules.
$$
  \binaryR{Σ ⊢ t : τ}{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
  \hspace(4.0)
  \binaryR{Σ ⊢ t : τ}{Σ, χ : s ⊢ A : ο}{Σ ⊢ \f("εχ∈s(t∉A)") : ο}
$$
\end{def}

To introduce value and stack witnesses into our system, we will
need to make a distinction between values, terms, stacks and
formulas that may contain value and stack witnesses and those
that may not.
\begin{def}
We extend the syntax of values with a new constructor
$\v("εx∈A(t∉B)")$, where $x∈\cal{V}_ι$ is a $λ$-variables,
$t∈Λ$ is a term and $A$, $B∈\cal{F}$ are propositions.
Similarly, the syntax of stacks is extended with a new
constructor $\s("εα∈A(t∉A)")$, where $α∈\cal{V}_σ$ is a
$μ$-variable, $t∈Λ$ is a term and $A∈\cal{F}$ is a
proposition. Note that our system needs to be extended
with the following two sorting rules.
$$
  \ternaryR{Σ ⊢ A : ο}{Σ, x : ι ⊢ t : τ}{Σ ⊢ B : ο}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
  \hspace(4.0)
  \binaryR{Σ ⊢ A : ο}{Σ, α : σ ⊢ t : τ}{Σ ⊢ \f("εχ∈s(t∈A)") : ο}
$$
\end{def}
Note that our extension of the syntax of values and the syntax
of stacks propagates to the terms and formulas in general.
\begin{def}
We will refer to values, terms and stacks that may contain value
and stack witnesses as //raw// values, //raw// terms and //raw//
stacks. The corresponding sets will be denoted $Λ^{+}_ι$, $Λ^{+}$
and $Π^{+}$ respectively.
\end{def}

Before giving the new typing and subtyping rules of our system,
we need to consider three (and in fact three) new forms of judgments.
\begin{def}
A //general typing judgment// is a triple of an equational context
$Ξ$, a raw term $t∈Λ^+$ and a formula $A ∈ \cal{F}$ that is denoted
$Ξ ⊢ t : A$. A //general stack judgment// is a triple of an equational
context $Ξ$, a raw stack $π∈Π^+$ and a formula $A ∈ \cal{F}$ that is
denoted $Ξ ⊢ π : ¬A$. A //pointed subtyping judgment// is a quadruple
of an equational context $Ξ$, a raw term $t∈Λ^{+}$ and two formulas
$A$, $B ∈ \cal{F}$ that is denoted $Ξ ⊢ t ∈ A ⊂ B$. We will use the
notation $Ξ ⊢ A ⊂ B$ when the term $t$ is equal to $\v("εx∈A(x∉B)")$.
\end{def}
\begin{def}
A general typing judgment or a pointed subtyping judgment is said to
be correct if it is derivable using the deduction rules of
\figRef("subrules").
\end{def}

With the implementation in mind, it is important for our general typing
rules to be directed by the syntax. This means that we should be able
to select which rule to apply by looking at the surface constructor of
the term we want to type-check. The general typing rules given in
\figRef("subrules") can all be implemented as a syntax-directed procedure,
with the exception of the ($⇒_e$) and ($⇒_{e,{∈}}$) rules (which form
a critical pair). However, this is not really a problem since we can
choose to apply the ($⇒_{e,{∈}}$) rule whenever possible, and fallback
to the ($⇒_e$) rule. It is always safe to do so thanks to the following
lemma.
\Caml(let _ = subrules ()) (* NOTE can be moved *)

\begin{lem}
If a typing judgment $Ξ ⊢ \t("t u") : \f("B")$ has a typing proof starting
with the ($⇒_e$) rule, and if the judgment $Ξ ⊢ v≡u$ is provable, then
$Ξ ⊢ \t("t u") : \f("B")$ also has a typing proof starting with the
($⇒_{e,{∈}}$) rule.
\begin{proof}
\todo(Some "Hopeless ?") (* TODO *)
\end{proof}
\end{lem}

=<
=> Semantics of subtyping

We will now adapt our model to work with our new typing and subtyping
rules. The main problem that we need to solve is the interpretation of
raw terms, values and stacks. In particular, we need a way to interpret
our choice operators for values and for stacks. In \cite("Lepigre2017"),
choice operators for values are interpreted using neutral terms (i.e.
members of the smallest candidate). Here we cannot use the same trick
as there is no guarantee for the interpretation of a type to contain
a value. We will thus introduce a special symbol $✠$ that will be
used to denote an undefined witness in terms, values and stacks.

\begin{def}
We extend the syntax of values and the syntax of stacks with the symbol
$✠$ denoting an "undefined" object. Given a value, term, starck or
process $ψ$, we will write $✠ ∈ ψ$ if $ψ$ contains $✠$, and
$✠ ∉ ψ$ otherwise.
\end{def}
\begin{lem}
Let $p ∈ Λ×Π$ be a process such that $✠ ∉ p$. If there is $q ∈ Λ×Π$
such that $p ↠ q$ then $✠ ∉ q$.
\begin{proof}
Most of the reduction rules of $({↠})$ only build a new process by moving
around pieces of syntax appearing in $p$. As a consequence, every such
rule cannot make $✠$ appear. All the remaining rules are related to
binders, and obviously if $t$, $v$ and $π$ do not contain $✠$, then
neither $\f("t[x≔v]")$ nor $\f("t[α≔π]")$ do.
\end{proof}
\end{lem}

In the semantics, raw values, raw terms and raw stacks will be interpreted
using values, terms and stacks with the same structure. The underlying
choice operators will thus be replaced by elements of the corresponding
syntactic category.
\begin{def}
Given a raw value $v ∈ Λ_ι^{+}$ (resp. raw term $t ∈ Λ^{+}$, raw stack
$π ∈ Π^+$), we denote $⟦v⟧ ∈ Λ_ι$ (resp. $⟦t⟧ ∈ Λ$, $⟦π⟧ ∈ Π$) its
semantical interpretation. It is defined inductively as follows.
\begin{center}
\diagram(
let contents_values =
  let line syn s1 s2 = [<$ \syn(s1) $> ; <$ = $> ; <$ \syn(s2) $>] in
  let spec syn s  n = [<$ \syn(s) $> ; <$ = $> ; n] in
  two_cols
  [ line v "⟦x⟧"                  "x"
  ; line v "⟦λx t⟧"               "λx ⟦t⟧"
  ; line v "⟦C[v]⟧"               "C[⟦v⟧]"
  ; line v "⟦{(li=vi)i∈I}⟧"       "{(li=⟦vi⟧)i∈I}"
  ; spec v "⟦εx∈A(t∉B)⟧"          <$ v∈⟦A⟧ \st \t("t[x≔v]")∉⟦B⟧^{⊥⊥} $>
  ; spec v "⟦εx∈A(t∉B)⟧"          <$ ⊥ \hspace(0.4) otherwise $> ]
let _ = array [`East; `Main; `West; `East; `Main; `West] contents_values
          ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\begin{center}
\diagram(
let contents_terms =
  let line syn s1 s2 = [<$ \syn(s1) $> ; <$ = $> ; <$ \syn(s2) $>] in
  two_cols
  [ line t "⟦a⟧"                  "a"
  ; line t "⟦t u⟧"                "⟦t⟧ ⟦u⟧"
  ; line t "⟦μα t⟧"               "μα ⟦t⟧"
  ; line t "⟦[π]t⟧"               "[⟦π⟧] ⟦t⟧"
  ; line t "⟦v.lk⟧"               "⟦v⟧.lk"
  ; line t "⟦[v|(Ci[xi]→ti)i∈I]⟧" "[⟦v⟧|(Ci[xi]→⟦ti⟧)i∈I]"
  ; line t "⟦Y(t,v)⟧"             "Y(⟦t⟧,⟦v⟧)"
  ; line t "⟦U(v)⟧"               "U(⟦v⟧)"
  ; line t "⟦δ(v,w)⟧"             "δ(⟦v⟧,⟦w⟧)" ]
let _ = array [`East; `Main; `West; `East; `Main; `West] contents_terms
          ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\begin{center}
\linesBefore(5)
\diagram(
let contents_stacks =
  let line syn s1 s2 = [<$ \syn(s1) $> ; <$ = $> ; <$ \syn(s2) $>] in
  let spec syn s  n = [<$ \syn(s) $> ; <$ = $> ; n] in
  two_cols
  [ line s "⟦ε⟧"                  "ε"
  ; line s "⟦α⟧"                  "α"
  ; line s "⟦v·π⟧"                "⟦v⟧·⟦π⟧"
  ; line s "⟦[t]π⟧"               "[⟦t⟧]⟦π⟧"
  ; spec s "⟦εα∈A(t∉A)⟧"          <$ π∈⟦A⟧^⊥ \st \t("t[α≔π]")∉⟦B⟧^{⊥⊥} $>
  ; spec s "⟦εα∈A(t∉A)⟧"          <$ ⊥ \hspace(0.4) otherwise $> ]
let _ = array [`East; `Main; `West; `East; `Main; `West] contents_stacks
          ~horizontal_padding:(fun n -> if n = 3 then 10.0 else 1.0)
)
\end{center}
\end{def}
It is important to note that raw values, raw terms and raw stacks cannot
appear into types. Indeed, the semantics of our types is still defined
exactly as in \chapter("typeSystem"). In particular, value witnesses,
stack witnesses and $✠$ never appear in types.

\begin{def}
We will write:
\begin{itemize}
  \item $t ⊩ A$ if either $✠ ∈ \t("⟦t⟧")$ or $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$,
  \item $π ⊩ A$ if either $✠ ∈ \s("⟦π⟧")$ or $\s("⟦π⟧") ∈ ⟦A⟧^{⊥}$ and
  \item $t ⊩ A ⊆ B$ if either $t ⊩ A$ implies $t ⊩ B$, or in other words if
        we have $✠ ∈ \t("⟦t⟧")$ or if $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$ implies
        $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$.
\end{itemize}
\end{def}

\begin{lem}\label("subtypingincl")
Let $A$, $B ∈ \cal{F}$ be two formulas such that $\t("εx∈A(x∉B)") ⊩ A ⊂ B$
then $⟦A⟧ ⊆ ⟦B⟧$.
\begin{proof}
We reason by case on the definition of $\t("⟦εx∈A(x∉B)⟧")$. If it is equal
to $✠$, then for all $v∈⟦A⟧$ we have $v∈⟦B⟧^{⊥⊥}$ by definition. Thanks to
\thmRef("main"), $v∈⟦B⟧^{⊥⊥}$ implies $v ∈ ⟦B⟧$. As a consequence, we
obtain that for all $v ∈ ⟦A⟧$ we have $v ∈ ⟦B⟧$, which exactly means that
$⟦A⟧ ⊆ ⟦B⟧$. Now, if $\t("⟦εx∈A(x∉B)⟧") = v$ such that $v ∈ ⟦A⟧$ and
$v ∉ ⟦B⟧^{⊥⊥}$ then our hypothesis tells us that $v ∈ ⟦A⟧^{⊥⊥}$ implies
$v ∈ ⟦B⟧^{⊥⊥}$. Since $v ∈ ⟦A⟧$ we know that $v ∈ ⟦A⟧^{⊥⊥}$ by
\lemRef("orthosimple"), and thus we obtain $v ∈ ⟦B⟧^{⊥⊥}$. This is a
contradiction, and thus we necessarily have $\t("⟦εx∈A(x∉B)⟧") = ✠$.
\end{proof}
\end{lem}
\begin{thm}
Let $Ξ$ be an equational context, $A$, $B ∈ \cal{F}$ be closed types and
$t ∈ Λ^{+}$ be a raw term. If $ρ_{id} ⊩ Ξ$ then we have:
\begin{itemize}
\item if $Ξ ⊢ t : A$ is valid then we have $t ⊩ A$,
\item if $Ξ ⊢ π : ¬A$ is valid then we have $π ⊩ A$ and
\item if $Ξ ⊢ t ∈ A ⊂ B$ is valid then we have $t ⊩ A ⊂ B$.
\end{itemize}
\begin{proof}
We do a proof by induction on the structure of the proof of $Ξ ⊢ t : A$,
the proof of $Ξ ⊢ π : ¬A$ and the proof of $Ξ ⊢ t ∈ A ⊆ B$ respectively.
We consider the last rules used in the proof.
\begin{itemize}
\item In the case of the ($⇒_i$) rule, we need to show that $\t("λx t")⊩C$.
  Using the first induction hypothesis, we see that it is enough to show
  $\t("λx t") ⊩ \f("A ⇒ B")$. Let us now suppose $✠ ∉ \t("λx t")$, as
  otherwise we can conclude immediatly. In particular $✠ ∉ t$, or in other
  words $\t("⟦t⟧") = t$. By the second induction hypothesis, we have
  $\t("t[x≔εx∈A(t∉B)]") ⊩ B$. If $\t("⟦εx∈A(t∉B)⟧") = ✠$ then by definition
  $\t("⟦t[x≔v]⟧") = \t("t[x≔v]") ∈ ⟦B⟧^{⊥⊥}$ for all $v ∈ ⟦A⟧$. This
  exactly means that $\v("⟦λx t⟧") = \v("λx t") ∈ ⟦\f("A⇒B")⟧$. It remains
  to consider the case where $\t("⟦εx∈A(t∉B)⟧")$ is equal to some value
  $v ∈ ⟦A⟧$ such that $\t("⟦t[x≔v]⟧") ∉ ⟦B⟧^{⊥⊥}$. As we know that
  $✠ ∉ \t("⟦t[x≔v]⟧")$, the second induction hypothesis gives us a
  contradiction as it implies  $\t("⟦t[x≔εx∈A(t∉B)]⟧") = \t("⟦t[x≔v]⟧") ∈
  ⟦B⟧^{⊥⊥}$.

  $$ \id(r_arrow_i) $$

\item In the case of the ($⇒_e$) rule, we need to show that $\t("t u") ⊩
  B$. We can suppose that $✠ ∉ \t("⟦t u⟧")$ as otherwise we can conclude
  immediatly. In particular, this means that $\t("⟦t⟧") = t$ and that
  $\t("⟦u⟧") = u$, and thus we obtain $⟦t⟧ ∈ ⟦\f("A ⇒ B")⟧^{⊥⊥}$ and
  $⟦u⟧ ∈ ⟦A⟧^{⊥⊥}$ using our two induction hypotheses. We need to show
  that $\t("⟦t u⟧") = \t("⟦t⟧ ⟦u⟧") ∈ ⟦B⟧^{⊥⊥}$ so we take $π ∈ ⟦B⟧^⊥$
  and we show that $\p("⟦t⟧ ⟦u⟧ ∗ π") ∈ \dbot$. Since $\dbot$ is
  $({↠})$-saturated, it is enough to show that $\p("⟦u⟧ ∗ [⟦t⟧]π") ∈
  \dbot$. Now, as $⟦u⟧ ∈ ⟦A⟧^{⊥⊥}$ it is enough to show that
  $\s("[⟦t⟧]π") ∈ ⟦A⟧^⊥$. We thus take $v ∈ ⟦a⟧$ and show that we
  have $\p("v ∗ [⟦t⟧]π") ∈ \dbot$. Again, since $\dbot$ is
  $({↠})$-saturated it is enough to show that $\p("⟦t⟧ ∗ v·π") ∈ \dbot$.
  As $⟦t⟧ ∈ ⟦\f("A ⇒ B")⟧^{⊥⊥}$ we only have to show that $\s("v·π") ∈
  ⟦\f("A⇒B")⟧^{⊥⊥}$ so we take $\v("λx f") ∈ ⟦\f("A⇒B")⟧$ and show that
  $\p("λx f ∗ v·π") ∈ \dbot$. It is enough to show that
  $\p("f[x≔v] ∗ π") ∈ \dbot$, and this is true since $π ∈ ⟦B⟧^⊥$ and
  $\t("f[x≔v]") ∈ ⟦B⟧^{⊥⊥}$ by definition of $⟦\f("A⇒B")⟧$.

  $$ \id(r_arrow_e) $$

\item In the case of the ($Ax$) rule, we need to show that
  $\t("εx∈A(t∉B)") ⊩ C$. According to the induction hypothesis, it is
  enough to show that $\t("εx∈A(t∉B)") ⊩ A$. Let us reason by case on
  the definition of $\t("⟦εx∈A(t∉B)⟧")$. If it is $✠$ the the proof is
  immediate. Otherwise, we know that it is equal to some value $v ∈ ⟦A⟧$.
  We can thus conclude since $⟦A⟧ ⊆ ⟦A⟧^{⊥⊥}$ according to
  \lemRef("orthosimple").

  $$ \id(r_ax) $$

\item In the case of the ($⇒_{e,{∈}}$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_arrow_ee) $$

\item In the case of the ($μ$) rule, we need to show that $\t("μαt") ⊩ A$.
  We can assume that $✠ ∉ \t("⟦μαt⟧")$ as otherwise it is immediate. In
  particular, this means that $✠ ∉ \t("⟦t⟧")$. We have to show that
  $\t("⟦μαt⟧") = \t("μα⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$ so we take a stack $π ∈ ⟦A⟧^⊥$
  and show $\p("μα⟦t⟧ ∗ π") ∈ \dbot$. As $\dbot$ is $({↠})$-saturated, it
  is enougth to show $\p("⟦t⟧[α≔π] ∗ π") ∈ \dbot$, which rewrites as
  $\p("⟦t[α≔π]⟧ ∗ π") ∈ \dbot$. Let us now consider the induction
  hypothesis, which states that $\t("t[α ≔ εα∈A(t∉A)]") ⊩ A$. We will
  reason by case on the definition of $\t("⟦εα∈A(t∉A)⟧")$ so we first
  suppose that it is equal to $✠$. This means that for every stack
  $ξ ∈ ⟦A⟧^⊥$ we have $\t("⟦t[α≔π]⟧") ∈ ⟦A⟧^{⊥⊥}$ (it cannot be that
  $✠ ∈ \t("⟦t[α≔π]⟧")$ since $✠ ∉ \t("⟦t⟧")$). In particular, this is
  true for $ξ = π$ so we can conclude. Let us now suppose that
  $\t("⟦εα∈A(t∉A)⟧") = π$ with $π ∈ ⟦A⟧^⊥$ such that $\t("⟦t[α≔π]⟧") ∉
  ⟦A⟧^{⊥⊥}$ (we cannot have $✠ ∈ \t("⟦t[α≔π]⟧")$ as $✠ ∉ \t("⟦t⟧")$).
  This is a contradiction since the induction hypothesis gives
  $\t("⟦t[α ≔ εα∈A(t∉A)]⟧") = \t("⟦t[α≔π]⟧") ∉ ⟦A⟧^{⊥⊥}$ as
  $✠ ∉ \t("⟦t[α≔π]⟧")$.

  $$ \id(r_arrow_ee) $$

\item In the case of the ($[\wc]$) rule, we need to show that $\t("[π]u")
  ⊩ B$. We can assume that $✠ ∉ \t("⟦[π]u⟧")$ as otherwise it is immediate.
  As a consequence, we have $✠ ∉ \s("⟦π⟧")$ and $✠ ∉ \t("⟦u⟧")$, and thus
  the induction hypotheses give $\t("⟦u⟧") ∈ ⟦A⟧^{⊥⊥}$ and $\s("⟦π⟧") ∈
  ⟦A⟧$. We need to show $\t("⟦[π]u⟧") = \t("[⟦π⟧]⟦u⟧") ∈ ⟦B⟧^{⊥⊥}$ so we
  take $ξ ∈ ⟦B⟧^⊥$ and show that we have $\p("[⟦π⟧]⟦u⟧ ∗ ξ") ∈ \dbot$.
  As $\dbot$ is $({↠})$-saturated, it is enougth to show $\p("⟦u⟧ ∗ ⟦π⟧")
  ∈ \dbot$. This is immediate since we have $\t("⟦u⟧") ∈ ⟦A⟧^{⊥⊥}$ and
  $\s("⟦π⟧") ∈ ⟦A⟧$.

  $$ \id(r_name) $$

\item In the case of the ($Ax^⊥$) rule, we need to show that
  $\s("εα∈A(t∉A)") ⊩ B$. We can assume that $\s("⟦εα∈A(t∉A)⟧") ≠ ✠$
  as otherwise this is immediate. As a consequence, we know that
  $\s("⟦εα∈A(t∉A)⟧") = π$ such that $π ∈ ⟦A⟧^⊥$. As we need to show
  that $π ∈ ⟦B⟧^⊥$, it is enough to prove that $⟦A⟧^⊥ ⊆ ⟦B⟧^⊥$. According
  to \lemRef("orthoinclstack"), it is even enough to show that we have
  $⟦B⟧ ⊆ ⟦A⟧$. By induction hypothesis, we know that $\t("εx∈B(x∉A)")⊩B⊂A$
  and thus we can conclude using \lemRef("subtypingincl").

  $$ \id(r_ax_bot) $$

\item In the case of the ($\wc·\wc$) rule, we need to show that
  $\s("v·π") ⊩ C$. We can assume that $✠ ∉ \s("⟦v·π⟧")$ as otherwise
  this is immediate. As a consequence, $✠ ∉ \v("⟦v⟧")$ and $✠ ∉
  \s("⟦π⟧")$, and thus $\v("⟦v⟧") ∈ ⟦A⟧^{⊥⊥}$ and $\s("⟦π⟧") ∈ ⟦B⟧^⊥$
  by the first two induction hypotheses. We need to show that we have
  $\s("⟦v·π⟧") ∈ ⟦C⟧^⊥$. Using the third induction hypothesis
  together with \lemRef("subtypingincl"), it is enough to show that
  $\s("⟦v·π⟧") ∈ ⟦\f("A⇒B")⟧^⊥$. We thus take a value $\v("λx t") ∈
  ⟦\f("A⇒B")⟧$ and we show that $\p("λx t ∗ ⟦v⟧·⟦π⟧") ∈ \dbot$. As
  $\dbot$ is $({↠})$-saturated, it is enougth to show 
  $\p("t[x≔⟦v⟧] ∗ ⟦π⟧") ∈ \dbot$. Since $\s("⟦π⟧") ∈ ⟦B⟧^⊥$, we
  need to show that $\t("t[x≔⟦v⟧]") ∈ ⟦B⟧^{⊥⊥}$ but this follows
  from the definition of $⟦\f("A⇒B")⟧$.

  $$ \id(r_push) $$

\item In the case of the ($[\wc]\wc$) rule, we need to show that
  $\s("[t]π") ⊩ A$. We can assume that $✠ ∉ \s("⟦[t]π⟧")$ as
  otherwise this is immediate. As a consequence, $✠ ∉ \t("⟦t⟧")$
  and $✠ ∉ \s("⟦π⟧")$, and thus $\t("⟦t⟧") ∈ ⟦\f("A⇒B")⟧^{⊥⊥}$
  and $\s("⟦π⟧") ∈ ⟦B⟧^⊥$ by the first two induction hypotheses.
  We need to show that we have $\s("⟦[t]π⟧") ∈ ⟦A⟧^\bot$ so we
  take a value $v ∈ ⟦A⟧$ and we show that $\p("v ∗ [⟦t⟧]⟦π⟧") ∈
  \dbot$. As $\dbot$ is $({↠})$-saturated, it is enougth to show 
  $\p("⟦t⟧ ∗ v·⟦π⟧") ∈ \dbot$. As we know that we have $\t("⟦t⟧")
  ∈ ⟦\f("A⇒B")⟧^{⊥⊥}$ it remains to show that the stack $\s("v·⟦π⟧")$
  is in $⟦\f("A⇒B")⟧^⊥$. We can then finish the proof like in the
  previous case.

  $$ \id(r_fram) $$

\item In the case of the ($×_e$) rule, we need to show that
  $\t("v.l") ⊩ A$. We can assume that $✠ ∉ \t("⟦v.l⟧")$ as
  otherwise this is immediate. As a consequence, we know that
  $✠ ∉ \v("⟦v⟧")$ and the induction hypothesis gives us
  $\v("⟦v⟧") ∈ ⟦\f("{l:A}")⟧^{⊥⊥}$. Moreover, \thmRef("main")
  tells us that $\v("⟦v⟧") ∈ ⟦\f("{l:A}")⟧$, which means that
  $\v("⟦v⟧") = \v("{l = w}")$ for some value $w∈⟦A⟧$. We need
  to show that $\t("⟦v.l⟧") ∈ ⟦A⟧^{⊥⊥}$ so we take $π ∈ ⟦A⟧^⊥$
  and we show that we have
  $\p("⟦v⟧.l ∗ π") = \p("{l = w}.l ∗ π") ∈ \dbot$. As $\dbot$
  is $({↠})$-saturated, it is enougth to show 
  $\p("w ∗ π") ∈ \dbot$. This is immediate as $w ∈ ⟦A⟧$ and
  $π ∈ ⟦A⟧^⊥$.

  $$ \id(r_prod_e) $$

\item In the case of the ($×_i$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_prod_i) $$

\item In the case of the ($+_e$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_sum_e) $$

\item In the case of the ($+_i$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_sum_i) $$

\item In the case of the ($Ax_{⊂}$) rule, the proof is immediate. Indeed,
  it is always true that $t ⊩ A$ implies $t ⊩ A$.

  $$ \id(r_ax_sub) $$

\item In the case of the ($⇒$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_arrow) $$

\item In the case of the ($+$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_sum) $$

\item In the case of the ($×$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_prod) $$

\item In the case of the ($∀_l$) rule, we need to show that $t ⊩
  \f("∀χ^s A") ⊂ \f("B")$. We can assume $✠ ∉ ⟦t⟧$ as otherwise it is
  immediate. We thus suppose that $\t("⟦t⟧") ∈ ⟦\f("∀χ^s A")⟧^{⊥⊥}$
  and show that $\t("⟦t⟧") ∈ ⟦\f("B")⟧^{⊥⊥}$. Using the induction
  hypothesis, it is enough to show that we have $\t("⟦t⟧") ∈
  ⟦\f("A[χ≔C]")⟧^{⊥⊥}$. We will thus show that $⟦\f("∀χ^s A")⟧^{⊥⊥} ⊆
  ⟦\f("A[χ≔C]")⟧^{⊥⊥}$, for which it is enough to show $⟦\f("∀χ^s A")⟧
  ⊆ ⟦\f("A[χ≔C]")⟧^{⊥⊥}$ according to \lemRef("orthoincl"). This is
  immediate by definition of $⟦\f("∀χ^s A")⟧$.

  $$ \id(r_forall_l) $$

\item In the case of the ($∀_r$) rule, we need to show that $t ⊩
  \f("A") ⊂ \f("∀χ^s B")$. We can assume $✠ ∉ ⟦t⟧$ as otherwise it is
  immediate. We thus suppose that $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$ and show that
  $\t("⟦t⟧") ∈ ⟦\f("∀χ^s B")⟧^{⊥⊥}$. We have
  $\t("⟦t⟧") ∈ ⟦\f("B[χ ≔ εχ∈s(t∉B)]")⟧^{⊥⊥}$ by induction hypothesis.
  Now, as the pole is $({≡})$-extensional and $\t("⟦v⟧") ≡ \t("⟦t⟧")$
  for some value $v$, we know that
  $\t("⟦v⟧") ∈ ⟦\f("B[χ ≔ εχ∈s(t∉B)]")⟧^{⊥⊥}$ and we only have to show
  that $\t("⟦v⟧") ∈ ⟦\v("∀χ^s B")⟧^{⊥⊥}$. With \thmRef("main") we even
  have $\t("⟦v⟧") ∈ ⟦\f("B[χ ≔ εχ∈s(t∉B)]")⟧$ and we can show
  $\t("⟦v⟧") ∈ ⟦\v("∀χ^s B")⟧$. We now assume (by contradiction) that
  there is a formula $Φ ∈ ⟦s⟧$ such that we have
  $\t("⟦t⟧") ∉ ⟦\f("B[χ≔Φ]")⟧^{⊥⊥}$. We can thus decide that
  $⟦\f("B[χ ≔ εχ∈s(t∉B)]")⟧ = ⟦\f("B[χ≔Φ]")⟧$, which means that
  $\t("⟦t⟧") ∈ ⟦\f("B[χ≔Φ]")⟧^{⊥⊥}$. As a consequence, it
  must be that for every formula $Φ ∈ ⟦s⟧$ we have
  $\t("⟦t⟧") ∈ ⟦\f("B[χ≔Φ]")⟧^{⊥⊥}$, or equivalently
  $\t("⟦v⟧") ∈ ⟦\f("B[χ≔Φ]")⟧$ using the $({≡})$-extensionality of the
  pole and \thmRef("main"). This immediatly implies that we have
  $\t("⟦v⟧") ∈ ⟦\v("∀χ^s B")⟧$.

  $$ \id(r_forall_r) $$

\item In the case of the ($∃_r$) rule, we need to show that $t ⊩
  \f("A") ⊂ \f("∃χ^s B")$. We can assume $✠ ∉ ⟦t⟧$ as otherwise it is
  immediate. We thus suppose that $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$ and show that
  $\t("⟦t⟧") ∈ ⟦\f("∃χ^s B")⟧^{⊥⊥}$. By induction hypothesis, we know
  that $\t("⟦t⟧") ∈ ⟦\f("B[χ≔C]")⟧^{⊥⊥}$. We will thus show that
  $⟦\f("B[χ≔C]")⟧^{⊥⊥} ⊆ ⟦\f("∃χ^s B")⟧^{⊥⊥}$, for which it is enough
  to show $⟦\f("B[χ≔C]")⟧ ⊆ ⟦\f("∃χ^s B")⟧$ according to
  \lemRef("orthoincl"). This is immediate by definition of
  $⟦\f("∃χ^s B")⟧$.

  $$ \id(r_exists_r) $$

\item In the case of the ($∃_l$) rule,
  \todo(None) (* TODO *)

  $$ \id(r_exists_l) $$

\item In the case of the ($\restriction_l$) rule, we need to show that
  $t ⊩ \f("A∧u₁≡u₂") ⊂ B$. We can assume $✠ ∉ ⟦t⟧$ as otherwise it is
  immediate. We thus assume that $\t("⟦t⟧") ∈ ⟦\f("A∧u₁≡u₂")⟧^{⊥⊥}$ and
  show that we have $\t("⟦t⟧") ∈ ⟦B⟧^{⊥⊥}$. We can assume $u₁ ≡ u₂$ as
  otherwise we would have $⟦\f("A∧u₁≡u₂")⟧^{⊥⊥} = ∅^{⊥⊥} = ∅$, which
  contradicts $\t("⟦t⟧") ∈ ⟦\f("A∧u₁≡u₂")⟧^{⊥⊥}$. As a consequence, we
  know that $⟦\f("A∧u₁≡u₂")⟧ = ⟦A⟧$ and thus $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$.
  We can thus apply the induction hypothesis to conclude (using the
  fact that the $u₁ ≡ u₂$).

  $$ \id(r_rest_l) $$

\item In the case of the ($\restriction_r$) rule, we need to show that
  $t ⊩ A ⊂ \f("B∧u₁≡u₂")$. We can assume $✠ ∉ ⟦t⟧$ as otherwise it is
  immediate. We thus assume that $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$ and show that
  we have $\t("⟦t⟧") ∈ ⟦\f("B∧u₁≡u₂")⟧^{⊥⊥}$. Using the induction
  hypothesis, we know that $\t("⟦t⟧") ∈ ⟦B⟧^{⊥⊥}$. To conclude the
  proof, we will show that $⟦\f("B∧u₁≡u₂")⟧ = ⟦B⟧$. This immediatly
  follows from the second hypothesis, which gives us $u₁ ≡ u₂$ since
  the equivalences of $Ξ$ were assumed to be valid.

  $$ \id(r_rest_r) $$

\item In the case of the ($∈_l$) rule, we need to show that $t ⊩
  \f("u∈A") ⊂ B$. We can assume that $✠ ∉ \t("⟦t⟧")$ as otherwise
  it is immediate. We thus assume that $\t("⟦t⟧") ∈ ⟦\f("u∈A")⟧^{⊥⊥}$
  and show that $\t("⟦t⟧") ∈ ⟦B⟧^{⊥⊥}$. By hypothesis, we have
  $\t("⟦v⟧") ≡ \t("⟦t⟧")$ and as our pole is $({≡})$-extensional, we
  know that we have $\t("⟦v⟧") ∈ ⟦\f("u∈A")⟧^{⊥⊥}$ and it is enough
  to show that $\t("⟦v⟧") ∈ ⟦B⟧^{⊥⊥}$. Using \thmRef("main"), we know
  that we have $\t("⟦v⟧") ∈ ⟦\f("u∈A")⟧$, which gives us $\t("⟦v⟧") ≡
  \t("⟦u⟧")$ and $\t("⟦v⟧") ∈ ⟦A⟧$. We can thus apply the induction
  hypothesis to obtain $\t("⟦v⟧") ∈ ⟦B⟧$ using again the fact that
  the pole is $({≡})$-extensional and \thmRef("main").

  $$ \id(r_memb_l) $$

\item In the case of the ($∈_r$) rule, we need to show that $t ⊩ A ⊂
  \f("u∈B")$. We can assume that $✠ ∉ \t("⟦t⟧")$ as otherwise it is
  immediate. We thus suppose that $\t("⟦t⟧") ∈ ⟦A⟧^{⊥⊥}$ and show
  that $\t("⟦t⟧") ∈ ⟦\f("u∈B")⟧^{⊥⊥}$. Using the first induction
  hypothesis, we know that $\t("⟦t⟧") ∈ ⟦B⟧^{⊥⊥}$. Now, as the pole
  is $({≡})$-extensional and $\t("⟦v⟧") ≡ \t("⟦t⟧")$ for some value
  $v$, we know that $\t("⟦v⟧") ∈ ⟦B⟧^{⊥⊥}$ and we only have to show
  that $\t("⟦v⟧") ∈ ⟦\v("u∈B")⟧^{⊥⊥}$. According to \thmRef("main")
  we even have $\t("⟦v⟧") ∈ ⟦B⟧$ and we can show $\t("⟦v⟧") ∈
  ⟦\v("u∈B")⟧$. By definition of $⟦\f("u∈B")⟧$ we only have to show
  that $\t("⟦v⟧") ≡ \t("⟦u⟧")$, which follows by transitivity of
  $({≡})$ knowing $\t("⟦v⟧") ≡ \t("⟦t⟧")$ and $\t("⟦t⟧") ≡ \t("⟦u⟧")$.

  $$ \id(r_memb_r) $$
\end{itemize}
\end{proof}
\end{thm}

=<

=<
