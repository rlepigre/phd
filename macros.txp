\Caml(
let take n l =
  let rec take n l acc =
    match n, l with
    | 0, l     -> List.rev acc
    | n, x::xs -> take (n-1) xs (x :: acc)
    | _        -> l
  in take n l []

let rec drop n l =
  match n, l with
  | 0, l    -> l
  | n, []   -> l
  | n, x::l -> drop (n-1) l

let two_cols ls =
  let l = List.length ls in
  let h = l / 2 + (l mod 2) in
  let c1 = take h ls in
  let c2 = drop h ls in
  let c2 = if List.length c2 < h then c2 @ [[[];[];[]]] else c2 in
  let rec zip c1 c2 acc =
    match c1, c2 with
    | []    , []     -> List.rev acc
    | x1::c1, x2::c2 -> zip c1 c2 ((x1 @ x2) :: acc)
    | _              -> assert false
  in
  zip c1 c2 []

let _ =
  let pnum i = if i < 3 || i > 49 then "" else string_of_int i in
  DefaultFormat.sprint_page_number := pnum

module type Env =
  sig
    val do_begin_env : unit -> unit
    val do_end_env : unit -> unit
  end

let make_theorem : string -> (module Env) = fun name ->
  let module A =
    struct
      let refType = name
      let counter = name
      let counterLevel = 1
      let display num = bold [tT (name ^ " " ^ num ^ "."); (tT " ")]
    end
  in (module Make_theorem( A ))

module Env_def = (val make_theorem "Definition")
module Env_rem = (val make_theorem "Remark")
module Env_lem = (val make_theorem "Lemma")
module Env_thm = (val make_theorem "Theorem")
module Env_cor = (val make_theorem "Corollary")

let defRef x = <<Definition \generalRef("Definition")(x)>>
let remRef x = <<Remark \generalRef("Remark")(x)>>
let lemRef x = <<Lemma \generalRef("Lemma")(x)>>
let thmRef x = <<Theorem \generalRef("Theorem")(x)>>
let corRef x = <<Corollary \generalRef("Corollary")(x)>>
let figRef x = <<Figure \generalRef("figure")(x)>>

let definition = defRef
let remark     = remRef
let lemma      = lemRef
let theorem    = thmRef
let corollary  = corRef

let chapter l = (tT "Chapter ") :: sectref l
let section l = (tT "Section ") :: sectref l

let tval : Typography.Maths.math list =
  let t env = Maths.glyphs "val" (Maths.change_fonts env env.font)  in
  [Maths.bin_invisible 5 (mathSpace (-0.8)) [Maths.Ordinary (Maths.node t)]]

(* Stuff to add side note. *)
let sidenote_wr lbef laft text note =
  let environment env = {env with par_indent = []} in
  let np = newPar D.structure ~environment Complete.normal
    Patoline_Format.parameters in
  let contents env =
    let width c =
      let (x0,_,x1,_) = bounding_box_full (Document.draw env c) in
      x1 -. x0
    in
    let textw = width text in
    let notew = width note in
    let pagew = env.normalMeasure in
    let pad1 = (pagew -. textw) /. 2.0 in
    let pad2 = pagew -. pad1 -. textw -. notew in
    let glue w = [bB (fun _ -> [glue w w w])] in 
    (linesBefore lbef) @ (glue pad1) @ text @ (glue pad2) @ note @
    (linesAfter laft)
  in np [C contents]

let sidenote = sidenote_wr 2 2

let bnfs ls =
  let environment env = {env with par_indent = []} in
  let np = newPar D.structure ~environment Complete.normal
    Patoline_Format.parameters in
  let contents (name, vars, rule, more) env =
    let width c =
      let (x0,_,x1,_) = bounding_box (Document.draw env c) in x1 -. x0
    in
    let glue w = [bB (fun _ -> [glue w w w])] in 
    let wsname = List.map (fun (x,_,_,_) -> width x) ls in
    let wsvars = List.map (fun (_,x,_,_) -> width x) ls in
    let wsrule = List.map (fun (_,_,x,_) -> width x) ls in
    let wsmore = List.map (fun (_,_,_,x) -> width x) ls in
    let maxname = List.fold_left max 0.0 wsname in
    let maxvars = List.fold_left max 0.0 wsvars in
    let maxrule = List.fold_left max 0.0 wsrule in
    let maxmore = List.fold_left max 0.0 wsmore in
    let pad_sep = 2.0 in
    let sep = << $::=$ >> in
    let full_sep = (glue pad_sep) @ sep @ (glue pad_sep) in

    let wsep = width sep in
    let wname = width name in
    let wvars = width vars in
    let wrule = width rule in
    let wmore = width more in

    let pagew = env.normalMeasure in

    let name = name @ (glue (maxname -. wname)) in
    let vars = (glue (maxvars -. wvars)) @ vars in
    let rule = rule @ (glue (maxrule -. wrule)) in
    let more = (glue (maxmore -. wmore)) @ more in

    let padl =
      (pagew -. maxvars -. maxrule -. 2.0 *. wsep) /. 2.0 -. maxname
    in
    let padr =
      pagew -. maxname -. padl -. maxvars -. maxrule -. 2.0 *. wsep
      -. maxmore
    in

    name @ (glue padl) @ vars @ full_sep @ rule @ (glue padr) @ more
  in
  let line i l =
    let hd =
      if i = 0 then linesBefore 2
      else if i = List.length ls - 1 then linesAfter 2
      else []
    in
    np (hd @ [C (contents l)])
  in
  List.iteri line ls

(* Bibliography stuff. *)
let biblio = Minibib.from_name "biblio"

let mcite : string list -> content list = fun l ->
  let act l =
    let l = List.map (fun k -> emph [tT k]) l in
    let rec generate = function
      | []    -> invalid_arg "mcite"
      | [k]   -> k
      | k::ks -> k @ [tT ", "] @ generate ks
    in
    [tT "["] @ generate l @ [tT "]"]
  in
  Minibib.cite biblio act l

let cite : string -> content list = fun k ->
  mcite [k]

let dcite : string -> string -> content list = fun k e ->
  let txt = List.rev (List.tl (List.rev (cite k))) in
  txt @ [tT ", "] @ (emph [tT e]) @ [tT "]"]

let citen : string -> string -> content list = fun k n ->
  let act l =
    let k = List.hd l in
    [tT "["] @ emph [tT (String.concat ", " [k;n])] @ [tT "]"]
  in
  Minibib.cite biblio act [k]

let scale : float -> Document.environment -> Document.environment =
  fun f e -> {e with size = f *. e.size}

(* A majestic scissors symbol built with my onw hands. *)
let raw_scissors : raw list =
  let mirror =
    let mat =
      [| [| 1.0 ;  0.0 ; 0.0 |]
      ;  [| 0.0 ; -1.0 ; 0.0 |]
      ;  [| 0.0 ;  0.0 ; 1.0 |] |]
    in
    affine mat
  in
  let pp = {default_path_param with lineWidth = 0.4} in
  let pp_fillb =
    { default_path_param with close = true; fillColor = Some Color.black }
  in
  let pp_fillw = {pp_fillb with fillColor = Some Color.white} in
  let hd = Path (pp, [circle 0.8]) in
  let hole = Path (pp_fillw, [circle 0.3]) in
  let br =
    let x = [|0.0; 8.0; 1.0|] in
    let y = [|0.0; 0.0; 0.9|] in
    (x,y)
  in
  let br = Path (pp_fillb, [[|br|]]) in
  let br = translate 0.0 (-1.0) br in
  let br = [br; hd] in
  let origin_x c =
    let (x0,_,_,_) = bounding_box_full [c] in
    translate (-.x0) 0.0 c
  in
  let br1 = rotate (-0.3) (List.map (translate (-0.5) 1.7) br) in
  let br2 = rotate 0.3 [mirror br] in
  let cs =
    [ origin_x br1 ; origin_x br2
    ; translate 1.5 0.9 (origin_x hole) ]
  in
  let (x0,y0,x1,y1) = bounding_box_full cs in
  let w = x1 -. x0 in
  let cs = List.map (resize (1.0 /. w)) cs in
  let (x0,y0,x1,y1) = bounding_box_full cs in
  List.map (translate (-.x0) (-.y0)) cs

let scissors_drawing : Document.environment -> drawingBox = fun env ->
  let cont _ = List.map (resize 3.2) raw_scissors in
  drawing ~offset:(-0.2) (cont env)

let scissors : math list =
  let glue w =
    { drawing_min_width     = w
    ; drawing_max_width     = w
    ; drawing_nominal_width = w
    ; drawing_width_fixed   = true
    ; drawing_adjust_before = false
    ; drawing_y0            = infinity
    ; drawing_y1            = -.infinity
    ; drawing_contents      = (fun _ -> [])
    ; drawing_break_badness = 0.0
    ; drawing_states        = []
    ; drawing_badness       = knuth_h_badness w }
  in
  [Maths.Scope (fun env menv ->
    [ Maths.Glue (glue 1.2)
    ; Maths.Glue (scissors_drawing env)
    ; Maths.Glue (glue 0.4) ]
  )]

(* PML verbatim environments. *)
module PMLVerbatim : sig
    val verb_PML : string option -> string list -> unit
    val verbatim : string -> content list
  end = struct
    let pad = 2.0

    let keywords =
      [ "type" ; "val" ; "fun" ; "if" ; "then" ; "else" ; "let" ; "in"
      ; "rec" ; "match" ; "with" ; "of" ; "save" ; "restore" ]

    let symbols  =
      let simple_verb : string -> string * content =
         fun s -> (s, Verbatim.symbol s)
      in
      let scissors =
        bB (fun env -> [Drawing (scissors_drawing env)])
      in
      [ simple_verb "∀"
      ; simple_verb "→"
      ; simple_verb "∃"
      ; simple_verb "≡"
      ; simple_verb "⇒"
      ; simple_verb "Π"
      ; ("8<", scissors) ]

    let verb_PML fn lines =
      let open Verbatim in
      lines_to_file lines fn;
      let build_word = handle_word {keywords ; symbols} in
      let build_line l = hspace pad @ handle_spaces build_word l in
      line_per_line D.structure build_line lines
  
    let verbatim =
      let open Verbatim in
      (*
      let build = handle_spaces (handle_word {keywords ; symbols}) in
      verb_text (handle_spaces build)
      *)
      verb_text (handle_word {keywords = []; symbols})
  end

let verb_OCaml fn lines =
  let open Verbatim in
  lines_to_file lines fn;
  let extra = ["ref"; "throw"; "callcc"] in
  let param_OCaml =
    { param_OCaml with keywords = extra @ param_OCaml.keywords }
  in
  let build_word = handle_word param_OCaml in
  let build_line l = hspace 2.0 @ handle_spaces build_word l in
  line_per_line D.structure build_line lines

let lmcalc =
  let lm = [Maths.Ordinary (Maths.node (Maths.glyphs "λμ"))] in
  << $\lm$-calculus >>

let br, mbr =
  let dr1 env =
    { empty_drawing_box with drawing_min_width = 0.0
    ; drawing_max_width = env.normalMeasure
    ; drawing_nominal_width = 0.0 }
  in
  let dr2 env =
    { empty_drawing_box with drawing_min_width = 0.0
    ; drawing_max_width = 0.0 ; drawing_nominal_width = 0.0
    ; drawing_badness = (fun _ -> infinity) }
  in
  let br =
    let open Box in
    [bB (fun env -> [Glue (dr1 env); Glue (dr2 env)])]
  in
  let mbr =
    let open Maths in
    [Scope (fun env _ -> [Glue (dr1 env); Glue (dr2 env)])]
  in (br, mbr)

(* Convenient function to build figures. *)
let dr rs env =
  let rs = rs env in
  let wall = env.normalMeasure -. 6.0 in
  let size_box rs =
    let (x1, y1, x2, y2) = bounding_box rs in 
    (x2 -. x1, y2 -. y1)
  in
  let trs d = RawContent.translate d 0.0 in
  let draw_line ls =
    match ls with
    | [e1]         -> let (w1, h1) = size_box e1 in
                      let d1 = (wall -. w1) /. 2.0 in
                      let all = List.map (trs d1) e1 in
                      (h1, all)
    | [e1; e2]     -> let (w1, h1) = size_box e1 in
                      let (w2, h2) = size_box e2 in
                      let d1 = 0.0 in
                      let d2 = wall -. w2 in
                      let all =
                        List.map (trs d1) e1 @ List.map (trs d2) e2
                      in
                      (max h1 h2, all)
    | [e1; e2; e3] -> let (w1, h1) = size_box e1 in
                      let (w2, h2) = size_box e2 in
                      let (w3, h3) = size_box e3 in
                      let d1 = 0.0 in
                      let d2 = (wall -. w2) /. 2.0 in
                      let d3 = wall -. w3 in
                      let all =
                        List.map (trs d1) e1 @ List.map (trs d2) e2 @
                        List.map (trs d3) e3
                      in
                      (max h1 (max h2 h3), all)
    | _            -> assert false
  in
  let ls = List.map draw_line rs in
  let gather acc (h,l) =
    let h = h +. 6.0 in
    (List.map (RawContent.translate 0.0 h) acc) @ l
  in
  let cs = List.fold_left gather [] ls in
  let (x1, y1, x2, y2) = bounding_box cs in
  let border =
    let pad = 3.0 in
    let r = rectangle (x1 -. pad, y1 -. pad) (x2 +. pad, y2 +. pad) in
    [Path(default_path_param, [r])]
  in
  let all = (List.fold_left gather [] ls @ border) in
  let (x0,y0,x1,y1) = RawContent.bounding_box all in
  let all = List.map (RawContent.translate (-.x0) (-.y0)) all in
  drawing all
)
