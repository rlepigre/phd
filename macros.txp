\Caml(
let take n l =
  let rec take n l acc =
    match n, l with
    | 0, l     -> List.rev acc
    | n, x::xs -> take (n-1) xs (x :: acc)
    | _        -> l
  in take n l []

let rec drop n l =
  match n, l with
  | 0, l    -> l
  | n, []   -> l
  | n, x::l -> drop (n-1) l

let two_cols ls =
  let l = List.length ls in
  let h = l / 2 + (l mod 2) in
  let c1 = take h ls in
  let c2 = drop h ls in
  let c2 = if List.length c2 < h then c2 @ [[[];[];[]]] else c2 in
  let rec zip c1 c2 acc =
    match c1, c2 with
    | []    , []     -> List.rev acc
    | x1::c1, x2::c2 -> zip c1 c2 ((x1 @ x2) :: acc)
    | _              -> assert false
  in
  zip c1 c2 []

let _ =
  let pnum i = if i < 3 then "" else string_of_int i in
  DefaultFormat.sprint_page_number := pnum

let defaultEnv =
  {defaultEnv with hyphenate = DefaultFormat.hyphenate_dict "hyph-fr.hdict"}

module type Env =
  sig
    val do_begin_env : unit -> unit
    val do_end_env : unit -> unit
  end

let make_theorem : string -> (module Env) = fun name ->
  let module A =
    struct
      let refType = name
      let counter = name
      let counterLevel = 0
      let display num = alternative Bold
        [tT (name ^ " " ^ num ^ "."); (tT " ")]
    end
  in (module Make_theorem( A ))

module Env_def = (val make_theorem "Definition")
module Env_rem = (val make_theorem "Remark")
module Env_lem = (val make_theorem "Lemma")
module Env_thm = (val make_theorem "Theorem")
module Env_cor = (val make_theorem "Corollary")

let defRef x = <<definition \generalRef("Definition")(x)>>
let remRef x = <<remark \generalRef("Remark")(x)>>
let lemRef x = <<lemma \generalRef("Lemma")(x)>>
let thmRef x = <<theorem \generalRef("Theorem")(x)>>
let corRef x = <<corollary \generalRef("Corollary")(x)>>

let chapter l = (tT "chapter ") :: sectref l
let mchapter l = (tT "Chapter ") :: sectref l

let tval : Typography.Document.environment Typography.Maths.math list =
  let t = Maths.glyphs "val" in
  [Maths.bin_invisible 5 (mathSpace (-0.8)) [Maths.Ordinary (Maths.noad t)]]

(* Bibliography stuff. *)
let biblio = Minibib.from_name "biblio"

let mcite : string list -> content list = fun l ->
  let act l =
    let l = List.map (fun k -> emph [tT k]) l in
    let rec generate = function
      | []    -> invalid_arg "mcite"
      | [k]   -> k
      | k::ks -> k @ [tT ", "] @ generate ks
    in
    [tT "["] @ generate l @ [tT "]"]
  in
  Minibib.cite biblio act l

let cite : string -> content list = fun k ->
  mcite [k]
)


