\Caml(
let take n l =
  let rec take n l acc =
    match n, l with
    | 0, l     -> List.rev acc
    | n, x::xs -> take (n-1) xs (x :: acc)
    | _        -> l
  in take n l []

let rec drop n l =
  match n, l with
  | 0, l    -> l
  | n, []   -> l
  | n, x::l -> drop (n-1) l

let two_cols ls =
  let l = List.length ls in
  let h = l / 2 + (l mod 2) in
  let c1 = take h ls in
  let c2 = drop h ls in
  let c2 = if List.length c2 < h then c2 @ [[[];[];[]]] else c2 in
  let rec zip c1 c2 acc =
    match c1, c2 with
    | []    , []     -> List.rev acc
    | x1::c1, x2::c2 -> zip c1 c2 ((x1 @ x2) :: acc)
    | _              -> assert false
  in
  zip c1 c2 []

let _ =
  let pnum i = if i < 3 || i > 49 then "" else string_of_int i in
  DefaultFormat.sprint_page_number := pnum

module type Env =
  sig
    val do_begin_env : unit -> unit
    val do_end_env : unit -> unit
  end

let make_theorem : string -> (module Env) = fun name ->
  let module A =
    struct
      let refType = name
      let counter = name
      let counterLevel = 1
      let display num = emph [tT (name ^ " " ^ num ^ "."); (tT " ")]
    end
  in (module Make_theorem( A ))

module Env_def = (val make_theorem "Definition")
module Env_rem = (val make_theorem "Remark")
module Env_lem = (val make_theorem "Lemma")
module Env_thm = (val make_theorem "Theorem")
module Env_cor = (val make_theorem "Corollary")

let defRef x = <<Definition \generalRef("Definition")(x)>>
let remRef x = <<Remark \generalRef("Remark")(x)>>
let lemRef x = <<Lemma \generalRef("Lemma")(x)>>
let thmRef x = <<Theorem \generalRef("Theorem")(x)>>
let corRef x = <<Corollary \generalRef("Corollary")(x)>>

let chapter l = (tT "Chapter ") :: sectref l

let tval : Typography.Maths.math list =
  let t = Maths.glyphs "val" in
  [Maths.bin_invisible 5 (mathSpace (-0.8)) [Maths.Ordinary (Maths.node t)]]

(* Stuff to add side note. *)
let sidenote text note =
  let environment env = {env with par_indent = []} in
  let np =
    newPar D.structure ~environment Complete.normal Patoline_Format.parameters
  in
  let contents env =
    let width c =
      let (x0,_,x1,_) = bounding_box (Document.draw env c) in
      x1 -. x0
    in
    let textw = width text in
    let notew = width note in
    let pagew = env.normalMeasure in
    let pad1 = (pagew -. textw) /. 2.0 in
    let pad2 = pagew -. pad1 -. textw -. notew in
    let glue w = [bB (fun _ -> [glue w w w])] in 
    (linesBefore 2) @ (glue pad1) @ text @ (glue pad2) @ note @ (linesAfter 2)
  in np [C contents]

(* Bibliography stuff. *)
let biblio = Minibib.from_name "biblio"

let mcite : string list -> content list = fun l ->
  let act l =
    let l = List.map (fun k -> emph [tT k]) l in
    let rec generate = function
      | []    -> invalid_arg "mcite"
      | [k]   -> k
      | k::ks -> k @ [tT ", "] @ generate ks
    in
    [tT "["] @ generate l @ [tT "]"]
  in
  Minibib.cite biblio act l

let cite : string -> content list = fun k ->
  mcite [k]

let dcite : string -> string -> content list = fun k e ->
  let txt = List.rev (List.tl (List.rev (cite k))) in
  txt @ [tT ", "] @ (emph [tT e]) @ [tT "]"]

let citen : string -> string -> content list = fun k n ->
  let act l =
    let k = List.hd l in
    [tT "["] @ emph [tT (String.concat ", " [k;n])] @ [tT "]"]
  in
  Minibib.cite biblio act [k]

let scale : float -> Document.environment -> Document.environment =
  fun f e -> {e with size = f *. e.size}

(* A majestic scissors symbol built with my onw hands. *)
let raw_scissors : raw list =
  let mirror =
    let mat =
      [| [| 1.0 ;  0.0 ; 0.0 |]
      ;  [| 0.0 ; -1.0 ; 0.0 |]
      ;  [| 0.0 ;  0.0 ; 1.0 |] |]
    in
    affine mat
  in
  let pp = {default_path_param with lineWidth = 0.4} in
  let pp_fillb =
    { default_path_param with close = true; fillColor = Some Color.black }
  in
  let pp_fillw = {pp_fillb with fillColor = Some Color.white} in
  let hd = Path (pp, [circle 0.8]) in
  let hole = Path (pp_fillw, [circle 0.3]) in
  let br =
    let x = [|0.0; 8.0; 1.0|] in
    let y = [|0.0; 0.0; 0.9|] in
    (x,y)
  in
  let br = Path (pp_fillb, [[|br|]]) in
  let br = translate 0.0 (-1.0) br in
  let br = [br; hd] in
  let origin_x c =
    let (x0,_,_,_) = bounding_box_full [c] in
    translate (-.x0) 0.0 c
  in
  let br1 = rotate (-0.3) (List.map (translate (-0.5) 1.7) br) in
  let br2 = rotate 0.3 [mirror br] in
  let cs =
    [ origin_x br1 ; origin_x br2
    ; translate 1.5 0.9 (origin_x hole) ]
  in
  let (x0,y0,x1,y1) = bounding_box_full cs in
  let w = x1 -. x0 in
  let cs = List.map (resize (1.0 /. w)) cs in
  let (x0,y0,x1,y1) = bounding_box_full cs in
  List.map (translate (-.x0) (-.y0)) cs

let scissors_drawing : Document.environment -> drawingBox = fun env ->
  let cont _ = List.map (resize 3.2) raw_scissors in
  drawing ~offset:(-0.2) (cont env)

let scissors : math list =
  let glue w =
    { drawing_min_width     = w
    ; drawing_max_width     = w
    ; drawing_nominal_width = w
    ; drawing_width_fixed   = true
    ; drawing_adjust_before = false
    ; drawing_y0            = infinity
    ; drawing_y1            = -.infinity
    ; drawing_contents      = (fun _ -> [])
    ; drawing_break_badness = 0.0
    ; drawing_states        = []
    ; drawing_badness       = knuth_h_badness w }
  in
  [Maths.Scope (fun env menv ->
    [ Maths.Glue (glue 1.2)
    ; Maths.Glue (scissors_drawing env)
    ; Maths.Glue (glue 0.4) ]
  )]

(* PML verbatim environments. *)
module PMLVerbatim : sig
    val verb_PML : string option -> string list -> unit
    val verbatim : string -> content list
  end = struct
    let pad = 2.0

    let keywords =
      [ "type" ; "val" ; "fun" ; "if" ; "then" ; "else" ; "let" ; "in"
      ; "rec" ; "match" ; "with" ; "of" ; "save" ; "restore" ]

    let symbols  =
      let simple_verb : string -> string * content =
         fun s -> (s, Verbatim.symbol s)
      in
      let scissors =
        bB (fun env -> [Drawing (scissors_drawing env)])
      in
      [ simple_verb "∀"
      ; simple_verb "→"
      ; simple_verb "∃"
      ; simple_verb "≡"
      ; simple_verb "⇒"
      ; simple_verb "Π"
      ; ("8<", scissors) ]

    let verb_PML fn lines =
      let open Verbatim in
      lines_to_file lines fn;
      let build_word = handle_word {keywords ; symbols} in
      let build_line l = hspace pad @ handle_spaces build_word l in
      line_per_line D.structure build_line lines
  
    let verbatim =
      let open Verbatim in
      (*
      let build = handle_spaces (handle_word {keywords ; symbols}) in
      verb_text (handle_spaces build)
      *)
      verb_text (handle_word {keywords = []; symbols})
  end
)
