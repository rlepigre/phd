\Include{Macros}
\color(white){...}\linesAfter(7)

\begin{center}
\size(6.0){||Résumé||}
\linesAfter(3)
\end{center}
\begin{env}(fun env -> hyphenate_fr env)
Au cours des dernières années, les assistants de preuves on fait des progrès
considérables et ont atteint un grand niveau de maturité. Ils ont permit la
certification de programmes complexes tels que des compilateurs et même des
systèmes d'exploitation. Néanmoins, l'utilisation d'un assistant de preuve
requiert des compétences techniques très particulières, qui sont très
éloignées de celles requises pour programmer de manière usuelle. Pour combler
cet écart, nous entendons concevoir un langage de programmation de style ML
supportant la preuve de programmes. Il combine au sein d'un même outil la
flexibilité de ML et le fin niveau de spécification offert par un assistant
de preuve. Autrement dit, le système peut être utilisé pour programmer de
manière fonctionnelle et fortement typée tout en autorisant l'obtention de
nouvelles garanties au besoin.

On étudie donc un langage en appel par valeurs dont le système de type
étend une logique d'ordre supérieur. Il comprend un type égalité entre
les programmes non typés, un type de fonction dépendant, la logique
classique et du sous-typage. La combinaison de l'appel par valeurs,
des fonctions dépendantes et de la logique classique est connu pour
poser des problèmes de cohérence. Pour s'assurer de la correction du
système (cohérence logique et sûreté à l'exécution), on propose un
cadre théorique basé sur la réalisabilité classique de Krivine. La
construction du modèle repose sur une propriété essentielle qui lie
les différent niveaux d'interprétation des types d'une manière
novatrice.

On démontre aussi l'expressivité de notre système en se basant sur
son implantation dans un prototype. Il peut être utilisé pour prouver
des propriétés de programmes standards tels que la fonction « map »
sur les listes ou le tri par insertion.
\end{env}
(*
\begin{env}(fun env -> hyphenate_fr env)
On considère un langage de programmation à la ML, supportant la preuve de
programmes. L'idée est de combiner, au sein d'un même outil, la flexibilité
d'un véritable langage de programme et un grand pouvoir de spécification.
Autrement dit, on propose un système qui peut être utilisé pour programmer
de manière usuelle (au sens de la programmation fonctionnelle avec typage
fort), mais qui autorise l'ajout graduel de nouvelles garanties en prouvant
des propriétés des programmes (par exemple, montrer qu'une liste est triée).
De telles propriétés peuvent être spécifiées grâce à la réflexion d'une
relation d'équivalence sur les termes du langages, au sein de son système
de types. Un autre composant essentiel est un type de fonction dépendante,
qui peut être lu comme une forme de quantification typée. On peut donc
exprimer des propriétés qui s'appliquent, par exemple à tous les entiers
naturels, ou à tous les arbres binaires de recherche.

Pour s'assurer de la correction du système (cohérence logique et sûreté à
l'exécution), un cadre théorique basé sur la réalisabilité classique de
Krivine à du être imaginé. La construction de ce modèle repose sur une
propriété essentielle, liant les différents niveaux d'interprétation des
types d'une manière novatrice. La sémantique obtenue peut être combinée
avec du sous-typage pour former un système propice à l'implantation. Pour
gérer nos nouveaux connecteurs logiques, on introduit une relation ternaire
$t ∈ A ⊂ B$, appelée sous-typage pointé. Elle est interprétée comme
l'implication « si $t$ a le type $A$, alors $t$ a aussi le type $B$ » et
non comme une inclusion.
\end{env}
*)
