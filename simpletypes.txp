\Caml(open Diagrams open ProofTree)
\Include{Macros}

=> Simple types and classical logic

In order to prevent undesired computational behaviours such as runtime
errors, functional programming languages rely on syntactic checks. We
will here consider a small type system for our language, with only one
type constructor for functions and type constants.
\begin{def}
The set of types (or formulas) $\cal{F}$ is built from the countable set of
type variables (or type constants) $\cal{V}₀ = \{X,Y,Z...\}$ using
the following BNF grammar.
$$A,B ::= {X} \| {A ⇒ B} \hspace(4.0) X ∈ \cal{V}₀$$
We denote $FV_\cal{F}(A)$ the set of all the (free) type variables appearing
in the type $A$.
\end{def}
\begin{rem}
To lighten the notations, we will consider the function type to be right
associative. That is, we will always read a type of the form $A ⇒ B ⇒ C$
as $A ⇒ (B ⇒ C)$.
\end{rem}

To be able to give a type to terms containing free variables, we need to
use contexts. A context will map every free variable of a given term to its
assumed type. Additionally, we also include the (free) type variables in
our contexts.
\begin{def}
Given a term $t ∈ Λ$ and a type $A ∈ \cal{F}$, a context over $t$ and $A$
is a finite map $Γ$ with $FV_λ(t) ∪ FV_μ(t) ∪ FV_\cal{F}(A) ⊆ dom(Γ)$ such
that for all $λ$-variable $x ∈ FV_λ(t)$ we have $Γ(x) ∈ \cal{F}$ and for
all $μ$-variable $α∈FV_μ(t)$ we have $Γ(α) ∈ \cal{F}$. For convenience, we
will represent contexts using lists generated using the following BNF
grammar.
$$ Γ, Δ ::= {\bullet} \| {Γ, x : A} \| {Γ, α : A^\bot} \| {Γ, X} $$
However, we need to keep in mind that variables can only be mapped once in a
context and that the order in the list is not relevent.
\end{def}
\begin{def}
A typing judgement is a triple of a term $t$, a type $A$ and a context $Γ$
over $t$ and $A$ that is denoted $Γ ⊢ t : A$. We say that a judgement is
valid if it can be derived using the following rules.
$$
  \axiomRN{Ax}{Γ, x : A ⊢ x : A}
  \hspace(2.0)
  \unaryRN{{→}_i}{Γ, x : A ⊢ t : B}{Γ ⊢ λx t: A ⇒ B}
  \hspace(2.0)
  \binaryRN{{→}_e}{Γ ⊢ t : A ⇒ B}{Γ ⊢ u : A}{Γ ⊢ (t) u : B}
$$
$$
  \unaryRN{μ}{Γ, α : ¬A ⊢ t : A}{Γ ⊢ μα t : A}
  \hspace(2.0)
  \unaryRN{[{-}]}{Γ, α : ¬A ⊢ t : A}{Γ, α : ¬A  ⊢ [α] t : B}
$$
\end{def}

As an example, we can show that the term $λx λy x$ can be given the type
$X ⇒ Y ⇒ X$, where $X$ and $Y$ are type variables, in the following way.
$$
  \proofTree{
    \unaryN{⇒_i}{
      X, Y ⊢ λx λy x : Y ⇒ X
    }{
      \unaryN{⇒_i}{
        X, Y, x : X ⊢ λy x : Y ⇒ X
      }{
        \axiomN{Ax}{X, Y, x : X, y : Y ⊢ x : X}
      }
    }
  }
$$
Similarly, we can show that the term $λx λy x y$ has type $(X ⇒ Y) ⇒ X ⇒ Y$.
$$
  \proofTree{
    \unaryN{⇒_i}{
      X, Y ⊢ λx λy x y : (X ⇒ Y) ⇒ X ⇒ Y
    }{
      \unaryN{⇒_i}{
        X, Y, x : X ⇒ Y ⊢ λy x y : X ⇒ Y
      }{
        \binaryN{⇒_e}{
          X, Y, x : X ⇒ Y, x : Y ⊢ x y : Y
        }{
          \axiomN{Ax}{X, Y, x : X ⇒ Y, x : Y ⊢ x : X ⇒ Y}
        }{
          \axiomN{Ax}{X, Y, x : X ⇒ Y, x : Y ⊢ y : X}
        }
      }
    }
  }
$$

\begin{rem}
Intuitively, free type variables may stand for arbitary type. To discharche
these type variables from the context, we can use universal quantification
(i.e. polymorphism). It will be introduced introduced in the next section.
\end{rem}

Throught the Curry-Howard isomorphism, our type system can be seen as a
logic. Types then correspond to formulas that can be proved using deduction
rules. In our simple type system, the structure of a defivation is completely
determined by the terms of the $λμ$-calculus. Consequently, we may think of
a term well-typed term as a proof of its type (or formula).

(* § on classical reasoning TODO *)

\begin{env}(scale 0.75)
$$
  \proofTree{
    \unaryN{⇒_i}{
      X, Y ⊢ λf μα f λx [α]x : ((X ⇒ Y) ⇒ X) ⇒ X
    }{
      \unaryN{μ}{
        X, Y, f : (X ⇒ Y) ⇒ X ⊢ μα f λx [α]x : X
      }{
        \binaryN{⇒_e}{
          X, Y, f : (X ⇒ Y) ⇒ X, α : X^\bot ⊢ f λx [α]x : X
        }{
          \axiomN{Ax}{X, Y, f : (X ⇒ Y) ⇒ X, α : X^\bot ⊢ f : (X ⇒ Y) ⇒ X}
        }{
          \unaryN{⇒_i}{
            X, Y, f : (X ⇒ Y) ⇒ X, α : X^\bot ⊢ λx [α]x : X ⇒ Y
          }{
            \unaryN{[{-}]}{
              X, Y, f : (X ⇒ Y) ⇒ X, α : X^\bot, x : X ⊢ [α]x : Y
            }{
              \axiomN{Ax}{X, Y, f : (X ⇒ Y) ⇒ X, α : X^\bot, x : X ⊢ x : X}
            }
          }
        }
      }
    }
  }
$$
\end{env}

=<
