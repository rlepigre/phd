<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Rodolphe Lepigre's PhD Thesis</title>
    <style>
      h1, h2 { text-align : center; }
      p { text-align : justify; }
      html, body { max-width : 920px; margin : auto; padding : 20px; }
      a { text-decoration : none; color : grey; }
      a:hover { color : red; }
    </style>
  </head>
  <body>
    <h1>
      <a href="https://www.lama.univ-savoie.fr/~lepigre">Rodolphe Lepigre</a>'s PhD Thesis
    </h1>
    <h2>
      Semantics and Implementation of an Extension of ML
      <br/>
      for Proving Programs
    </h2>
    <p>
      In recent years, proof assistant have reached an impressive level of
      maturity. They have led to the certification of complex programs such
      as compilers and operating systems. Yet, using a proof assistant requires
      highly specialised skills and it remains very different from standard
      programming. To bridge this gap, we aim at designing an ML-style
      programming language with support for proofs of programs, combining in a
      single tool the flexibility of ML and the fine specification features of
      a proof assistant. In other words, the system should be suitable both for
      programming (in the strongly-typed, functional sense) and for gradually
      increasing the level of guarantees met by programs, on a by-need basis.
    </p>
    <p>
      We thus define and study a call-by-value language whose type system extends
      higher-order logic with an equality type over untyped programs, a dependent
      function type, classical logic and subtyping. The combination of
      call-by-value evaluation, dependent functions and classical logic is known
      to raise consistency issues. To ensure the correctness of the system (logical
      consistency and runtime safety), we design a theoretical framework based
      on Krivine's classical realisability. The construction of the model relies
      on an essential property linking the different levels of interpretation of
      types in a novel way.
    </p>
    <p>
      We finally demonstrate the expressive power of our system using our prototype
      implementation, by proving properties of standard programs like the map
      function on lists or the insertion sort.
    </p>
    <h3>Documents and source code:</h3>
    <ul>
      <li>
        <a href="manuscript_lepigre.pdf">PDF version</a> of the manuscript.
      </li>
      <li>
        <a href="manuscript_lepigre.ps">Postscript version</a> of the manuscript
        (recommended for printing).
      </li>
      <li>
        <a href="cbvMachine.v">Correctness proof</a> of a call-by-value
        Krivine abstract machine in Coq.
      </li>
      <li>
        <a href="classification.ml">Proof of Lemmas 2.6.45 and 2.6.46</a>
        (relies on OCaml's exhaustivity checker for patterns).
      </li>
      <li>
        Prototype implementation (soon available).
      </li>
    </ul>
    <h3>My advisors:</h3>
    <ul>
      <li><a href="https://lama.univ-savoie.fr/~raffalli">Christophe Raffalli</a></li>
      <li><a href="https://lama.univ-savoie.fr/~hyvernat">Pierre Hyvernat</a></li>
    </ul>
    <h3>Related papers:</h3>
    <ul>
      <li>
        <em>A Classical Realizability Model for a Semantical Value Restriction</em>
        (<a href="https://lama.univ-savoie.fr/~lepigre/files/docs/semvalrest2016.pdf">PDF draft</a>).
        <br/>
        Lecture Notes in Computer Science series, Volume 9632.
        <br/>
        Presented at the European Symposium on Programming (ESOP) 2016.
      </li>
      <li>
        <em>Practical Subtyping for System F with Sized (Co-)Induction</em>
        (<a href="../files/docs/subtyping2017.pdf">PDF draft</a>).
        <br/>
        To be submited for publication soon.
        <br/>
        With <a href="https://lama.univ-savoie.fr/~raffalli">Christophe Raffalli</a>, 2017.
      </li>
    </ul>
  </body>
</html>
