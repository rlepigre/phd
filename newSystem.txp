\Caml(
  open ProofTree
  open Lang
)
\Include{Macros}

=> Proofs of programs using equational reasoning \label("newSystem")

In this chapter, the type system previously presented will be extended to
enable the specification and the proof of program properties. The proof
mechanism will rely on an untyped notion of equivalence over programs. It
will be used to identify programs with the same computational behaviour and
will enable equational reasoning.

=> Observational equivalence type

To be able to specify program properties, we extend our type system with
equality types of the form $t ≡ u$, where $t$ and $u$ are (possibly untyped)
terms. Equality types are then interpreted as $⊤ = \f("∃X X")$ if the denoted
equivalence is true and as $⊥ = \f("∀X X")$ otherwise. For example, the type
$\f("(λx x) λx x ≡ (λx x)")$ will be inhabited if and only if the identity
function applied to itself is equivalent to the identity function.


(* TODO *)

=<
=> Realisers as individuals

... (* TODO *)

=<
=> Extensionality and substitutivity

... (* TODO *)

=<
=> Proofs and unreachability

... (* TODO *)

=<
=> Membership and typed quantification

\pagesBefore(1)
(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{Σ; {Γ, x:A}; Δ; Ξ ⊢ t : B}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : A ⇒ B}
\hspace(1.5)
\binaryRN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t : A ⇒ B}{Σ; Γ; Δ; Ξ ⊢ u : A}{
  Σ; Γ; Δ; Ξ ⊢ t u : B}
$$

(* The weak Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, x:ι_v}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{x ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀x (x∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, x:ι_v}; Γ; Δ; Ξ ⊢_\tval λx t : x∈A ⇒ B}{
   \unaryN{∈}{{Σ, x:ι_v}; {Γ, x:{x∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, x:ι_v}; {Γ, x:A}; Δ; {Ξ, x≡x} ⊢ t : B}{
     \hyp{{Σ, x:ι_v} ; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{x ∉ FV(Γ; Δ; Σ)}}
}
$$
(* The weak Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[x := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[x := v] ⇒ B[x := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀x (x∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[x := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[x := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[x := v]}
   }
  }
 }
}
$$

(* The Π_i rule and its derivation *)
$$
\binaryRN{Π_i}{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}{a ∉ FV(Γ; Δ; Ξ)}{
  Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)
}
$$
$$
\proofTree{
 \binaryN{∀_i}{Σ; Γ; Δ; Ξ ⊢_\tval λx t : ∀a (a∈A ⇒ B)}{
  \unaryN{⇒_i}{{Σ, a:ι}; Γ; Δ; Ξ ⊢_\tval λx t : a∈A ⇒ B}{
   \unaryN{∈}{{Σ, a:ι}; {Γ, x:{a∈A}}; Δ; Ξ ⊢ t : B}{
    \unaryN{wk}{{Σ, a:ι}; {Γ, x:A}; Δ; {Ξ, x≡a} ⊢ t : B}{
     \hyp{{Σ, a:ι}; {Γ, x:A}; Δ; Ξ ⊢ t : B}
    }
   }
  }
 }{\hyp{a ∉ FV(Γ; Δ; Σ)}}
}
$$

(* The Π_e rule and its derivation *)
$$
\binaryRN{Π_e}{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]
  }{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}
$$
$$
\proofTree{
 \binaryN{⇒_e}{Σ; Γ; Δ; Ξ ⊢ t v : B[a := v]}{
  \unaryN{∀_e}{Σ; Γ; Δ; Ξ ⊢ t : v∈A[a := v] ⇒ B[a := v]}{
   \hyp{Σ; Γ; Δ; Ξ ⊢ t : ∀a (a∈A ⇒ B)}
  }
 }{
  \unaryN{↑}{Σ; Γ; Δ; Ξ ⊢ v : v∈A[a := v]}{
   \unaryN{∈_i}{Σ; Γ; Δ; Ξ ⊢_\tval v : v∈A[a := v]}{
    \hyp{Σ; Γ; Δ; Ξ ⊢_\tval v : A[a := v]}
   }
  }
 }
}
$$
\pagesAfter(1)

(* TODO *)

=<
=> Extended type system

We will now give the formal definition of our new type system.
\begin{def}
We denote $\cal{S}₀ = \{ο, ι, τ, σ\}$ our set of atomic sorts. It contains
the sort of propositions $ο$, the sort of values $ι$, the sort of terms $τ$
and the sort of stacks $σ$.
\end{def}
\begin{def}
The set of all sorts $\cal{S}$ is generated from the set of atomic sorts
$\cal{S}₀$ using the following ||bnf|| grammar.
\Caml(let _ = sidenote_wr 1 2 << $s,r ::= {s→r} \| ξ$ >> << $ξ∈\cal{S}₀$ >>)
\end{def}
\begin{def}
Given a typing context $Γ$, a continuation context $Δ$ and an equational
context $Ξ$ we consider two different forms of typing judgments:
\begin{itemize}
\item value judgments $Γ;Ξ;Δ ⊢_\tval v : A$ meaning that the value $v$ has
      type $A$ and
\item general term judgments $Γ;Ξ;Δ ⊢ t : A$ meaning that the term $t$ has
      type $A$ in the context $Γ;Δ;Ξ$.
\end{itemize}
\end{def}
\begin{def}
Given a sorting context $Σ$ we say that $Γ;Δ;Ξ ⊢ t:A$ is a valid term
judgment and we write $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ when
\begin{itemize}
\item $dom(Γ) ⊆ dom(Σ)$ and hence for all $x ∈ dom(Γ)$ we have $Σ(x) = ι$,
\item $dom(Δ) ⊆ dom(Σ)$ and hence for all $α ∈ dom(Δ)$ we have $Σ(α) = σ$,
\item $Σ ⊢ t : τ$ and $Σ ⊢ A : ο$,
\item $FV_ι(t) ⊆ dom(Γ)$, $FV_σ(t) ⊆ dom(Δ)$ and $FV_τ(t) = ∅$,
\item for all $x ∈ dom(Γ)$ we have $Σ ⊢ Γ(x) : ο$,
\item for all $α ∈ dom(Δ)$ we have $Σ ⊢ Δ(α) : ο$,
\item for all $(t ≡ u) ∈ Σ$ we have $Σ ⊢ t : τ$ and $Σ ⊢ u : τ$.
\end{itemize}
\end{def}

\begin{def}
A valuation over a sorting context $Σ$ is a map $ρ$ such that $ρ(χ) ∈ ⟦Σ(χ)⟧$
for every $χ ∈ dom(Σ)$. In particular, this means that $dom(Σ) ⊆ dom(ρ)$.
\end{def}

(* Adequacy lemma. *)
\begin{thm}
Let $Σ$ be a sorting context and $ρ$ be a valuation over $Σ$. If the typing
judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$ (resp. $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$) is derivable
and if $ρ ⊩ Γ;Δ;Ξ$ then $\t("tρ") ∈ |\f("Aρ")|$ (resp.
$\t("vρ") ∈ ⟦\f("Aρ")⟧$).
\begin{proof}
We proceed by induction on the derivation of the judgment $Σ ⊢ (Γ;Δ;Ξ ⊢ t:A)$
or $Σ ⊢ (Γ;Δ;Ξ ⊢_\tval v:A)$, and we reason by case on the last used rule.
\begin{itemize}
\item In the case of the ($Ax$) rule we immediately obtain
      $\t("xρ") = ρ(x) ∈ ⟦\f("Aρ")⟧$ by hypothesis.
      \begin{center}
        $ \axiomRN{Ax}{Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)} $
      \end{center}
\item If the last used rule is ($⇒_i$) then we need to show that
      $\t("(λx t)ρ") ∈ ⟦\f("(A ⇒ B)ρ")⟧$. Let us take $v ∈ ⟦\f("Aρ")⟧$ and
      show that $\t("(tρ)[x ≔ v]") ∈ |\f("Bρ")|$. We can then conclude by
      induction hypothesis using the valuation $ρ[x ≔ v]$ to 
      \begin{center}
        $ \unaryRN{⇒_i}{Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)
            }{Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)} $
      \end{center}
\end{itemize}
\end{proof}
\end{thm}


(* Ax rule *)
$$
\axiomRN{Ax}{
  Σ, x:ι ⊢ (Γ, x:A; Δ; Ξ ⊢_\tval \t("x") : A)
}
$$

(* Coercion rules. *)
$$
\unaryRN{↑}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}
$$

$$
\unaryRN{↓}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}
$$

(* ⇒_i rule *)
$$
\unaryRN{⇒_i}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ ⊢ \t("t") : B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("λx t") : A ⇒ B)
}
$$

(* ⇒_e rule *)
$$
\binaryRN{⇒_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : A ⇒ B)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("u") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t u") : B)
}
$$

(* μ rule *)
$$
\unaryRN{μ}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("μα t") : A)
}
$$

(* ∗ rule *)
$$
\unaryRN{[\wc]}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("t") : A)
}{
  Σ, α:σ ⊢ (Γ;Δ,α:A;Ξ ⊢ \t("[α]t") : B)
}
$$

(* ∀i rule *)
$$
\unaryRN{∀_i}{
  Σ, χ:s ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("∀χ^s A"))
}
$$

(* ∀e rule *)
$$
\binaryRN{∀_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∀χ^s A"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ ≔ B]"))
}
$$

(* ∃i rule *)
$$
\binaryRN{∃_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A[χ≔B]"))
}{
  Σ ⊢ B : s
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("∃χ^s A"))
}
$$

(* ∃e rule *)
$$
\binaryRN{∃_e}{
  Σ, x:ι ⊢ (Γ,x:\f("A[χ≔B]");Δ;Ξ ⊢ \t("t") : \f("C"))
}{
  Σ ⊢ B : s
}{
  Σ, x:ι ⊢ (Γ,x:\f("∃χ^s A");Δ;Ξ ⊢ \t("t") : \f("C"))
}
$$

(* ∈i rule *)
$$
\unaryRN{∈_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("v∈A"))
}
$$

(* ∈e rule *)
$$
\unaryRN{∈_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,x≡t ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("t∈A");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ↾i rule *)
$$
\unaryRN{↾_i}{
  Σ ⊢ (Γ;Δ;Ξ,t≡u ⊢ \t("t") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("t") : \f("A | t≡u"))
}
$$

(* ↾e rule *)
$$
\unaryRN{↾_e}{
  Σ, x:ι ⊢ (Γ,x:A;Δ;Ξ,t≡u ⊢ \t("t") : C)
}{
  Σ, x:ι ⊢ (Γ,x:\f("A | t≡u");Δ;Ξ ⊢ \t("t") : C)
}
$$

(* ×i *)
$$
\unaryRN{×_i}{
  [Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("vi") : \f("Ai"))]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("{(li = vi) i∈I}") : \f("{(li : Ai) i∈I}"))
}
$$

(* ×e *)
$$
\binaryRN{×_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("{(li : Ai) i∈I}"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("v.lk") : A_k)
}
$$

(* +i *)
$$
\binaryRN{+_i}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("Ak"))
}{
  k∈I
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("Ci[v]") : \f("[(Ci : Ai) i∈I]"))
}
$$

(* +e *)
$$
\binaryRN{+_e}{
  Σ ⊢ (Γ;Δ;Ξ ⊢_\tval \v("v") : \f("[(Ci : Ai) i∈I]"))
}{
  [Σ ⊢ (Γ,x_i:A_i;Δ;Ξ,v≡\t("Ci[xi]") ⊢ t_i : B)]_{i∈I}
}{
  Σ ⊢ (Γ;Δ;Ξ ⊢ \t("[v | (Ci[xi] → ti) i∈I]") : B)
}
$$

(* ≡ *)
$$
\unaryRN{≡_{l, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔v]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ \t("t[x≔w]") : A)
}
$$

$$
\unaryRN{≡_{l}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₁]") : A)
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ \t("t[a≔u₂]") : A)
}
$$

$$
\unaryRN{≡_{r, {val}}}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔v]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,v≡w ⊢ t : \f("A[x≔w]"))
}
$$

$$
\unaryRN{≡_{r}}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₁]"))
}{
  Σ ⊢ (Γ;Δ;Ξ,u₁≡u₂ ⊢ t : \f("A[a≔u₂]"))
}
$$









=<
=> Soundness of the dependent product

... (* TODO *)

=<
=> The limits of value restriction

... (* TODO *)

=<

=<
