\Include{Macros}

The aim of this work is to provide a uniform environment in which programs
can be designed and proved. The idea is to combine a practical programming
language, with an enriched type-system allowing the specification of
computational behaviours.

=> Historical considerations

... (* TODO *)

=<
=> Proving \sc{ml} programs

... (* TODO *)

=<
=> \sc{ml} programs as proofs

... (* TODO *)

=<
=> Realizability model

... (* TODO *)

=<
=> Bias toward undecidability

... (* TODO *)

=<
=> Thesis overview

The type-system of our new language is build incrementally throughout this
thesis. The starting point is a standard higher-order system known as
\sc{hol}. It is enriched here with product types (corresponding to \sc{ml}
records) and sum types (corresponding to \sc{ml} constructors). This system
is formally constructed in \chapter("hocml"), following a general
introduction to the concepts and formalisms of type theory and classical
realisability. Readers familiar with these theories may jump directly to
\chapter("svr"), which marks the start of the author's original contribution.

\mchapter("svr") establishes the 

(*
(* TODO *)
Le chapitre 2 constitue la partie centrale de ce travail de thèse. En
particulier il contient la définition formèle de notre langage avec sa
sémantique opérationnelle et la notion d'équivalence observationnelle
correspondante. En utilisant l'équivalence, une alternative à la «~value
restriction~» est proposée, ce qui permet d'obtenir un produit dépendant
utilisable directement. Une alternative pourrait être d'avoir recours à
des sucres syntaxiques invasifs qui pourraient poser un problème de
clareté sémantique pour l'utilisateur.

Le chapitre 3 se concentre sur les aspects pratiques de l'équivalence. En
effet, la notion sémantique d'équivalence ne peut pas être utilisée pour
une implémentation et ne peut donc pas être appliquée en pratique. Pour
palier à ce problème, nous dérivons des règles syntaxiques à partir de la
définition de l'équivalence. Ces dernières correspondrons grossièrement
aux règles de réduction de notre langage et on pourra les utiliser pour
implémanter une procédure de pseudo-décision pour l'équivalence.

Le chapitre 4 quant à lui modifie le système défini dans les chapitres 2
et 3 pour intégrer une notion de sous-typage. En particulier, le sous-typage
permet d'englober toutes les règles de typage qui n'ont aucun contenu
algorithmique. En particulier, tout l'indécidabilité du typage de notre
système sera contenue dans le sous-typage (et donc aussi dans
l'équivalence). Dans notre cadre, le sous-typage peut également être utilisé
pour définir plus petits et plus grands points fixes de types. Ceci nous
permet donc d'obtenir types récursifs et types co-récursifs de manière
élégante.

Finalement, le chapitre 5 contient une description de certaines parties
de notre implémantation. Des examples de programmes standard et moins
standard sont également fournis pour donner au lecteur une idée de
l'utilisabilité du système en pratique. Les exemples sont également
distribués avec le code source du prototype, afin que le lecteur puisse
s'essayer à les utiliser et à les modifier.
*)

Every aspect of the system has been implemented in a prototype, which is
distributed with this document.

=<
