\Include{Macros}

Program proving is inherently difficult and time consuming. This is probably
the reason why so few programmers care to show the correctness of their
programs formally.
(* *)
The aim of this thesis work is to provide a uniform environment in which
programs can be designed, specified and proved. The idea is to combine a
full-fledged programming language with an enriched type-system allowing
the specification of computational behaviours.
(* *)
Using such a tool, a programmer can adjust the level of guarantees to his
needs, by using more or less fine-grained specifications. The system can thus
be used as \sc{ml} for type-safe general programming, or as a proof assistant
for proving properties of \sc{ml} programs.
(* *)
In the system, there is no syntactic distinction between programs and proofs.
Consequently, programming and proving features can be used both in proofs and
in programs. For instance, proofs can be composed as programs (and with
programs) to form proof tactics. And in programs, unreachable branches can be
eliminated using proof mechanisms.
(* *)
The uniformity of the framework imply that programs and proofs can be refined
incrementally to obtain more guarantees.

=> \sc{ML}-style general programming

In this thesis, our first goal is the design of a new type system for a
statically typed functional programming language. We choose to consider a
call-by-value language similar to \sc{caml} or \sc{sml}, as they have proved
to be higly practical and efficient. In particular, our language provides
polymorphic variants and \sc{sml} style records, which are convenient for
encoding datatypes. As an example, the type of lists and the corresponding
length function can be defined as follows in our language.
### OCaml

type rec List(A) = [ Nil | Cons of { hd : A ; tl : List(A) } ]

val rec length : /\A List(A) -> int = function
  | Nil    -> 0
  | Cons c -> 1 + (length c.tl)

###
Like in \sc{caml} or \sc{sml}, polymorphism can be used to make definitions
as general as possible. For instance, the previous function ##length## can
be applied to lists containing elements of arbitrary types. In our system,
we do not limit ourselves to let-polymorphism: universal quantification is
allowed anywhere in types. Our type system hence contains the full power of
Jean-Yves Girard and John Reynold's System F.



(* TODO *)

=<
=> \sc{ml} programs as proofs

... (* TODO *)

=<
=> Realizability model

... (* TODO *)

=<
=> Subtyping

Polymorphism and subtyping are essential for programming in a generic way.
They lead to programs that are shorter, easier to understand and hence more
reliable.


=<
=> Bias toward undecidability

... (* TODO *)

=<
=> Thesis overview

The type-system of our new language is built incrementally throughout this
thesis. Our starting point is a higher-order language enriched with product
types (corresponding to \sc{sml} records), sum types (corresponding to
\sc{OCaml} polymorphic variants) and control operators. This system is
formally constructed in \chapter("hocml"), following a general introduction
to the concepts and formalisms of type theory and classical realisability.
It is then enriched, in \chapter("pml"), with new types allowing the
specification of program equivalences. In particular, the system is extended
with a dependent product type. However, the expressivity of this dependent
product type is limited due to value restriction. A solution to this
problem is proposed in \chapter("svr"), and value restriction is relaxed.
A realizability model is then constructed to show the soundness of this new
approach. In particular, the property that the biorthogonal completion of
a set of value is closed for values is required.


(*
(* TODO *)
Le chapitre 3 se concentre sur les aspects pratiques de l'équivalence. En
effet, la notion sémantique d'équivalence ne peut pas être utilisée pour
une implémentation et ne peut donc pas être appliquée en pratique. Pour
palier à ce problème, nous dérivons des règles syntaxiques à partir de la
définition de l'équivalence. Ces dernières correspondrons grossièrement
aux règles de réduction de notre langage et on pourra les utiliser pour
implémanter une procédure de pseudo-décision pour l'équivalence.

Le chapitre 4 quant à lui modifie le système défini dans les chapitres 2
et 3 pour intégrer une notion de sous-typage. En particulier, le sous-typage
permet d'englober toutes les règles de typage qui n'ont aucun contenu
algorithmique. En particulier, tout l'indécidabilité du typage de notre
système sera contenue dans le sous-typage (et donc aussi dans
l'équivalence). Dans notre cadre, le sous-typage peut également être utilisé
pour définir plus petits et plus grands points fixes de types. Ceci nous
permet donc d'obtenir types récursifs et types co-récursifs de manière
élégante.

Finalement, le chapitre 5 contient une description de certaines parties
de notre implémantation. Des examples de programmes standard et moins
standard sont également fournis pour donner au lecteur une idée de
l'utilisabilité du système en pratique. Les exemples sont également
distribués avec le code source du prototype, afin que le lecteur puisse
s'essayer à les utiliser et à les modifier.
*)

Every aspect of the system has been implemented in a prototype, which is
distributed with this document.

=<
